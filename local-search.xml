<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络请求过程【持续迭代】</title>
    <link href="/2022/05/17/net-process/"/>
    <url>/2022/05/17/net-process/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>受到《计算机网络 - 自顶向下方法》 的启发，按照网络请求的过程，总结自己的网络知识，按照时间线，画了一张图，xmind 导出的图比较大，后续持续更新。</p><p><img src="/img/net/net_proceed_process.png" alt="网络请求过程"></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
      <tag>Http</tag>
      
      <tag>Net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档系统_程序员如何写好文档 (The documentation system)</title>
    <link href="/2021/10/03/the-documentation-system_how_to_write_good_document/"/>
    <url>/2021/10/03/the-documentation-system_how_to_write_good_document/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>文档是日常开发过程中非常重要的记录和交流的工具,也是学习新技术必然要阅读的材料.学习技术的时候,都会建议直接看官方文档,不同的技术网站,会看到 <strong>Guide</strong>,<strong>Tutorial</strong>,<strong>Wiki</strong>,<strong>Reference</strong> 等分类(也可能只包含其中一个或者几个). 我之前就一直对这几个英文单词有疑问,尤其是我在看 Android 开发者官网的时候,不明白每个分类的依据,间接导致,自己也没有学会如何写文档.后来发现了这篇文章,读完觉得很有道理. <a href="https://documentation.divio.com/introduction/">The documentation system</a>,窃以为非常好,值得我进行模仿学习.</p><p>以下的内容会进行自我理解的翻译,有意无意的删除一些冗余的修辞,如有幸被网上邻居搜到,建议看原文,非常简单.</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>为了编写良好的软件文档,需要说一个秘密: 没有一个名为文档的东西,文档应该是四样东西的集合.</p><p>这四样分别是是：<code>tutorials</code>(教程),<code>how-to guides</code>(如何做的引导),<code>technical reference</code> (技术参考),<code>explanation</code>(解释). 它们代表四种不同的目的或职能,并且这四种的写作方式都有差异.了解了这些差异,通常能巨大的提高文档的质量.</p><h2 id="关于即将描述的文档系统"><a href="#关于即将描述的文档系统" class="headerlink" title="关于即将描述的文档系统"></a>关于即将描述的文档系统</h2><p><img src="https://documentation.divio.com/_images/overview.png" alt="System"><br>这里的文档系统是非常简单的,近乎于全面适用行业内的方案.行文有个承诺: 如果将这些原则在实践中进行应用,将极大的提高写作文档的质量.</p><p>有很多公司/组织/开源项目采用了本文所述的方案,详细见链接<a href="https://documentation.divio.com/adoption/#adoption">采用本方案的项目</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="问题和解决方案"><a href="#问题和解决方案" class="headerlink" title="问题和解决方案"></a>问题和解决方案</h2><h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><p>如果文档不够好,产品再好,人们也不会使用它.即使人们必须使用它,那也是因为他们别无选择,没有良好的文档,人们无法如你期望的那样使用你开发的产品.</p><p>当然了,每个人都知道文档的重要性,每个人也都尝试去写好文档,最终也都失败了.</p><p>这也不是写作的人不够努力,通常是他们没有按照正确的方式去做而已.</p><p>本文介绍的文档系统,不是为了让你更加努力的工作,而是让你写作的文档更好,使用正确的方式进行写作,让文档更加易懂,更加容易维护: The right way is the easier way.</p><h3 id="文档系统的秘密"><a href="#文档系统的秘密" class="headerlink" title="文档系统的秘密"></a>文档系统的秘密</h3><p>有一个不应该是秘密的秘密: 文档应该围绕四种不能的功能目的进行构造: <code>tutorials</code>(教程),<code>how-to guides</code>(如何做的引导),<code>technical reference</code> (技术参考),<code>explanation</code>(解释).每一种都需要有独立的写作模式. 软件的使用者在不同的情况下,需要不同的文档,故而,大部分的软件,对于这四种文档,都需要包含. </p><p>文档将围绕这四种进行构建,并且四种文档需要独立的创建.</p><table><thead><tr><th align="center"></th><th align="center">Tutorials(教程)</th><th align="center">How-to guides(如何做的引导)</th><th align="center">Reference(技术参考)</th><th align="center">Explanation(解释)</th></tr></thead><tbody><tr><td align="center">oriented to(面向的/目的/导向)</td><td align="center">学习</td><td align="center">有一个固定的目标</td><td align="center">传达信息</td><td align="center">为了更深的理解</td></tr><tr><td align="center">must (必须做到)</td><td align="center">让一个初学者上手</td><td align="center">演示如何解决一个特定的问题</td><td align="center">描述技术的内部参数等</td><td align="center">深层次的解释</td></tr><tr><td align="center">its form(形式)</td><td align="center">一节课</td><td align="center">一些列的步骤</td><td align="center">纯粹的描述</td><td align="center">用文字进行阐述说明</td></tr><tr><td align="center">analogy(类比)</td><td align="center">教一个孩子如何进行烹饪</td><td align="center">烹饪中的食谱</td><td align="center">百科全书里的文章</td><td align="center">关于烹饪的历史书</td></tr></tbody></table><p>如上这种划分,可以让作者清楚写什么内容,写在哪儿,如何写; 读者清楚去哪找想要的内容.这种划分,可以让作者从原先的一股脑的将一堆信息进行拼凑的状态中解脱,因为这种划分,按照职责划分,不同类型的文章只需要完成一样职责,写作时目的很明确,不再出现拼凑信息的情况.</p><p>坦白讲,那些不符合该方案的文档还是非常难以维护的.因为我们列出的 4 种类型针对的是 4 种不同的需求,一旦将这些需求对应的内容糅合在一个文档里的时候,文档的内容为了兼顾,肯定有相互之间的牵扯,读者就会被牵扯.</p><p>一旦理解了上述的方案,就会极大地提高文档的结构性,我们也就能知晓接下来采取什么方式提高我们的文档质量.</p><p>接下里的章节中,将会针对这四种类型的文档,分别进行详细的描述.</p><h3 id="让文档自己工作"><a href="#让文档自己工作" class="headerlink" title="让文档自己工作"></a>让文档自己工作</h3><h4 id="对于作者而言"><a href="#对于作者而言" class="headerlink" title="对于作者而言"></a>对于作者而言</h4><p>对于文档的作者而言,最大的难题是不知道他们该做这些什么. 作者为了让自己想表达的内容以合适的方式排列在一起,不停的写再重写,不停的反复.<br>通过这种文档系统结构,将会使得写作更加容易,因为该方案将文档进行明确的职责区分,将文档进行明确的隔离,这样使得写作和维护都很容易,也很容易使用和查找.<br>虽然说文档不能自己完成,但是现在编写文档的时候,可以做到不用操心哪些内容应该包含,哪些内容不应该包含.在职责明确的背景下,我们很容易知道在什么地方,写什么,怎么写.</p><h4 id="对于读者而言"><a href="#对于读者而言" class="headerlink" title="对于读者而言"></a>对于读者而言</h4><p>对于读者言,可以更好的与软件进行交互了,在试用的不同阶段,可以很快的找到自己需要的资料.<br>按照上述四个象限进行编写文档,有助于软件吸引和留住用户,他们可以快速接入,更加高效的使用软件.</p><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><p>Tutorials(教程) 是由课程组合而成,内容都是些课程,目的是带领读者通过一系列步骤来完成某种项目.项目的作者需要这些 Tutorials(教程 ),一次向初学者展示他们可以用作者的软件可以获取到的东西.</p><p>Tutorials(教程) 是以学习为导向的,具体来说,Tutorials(教程) 是教会学习者如何使用,成为一个使用者,而不是学习项目本身.</p><p>你作为作者就是个老师,读者就是个学生.你需要对你教授给学生的东西负责.学生在你的指导下,将会通过一系列的操作在最终获到你想传授的技能.</p><p>最终的结局和步骤,都取决于你.但是读者应该是什么样的人,却是无法预测的.结局对于初学者来说,必须有意义,而且必须有所收获.</p><p>有一个重要的事情需要说明,当学习者阅读完Tutorial时,他应该对剩下的文档内容心里有数了,对于这个软件本身也做到了心里有数.</p><p>大多数软件的Tutorial很差,甚至干脆没有.Tutorial是一个让学习者成为软件用户的契机.如果Tutorial很差,或者没有,获取新用户的难度会大很多.</p><p>在介绍四种文档的章节中,这部分是最难写的,因为Tutorial是最难理解,也最难做好的内容.</p><p>传授知识的最佳方式是现实中存在一个可以互动的老师.这基本是不可能的,所以我们写的Tutorial就是最好的替代品.这也能说明,我们需要格外的注意Tutorial的部分.</p><p>Tutorial 必须对初学者有用,简单有意义,而且紧跟软件的发版节奏,及时保持最新状态.</p><h2 id="和烹饪类比"><a href="#和烹饪类比" class="headerlink" title="和烹饪类比"></a>和烹饪类比</h2><p><img src="https://documentation.divio.com/_images/anselmo.jpg" alt="孩子学烹饪"><br>可以类比教一个孩子如何烹饪.</p><p>你教孩子做什么菜不重要.重要的是,孩子通过你的传授,发现了烹饪的乐趣,获得了自信并且想再次尝试.</p><p>孩子通过学习过程中所做的事情,将会学习到烹饪中最重要的事情.他将学会为了做一道鸡丝面,应该放些什么材料,而且知道如何处理这些材料.</p><p>这是因为,使用软件,和烹饪一样,是个手艺活.尽管说,他是需要知识,但是这些知识是实用性的,需要实际使用,而不是理论性的.</p><p>当我们学一门新的手艺和技巧的时候,总是从使用这个手艺或技巧开始.</p><h2 id="如何写好Tutorial-How-to-write-good-tutorials"><a href="#如何写好Tutorial-How-to-write-good-tutorials" class="headerlink" title="如何写好Tutorial (How to write good tutorials)"></a>如何写好Tutorial (How to write good tutorials)</h2><h3 id="让学习者在使用中学-Allow-the-user-to-learn-by-doing"><a href="#让学习者在使用中学-Allow-the-user-to-learn-by-doing" class="headerlink" title="让学习者在使用中学(Allow the user to learn by doing)"></a>让学习者在使用中学(Allow the user to learn by doing)</h3><p>在事情的初期阶段,我们通过实际使用来学.这也是我们学习说话和走路使用的方法.</p><p>在软件的Tutorial中,都是软件的初学者需要做的事情.学习者在阅读Tutorial后可以知晓,从一个简单入门的项目向一个更复杂的项目需要使用的工具和步骤.</p><h3 id="让学习者开始动起来-Get-the-user-started"><a href="#让学习者开始动起来-Get-the-user-started" class="headerlink" title="让学习者开始动起来 (Get the user started)"></a>让学习者开始动起来 (Get the user started)</h3><p>对于初学者进行手把手式的讲解,是让人更容易接受的.而不是将初学者当作一个经验丰富的用户.有时候,传授的内容可能不是所谓的“正确”方式,因为刚开始的时候,不要传授所谓的最佳实践.</p><p>Tutorial 的最核心的点是,让学习者开始行动起来,让他踏上使用的旅程,而不是要一次性将他们带到旅途的终点.</p><h3 id="确保Tutorial是可用的-Make-sure-that-your-tutorial-works"><a href="#确保Tutorial是可用的-Make-sure-that-your-tutorial-works" class="headerlink" title="确保Tutorial是可用的 (Make sure that your tutorial works)"></a>确保Tutorial是可用的 (Make sure that your tutorial works)</h3><p>作为指导者,还有一个很重要的任务,就是让学习者充满自信,自信于在你的指导下,通过软件,以自己的能力,可以完成Tutorial中要求的内容.</p><p>有很多的内容可以帮我们达到这个目的.一份措辞温和友好的帮助文档,连续且逻辑清晰的语言,都对此大有裨益.但是其中最重要的一点是,你让阅读者进行的操作案例必须是可用的.阅读学习者必须根据你的步骤能看到跟你说的一样的效果.</p><p>如果学习者在学习过程中,进行的操作不顺利,产生错误或者意想不到的结果,即使这个不是你的原因,你的Tutorial就算是失败了.学习者如果跟你面对面交流,那么你可以直接线下指导,但是绝大部分情况,都是直接阅读Tutorial的,那就很难直接指导.所以,在写作Tutorial的时候,就需要想方设法的我避免这个样的事情发生.</p><h3 id="确保阅读者的操作能获得及时反馈-Ensure-the-user-sees-results-immediately"><a href="#确保阅读者的操作能获得及时反馈-Ensure-the-user-sees-results-immediately" class="headerlink" title="确保阅读者的操作能获得及时反馈(Ensure the user sees results immediately)"></a>确保阅读者的操作能获得及时反馈(Ensure the user sees results immediately)</h3><p>学习者在过程中执行的所有操作应该是完成一些学习者阅读时已经可理解的操作,无论这个操作有多小,都必须让阅读者明白目的.试想一下,你的一个学生,在看到一个效果之前,需要阅读两页的文档,且执行一些自身都觉得奇怪的操作,这个过程也太长了.学习者进行的每一步操作,应该做到尽快明显且可见.,执行的动作和效果之间的联系也需要清晰明了.</p><p>Tutorial整体或者其中的任一章节结束的时候,他的结尾,都必须是个有意义的总结,让学习者一顿操作下来是有意义的.</p><h3 id="让你的Tutorial是重复的-可反复操作的-Make-your-tutorial-repeatable"><a href="#让你的Tutorial是重复的-可反复操作的-Make-your-tutorial-repeatable" class="headerlink" title="让你的Tutorial是重复的,可反复操作的(Make your tutorial repeatable)"></a>让你的Tutorial是重复的,可反复操作的(Make your tutorial repeatable)</h3><p>你的Tutorial必须是非常可靠,可复现的.这点并不容易,原因在于,学习者使用的操作系统可能不一样,经验和使用工具的水平并不一样,更重要的是,学习者使用的软件和资料也与此同时发生了变化.</p><p>Tutorial必须适应这么多情况,在这些情况下都能正常工作.</p><p>所以 Tutorial 需要定期进行详细的测试,以保证它持续的有效.</p><h3 id="聚焦在具体的步骤中-而不是抽象的概念里-Focus-on-concrete-steps-not-abstract-concepts"><a href="#聚焦在具体的步骤中-而不是抽象的概念里-Focus-on-concrete-steps-not-abstract-concepts" class="headerlink" title="聚焦在具体的步骤中,而不是抽象的概念里(Focus on concrete steps, not abstract concepts)"></a>聚焦在具体的步骤中,而不是抽象的概念里(Focus on concrete steps, not abstract concepts)</h3><p>Tutorial 必须是具体的,围绕着规格说明进行开展的,有明确的步骤和步骤对应的结果.</p><p>进行抽象概念的介绍的诱惑力太大,毕竟,计算机的强大也是来自于此,然而,大多数的学习都是由具体到抽象,反过来是个比较糟糕的学习方式.</p><h3 id="必要的解释要尽量的少-Provide-the-minimum-necessary-explanation"><a href="#必要的解释要尽量的少-Provide-the-minimum-necessary-explanation" class="headerlink" title="必要的解释要尽量的少(Provide the minimum necessary explanation)"></a>必要的解释要尽量的少(Provide the minimum necessary explanation)</h3><p>在完成 Tutorial 中不需要了解的知识,不要进行解释.额外的扩展和讨论是可以的,但是不应该出现在 Tutorial 中.在 Tutorial 中,只会令学习者分心,还会干扰学习目的.只有必要的解释才可以放在这部分,其他的可以提供链接导航.</p><h3 id="关注于哪些用户需要执行的步骤-Focus-only-on-the-steps-the-user-needs-to-take"><a href="#关注于哪些用户需要执行的步骤-Focus-only-on-the-steps-the-user-needs-to-take" class="headerlink" title="关注于哪些用户需要执行的步骤 (Focus only on the steps the user needs to take)"></a>关注于哪些用户需要执行的步骤 (Focus only on the steps the user needs to take)</h3><p>Tutorial 需要关注的是手头的任务.也许你的命令还有很多的其他的可选项,也许你的API还有很多其他的使用方式,但是对于学习者当前的任务而言,并不需要. </p><h2 id="Divio-中的一个-Tutorial-例子-Example-from-Divio’s-documentation"><a href="#Divio-中的一个-Tutorial-例子-Example-from-Divio’s-documentation" class="headerlink" title="Divio 中的一个 Tutorial 例子(Example from Divio’s documentation)"></a>Divio 中的一个 Tutorial 例子(Example from Divio’s documentation)</h2><p>可以看下这个 <a href="https://docs.divio.com/en/latest/introduction/">Tutorial</a><br><img src="https://documentation.divio.com/_images/django-tutorial-example.png" alt="Django"></p><p>可以着重看下关于 Django 的 Tutorial,如图所示,其实就是在承诺,如果学者具备了基本的前提能力,并且按照文档所述的步骤一步一步的执行,当阅读完之后,将会完成一个用 Django 实现的web应用,其中数据库中用的是 Postgress, S3实现的媒体存储等等.为了达成这样的目标,Tutorial 就需要一步一步填充这些内容.</p><p>注意,Tutorial 目录都没有指明学习什么,而聚焦在应该做些什么,做什么的顺序.</p><h1 id="如何做的指南-How-to-guides"><a href="#如何做的指南-How-to-guides" class="headerlink" title="如何做的指南(How-to guides)"></a>如何做的指南(How-to guides)</h1><p>“How-to-guides”是通过指引读者进行一系列的步骤以解决现实中特定的问题。</p><p>Guide 是食谱，是为了解决一个特定问题的指导方案。举个例子，如何创建一个web表单；如何启用LDAP权限验证。</p><p>guide始终是目标为导向的。</p><p><strong>Guide 和 Tutorial完全不同，二者的编写目的和面向的目标都不一样</strong>，对此必须有清晰的认识。具体来说，有几下几个差异</p><ul><li>Tutorial 是你作为一个作者，想让读者作为一个初学者，需要知道的内容。是作者认为初学者应该知道的。</li><li>Guide 是面向有经验的用户，为的是解决他们的一个实际问题。</li><li>在编写 Guide 的时候，作者可以假设读者已经具备了常规的知识和理解。可以假设读者已经具备了操作使用作者的软件所需要的基础能力和基本的工具。</li><li>和 Tutorial 不同的是, Guide 是比较容易写好的，这部分内容是比较轻松，比较容易写的。</li></ul><h2 id="和烹饪类比-1"><a href="#和烹饪类比-1" class="headerlink" title="和烹饪类比"></a>和烹饪类比</h2><p><img src="https://documentation.divio.com/_images/recipe.jpg" alt="食谱"></p><p>可以想象成某样食物的食谱。</p><p>食谱必须清晰明了，有明确的定义。他们描述了一个明确的问题。食谱在向一个有基本烹饪经验的人，如何完成食物的烹饪过程。</p><p>从来没有任何烹饪经验的人，只靠食谱，是很难完成一道菜的烹饪的，所以说，食谱本来不是烹饪课的一部份。与此同时，如果有经验的厨师，发现食谱在描述一些他们早就掌握的基础能力，基础的技巧，他们就会很愤怒。</p><h2 id="如果编写一份好的guide-How-to-write-good-how-to-guides"><a href="#如果编写一份好的guide-How-to-write-good-how-to-guides" class="headerlink" title="如果编写一份好的guide(How to write good how-to guides)"></a>如果编写一份好的guide(How to write good how-to guides)</h2><h3 id="提供一系列的步骤-Provide-a-series-of-steps"><a href="#提供一系列的步骤-Provide-a-series-of-steps" class="headerlink" title="提供一系列的步骤(Provide a series of steps)"></a>提供一系列的步骤(Provide a series of steps)</h3><p>Guide 必须包含一些读者必须操作的步骤（这个在 Tutorial 也有类似的需求）。作者并不需要从头开始描述步骤，以一个相对合理的点进行开始描述即可。Guide 必须是可靠的，但是，Guide 并不需要保证像 Tutorial 一样的可重复性。</p><h3 id="聚焦于结果-Focus-on-results"><a href="#聚焦于结果-Focus-on-results" class="headerlink" title="聚焦于结果(Focus on results)"></a>聚焦于结果(Focus on results)</h3><p>Guide 必须聚焦于某个特定的目标。与目标无关的任何其他事情都是分心的。和 Tutorial 一样，详细的解释并不适合放这儿。</p><h3 id="解决某个特定的问题-Solve-a-particular-problem"><a href="#解决某个特定的问题-Solve-a-particular-problem" class="headerlink" title="解决某个特定的问题(Solve a particular problem)"></a>解决某个特定的问题(Solve a particular problem)</h3><p>Guide 必须的标题命名也必须是有明确指向一个问题的，比如： 如何。。。</p><p>Guide 和 Tutorial 的另一个不同点是，阅读 Guide 的人知道自己阅读 Guide 需要什么，最终的目的是什么，他们已经知道阅读完 Guide 自己将获得什么，他们只是不知道该怎么做而已。而对于 Tutorial 而言，读者其实并不知道自己将获得什么，读者阅读完获得的内容，完全是由作者说了算。</p><h3 id="不要解释概念-Don’t-explain-concepts"><a href="#不要解释概念-Don’t-explain-concepts" class="headerlink" title="不要解释概念(Don’t explain concepts)"></a>不要解释概念(Don’t explain concepts)</h3><p>guide中不需要解释任何东西，guide只适合放些解决问题的步骤，如果有解释的需求，可以进行超链接。</p><h3 id="也许允许存在一些弹性变通-Allow-for-some-flexibility"><a href="#也许允许存在一些弹性变通-Allow-for-some-flexibility" class="headerlink" title="也许允许存在一些弹性变通(Allow for some flexibility)"></a>也许允许存在一些弹性变通(Allow for some flexibility)</h3><p>一份 Guide 针对同一件事应该是允许存在一些不同的处理方式的。Guide中能让读者采取变通的地方应该做到显而易见。不要让guide太过特殊，一点通用型和灵活性都没有。</p><h3 id="Leave-things-out-将事情抛诸脑后"><a href="#Leave-things-out-将事情抛诸脑后" class="headerlink" title="Leave things out(将事情抛诸脑后)"></a>Leave things out(将事情抛诸脑后)</h3><p>实用性比完整性更有价值.Tutorial (教程)需要是完整的,有头有尾的指导. Guide 并不需要这样.Guide 可以从作者认为合适的地方开始和结束。Guide 也不需要提及那些仅仅因为它与主题相关,但是并不是关键内容的部分.臃肿的 Guide 并不能帮助用户快速找到解决方案.</p><h3 id="名字很重要-Name-guides-well"><a href="#名字很重要-Name-guides-well" class="headerlink" title="名字很重要(Name guides well)"></a>名字很重要(Name guides well)</h3><p>Guide 的标题很重要,标题必须能准确告诉读者,文章的内容具体是干什么的. “How to create a class-based view (如何创建一个基于类的视图)” 就是个很好的标题. 然而像 “(Creating a class-based)创建基于类的视图” 和 “Class-based views (基于类的视图)”就更差劲了.</p><h2 id="Divio-中的-Guide-例子-Example-from-Divio’s-documentation"><a href="#Divio-中的-Guide-例子-Example-from-Divio’s-documentation" class="headerlink" title="Divio 中的 Guide 例子(Example from Divio’s documentation)"></a>Divio 中的 Guide 例子(Example from Divio’s documentation)</h2><p>看一下这个文档<a href="https://docs.divio.com/en/latest/how-to/">our how-to guides</a>.<br><img src="https://documentation.divio.com/_images/django-how-to-example.png" alt="Divio中的例子"></p><p>这里的每个标题都是在说明内容是一个问题的答案. “how do I…? (如何解决…如何做到…)”. 这些标题里都是在阐述类似的概念”how to “.  每一个都是一道菜的食谱,都会引导读者完成对应的菜.</p><p>虽然我在 Tutorial 和 Guide 都是服务用户的需求.但是,Tutorial 的内容是作者在告诉读者,作者认为读者应该知道的内容. 然而,Guide,是作者在回答读者问的问题.</p><h1 id="参考-Reference-guides"><a href="#参考-Reference-guides" class="headerlink" title="参考(Reference guides)"></a>参考(Reference guides)</h1><p>Reference是机械的技术说明，说明如何进行操作。</p><p>Reference只有一个职责，就是进行描述。Reference是面向代码的。从根本上说，描述了关键的class，函数，API，以及罗列一些字段属性，还有方法，同时呢，说明如何使用它们。</p><p>Reference是信息导向的。</p><p>无论如何，尽管Reference可以包含一些example来演示使用方式，然而呢，依旧不应该试图解释一些基本概念和如何完成常规的需求。</p><p>Reference应该是简单直切主题的。</p><p>请注意，Reference的描述应该是包含一些机理的基本描述。如：如何初始化一个类，如何调用一个方法，例子，以及调用方法时，参数的限制等等。</p><p>对于一些开发者而言，Reference是他们唯一能想到的文档了。他们已经对软件非常熟悉了，也知晓了如何使用了。他们认为学习者就需要这些文档。</p><p>Reference比较容易写好，甚至在某种程度上来说，都可以自动生成。但是这还远远不够。 </p><h2 id="和烹饪进行类比-Analogy-from-cooking"><a href="#和烹饪进行类比-Analogy-from-cooking" class="headerlink" title="和烹饪进行类比(Analogy from cooking)"></a>和烹饪进行类比(Analogy from cooking)</h2><p><img src="https://documentation.divio.com/_images/ginger.jpg" alt="生姜"></p><p>想象一下百科全书上有一篇关于生姜作为原材料的文章。</p><p>当你在Reference中查询生姜时，你想要获取的信息都是些像起源，表现，化学机理，以及如何进行烹饪。</p><p>你希望你检索的任何食材都以类似的方式展示信息。而且你希望获取一些基本扩展信息，比如生姜家族还有姜粉，还有豆蔻等等。</p><p>还有一些潜在问题风险也是我们想获取的。比如。生姜可能会导致胃灼热，与一些抗凝血的药一起食用会有副作用。</p><h2 id="如何写一篇好的-Reference-How-to-write-good-reference-guides"><a href="#如何写一篇好的-Reference-How-to-write-good-reference-guides" class="headerlink" title="如何写一篇好的 Reference(How to write good reference guides)"></a>如何写一篇好的 Reference(How to write good reference guides)</h2><h3 id="Reference是围绕代码进行结构的组织-Structure-the-documentation-around-the-code"><a href="#Reference是围绕代码进行结构的组织-Structure-the-documentation-around-the-code" class="headerlink" title="Reference是围绕代码进行结构的组织(Structure the documentation around the code)"></a>Reference是围绕代码进行结构的组织(Structure the documentation around the code)</h3><p>将reference的结构和代码的结构保持一致，这样使用者看代码的同时，可以同时看到reference。这种方式也有利于开发维护文档，及时知晓哪块缺少文档，哪块需要更新。</p><h3 id="保持连贯性-Be-consistent"><a href="#保持连贯性-Be-consistent" class="headerlink" title="保持连贯性(Be consistent)"></a>保持连贯性(Be consistent)</h3><p>在书写Reference的过程中，结构，语气和格式都需要保持一致。就像一本百科全书和字典那样。</p><h3 id="只做内容描述-Do-nothing-but-describe"><a href="#只做内容描述-Do-nothing-but-describe" class="headerlink" title="只做内容描述(Do nothing but describe)"></a>只做内容描述(Do nothing but describe)</h3><p>技术Reference只需要尽可能的描述完整，描述清楚就行。其他的像解释，讨论，指导，命令，猜测，观点等等，不仅会让读者分心，也会让Reference难以使用，维护困难。可以在适当的时候，在Reference中提供简单的example进行演示。</p><p>不要在Reference中忍不住指引读者，使用超出基本操作之外的操作来完成某项完整的需求.更不要在 reference 中试图对一些概念进行解释或者进行一些主题讨论.相反,如果有类似的需求,可以放一个链接,导航到 Guide,Explanation 和 Tutorial 部分.</p><h3 id="一定要精确-Be-accurate"><a href="#一定要精确-Be-accurate" class="headerlink" title="一定要精确 (Be accurate)"></a>一定要精确 (Be accurate)</h3><p>Reference 这部分的内容必须时刻保持最新,紧跟软件的更新和发展,但凡 reference 和软件有一丝的不一致,就可能将读者或者用户带入沟里.</p><h2 id="以Divio的文档作为例子-Example-from-Divio’s-documentation"><a href="#以Divio的文档作为例子-Example-from-Divio’s-documentation" class="headerlink" title="以Divio的文档作为例子(Example from Divio’s documentation)"></a>以Divio的文档作为例子(Example from Divio’s documentation)</h2><p>可以看下这个链接里的<a href="https://docs.divio.com/en/latest/reference/divio-cli">例子</a> </p><p><img src="https://documentation.divio.com/_images/django-reference-example.png" alt="Divio CLI"></p><p>这是个典型的 Reference 文档,这里是展示的命令行工具的解释.</p><p>这里的描述就是如本文上述的内容一样,完整而精确地展示了这个工具的的功能,命令以及命令的参数.</p><p>这部分的内容的易读性可能没那么好,但是这部分的目的是为了尽快无干扰的找到相关功能的信息.</p><h1 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h1><p>Explanation(解释) 或者 discussion(讨论)是要阐明一个特定的主题. 这其实扩大了文档对主题的覆盖范围.</p><p>Explanation(解释) 是面向理解的.</p><p>Explanation(解释) 本质上也可以等价于 discussions(讨论) ,他们其实都比较散漫.Explanation(解释)  是在跳出了软件本身,从更高的视野和不同的角度在解释和阐明软件.你可以想象,你的用户在闲暇时间,希望阅读的是文档,而不是源码.</p><p>很少有人明确的创建Explanation(解释) 这一章节.而是本该属于这章节的内容分散在了其他的章节里.有时,文档里有对应Explanation(解释) 应有内容的章节,但是这些章节都命名成了”背景”,或者其他主题形式的记录,这就导致这些命名不能很好的表征内容.</p><p>Discussions (讨论)并没有看上去的那么容易,想象一下,你手里有张白纸,这时候,有人问了一个问题,该如何进行回答和讨论?</p><p>一个topic (主题)不是像 Guide(指南) 一样,解决一个特定的问题,传授一些特有的步骤; 也不是像tutorial(教程)一样,在向读者传授你认为读者他们应该掌握的内容.也不是由机器来决定的 reference . 这部分的内容完全是有作者自己来界定讨论的内容,以及覆盖的范围.所以这部分的内容看上是比较随意的.</p><h2 id="类比烹饪-Analogy-from-cooking"><a href="#类比烹饪-Analogy-from-cooking" class="headerlink" title="类比烹饪(Analogy from cooking)"></a>类比烹饪(Analogy from cooking)</h2><p><img src="https://documentation.divio.com/_images/mcgee.jpg" alt="烹饪"></p><p>考虑下,在进行历史,科技和科学的上下文和背景下,进行烹饪的讨论. 讨论的内容会是烹饪和厨房.</p><p>这部分讨论的内容并不是传授如何烹饪,也不是食谱的集合. 这部分内容只是在进行描述.</p><p>相反的,这部分内容是在从多个角度进行阐述分析问题. 可能是在解释为什么我们今天会如此处理事情,或者事情的处理如何糟糕,甚至会描述替代的方案.</p><p>这部分内容会加深我们对知识的理解,即使这部分内容并不是立马可应用于实际的业务场景中,但是这部分内容的价值并不是靠在实际的生产应用中体现.</p><p>当我们需要闲暇事件,离开厨房的时候,从更高的层次上,来加深对烹饪的理解时,了解更多关厨房的主题时,我们就会选择阅读这部分内容.</p><h2 id="如何写好一份-explanation-How-to-write-a-good-explanation"><a href="#如何写好一份-explanation-How-to-write-a-good-explanation" class="headerlink" title="如何写好一份 explanation(How to write a good explanation)"></a>如何写好一份 explanation(How to write a good explanation)</h2><h3 id="提供上下文环境-Provide-context"><a href="#提供上下文环境-Provide-context" class="headerlink" title="提供上下文环境(Provide context)"></a>提供上下文环境(Provide context)</h3><p>Explanations 可以用来提供上下文和背景. 例如,在 Django或者 CMS 中如何处理 Web  表单.</p><p>在这部分,可以解释为什么是如此处理,相关的设计决策,历史原因,技术限制等等.</p><h3 id="讨论替代方案和建议意见-Discuss-alternatives-and-opinions"><a href="#讨论替代方案和建议意见-Discuss-alternatives-and-opinions" class="headerlink" title="讨论替代方案和建议意见(Discuss alternatives and opinions)"></a>讨论替代方案和建议意见(Discuss alternatives and opinions)</h3><p>Explanation  可以考虑进行替代方案,或者同一问题的多种不同解决方案.举个例子,在一篇关于 Django 部署的文章中,可以讨论和评估不同的服务器部署.</p><p>Discussions  也可以用来讨论两种相反的意见和选择. 举个例子,是否需要将测试模块放入源码工程的包下面.</p><h3 id="不要进行指导-也不要提供技术支持-Don’t-instruct-or-provide-technical-reference"><a href="#不要进行指导-也不要提供技术支持-Don’t-instruct-or-provide-technical-reference" class="headerlink" title="不要进行指导,也不要提供技术支持(Don’t instruct, or provide technical reference)"></a>不要进行指导,也不要提供技术支持(Don’t instruct, or provide technical reference)</h3><p>Explanation 应该做一些其他部分的文档没有做的事情. Explanation 不适合对读者进行指导如何进行操作,也不适合提供技术解决方案.这些内容都是其他文档的职责.</p><h2 id="Example-from-Divio’s-documentation"><a href="#Example-from-Divio’s-documentation" class="headerlink" title="Example from Divio’s documentation"></a>Example from Divio’s documentation</h2><p>Divio 文档中的一个<a href="https://docs.divio.com/en/latest/reference/divio-cli">例子</a></p><p><img src="https://documentation.divio.com/_images/divio-explanation-example.png" alt="Divio"><br>看一眼这个文档, our explanation section (名称是“Background” -名字并不重要,阐释的主题和内容更加重要).</p><p>这些文章没有教任何东西. 他们不会告诉读者该做什么.它们不是 reference . 他们只是讨论特定的话题.举个例子, 读者不需要知道 缓存 或 CDN 亦或是如何管理环境变量来使用平台或完成任何特定任务,但是阅读完这些内容之后,读者的经验和平台的使用能力都会更加清晰,理解也会更加深刻.</p><p>这些文章的内容提供了一个更加广阔的图景,更加清晰地上下文. 读者作为一个用户,作为一个使用方,也许他们并不需要知道处理一个问题的方式为何如此.但是当他们知道这些背景和缘由之后,他们会对产品更加满足,自身也会更加的快乐.</p><h1 id="关于文档的结构-About-the-structure"><a href="#关于文档的结构-About-the-structure" class="headerlink" title="关于文档的结构(About the structure)"></a>关于文档的结构(About the structure)</h1><h2 id="为什么这个不明显-Why-isn’t-this-obvious"><a href="#为什么这个不明显-Why-isn’t-this-obvious" class="headerlink" title="为什么这个不明显(Why isn’t this obvious?)"></a>为什么这个不明显(Why isn’t this obvious?)</h2><p>这个结构是非常清晰的,而且是能其效果的. 但是为什么让人觉得这个结构没那么明显呢?原因是,这四个类型的文档,处在四个象限,每个象限的和其相邻的象限在特征上是有重叠.</p><p><img src="https://documentation.divio.com/_images/overview.png" alt="四种文档"><br>从上图中可以看到,每个象限都和邻居有重叠.</p><blockquote><p>Tutorials 和 Guides  都有描述操作步骤;<br>Guides 和 Reference 都有关于我们在工作时应该做的内容.<br>Reference 和 Explanation 都有理论知识的内容.<br>Tutorials 和 Explanation 相较于实际的工作内容,对学习有莫大的帮助.</p></blockquote><h3 id="坍塌的趋势-The-tendency-to-collapse"><a href="#坍塌的趋势-The-tendency-to-collapse" class="headerlink" title="坍塌的趋势(The tendency to collapse)"></a>坍塌的趋势(The tendency to collapse)</h3><p>考虑到这些文档之间的重叠部分,不同类型的文档相互之间变得混淆并相互混合也就不足为奇了.事实上,这些不同类型的文档彼此之间存在一种难以抗拒的力量,让他们之间纠缠不清.它的作用是坍塌式的结构,这就是为什么这么多文档看起来像这样.<br><img src="https://documentation.divio.com/_images/collapse.png" alt="文档之间坍塌"></p><h1 id="省略的内容"><a href="#省略的内容" class="headerlink" title="省略的内容"></a>省略的内容</h1><p>后面有一些使用本结构的文档链接和介绍,就不再翻译了.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章中最后也有说明,不是所有的文档都需要具备齐全这四种类型,最重要的是,知道有这四种类型,注意阅读者的分级分层,内容的重点和意图.</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Documentation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mySoftware</title>
    <link href="/2021/07/06/mySoftware/"/>
    <url>/2021/07/06/mySoftware/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>记录我平时使用的一些软件,提效的,娱乐的.</p><span id="more"></span><h1 id="快速打开"><a href="#快速打开" class="headerlink" title="快速打开"></a>快速打开</h1><p><a href="https://raycast.com/">Raycast</a><br><a href="https://www.alfredapp.com/">Alfred</a><br><a href="https://contexts.co/">Contexts</a></p><h2 id="目的-用于快速打开应用软件和文件夹"><a href="#目的-用于快速打开应用软件和文件夹" class="headerlink" title="目的: 用于快速打开应用软件和文件夹"></a>目的: 用于快速打开应用软件和文件夹</h2><p>其中比较知名的就是 Alfread了,我目前把它和Context进行配合使用.</p><p>Raycast 和 Alfred 差不多,Raycast 我装了,但是用的频率不高,目前没发现他有什么特别的亮点,用来作为 Alfred 的备选,毕竟免费.</p><p>Context有一个feature就是可以切换window,比如,AndroidStudio里打开了多个Project,形成了多个window,这说话,直接Alfred打开Androidstudio的话,只是打开了软件,至于哪个Window,有时候不清楚,这种情况下,Context 是个很好的补充.<br>Context 的缺陷就是,他只是用来打开,已有的窗口的.</p><h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p><a href="https://pinyin.sogou.com/mac/">搜狗输入法</a></p><p>目前国内也就搜狗输入法还行了,当然百度也有Mac版本,但是体验上,还是搜狗好点.</p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p><a href="https://iterm2.com/">iterm2</a><br><a href="https://ohmyz.sh/">oh-my-zsh</a><br>Mac 下很好的终端工具了.目前没发现其他替代品;</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://git-fork.com/">fork</a><br>Native开发,相比对sourceTree,颜值和性能都更高,无他,颜值即正义.</p><h1 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h1><p><a href="https://developer.android.com/studio">AndroidStudio</a></p><p>开发Android必备,只是有一点至今让我诟病的地方,就是ActivityStack的打印被删除了…</p><h1 id="C-Cpp开发"><a href="#C-Cpp开发" class="headerlink" title="C/Cpp开发"></a>C/Cpp开发</h1><p><a href="https://www.jetbrains.com/clion/">Clion</a></p><p>VSC配置cpp开发环境也试过,繁琐.Mac 下的Xcode也用过,感觉一般, 不得不说,jetbrains做的IDE,真香.</p><h1 id="Java开发"><a href="#Java开发" class="headerlink" title="Java开发"></a>Java开发</h1><p><a href="https://www.jetbrains.com/idea/">IntellijIdea</a><br><a href="https://www.eclipse.org/downloads/">Eclipse</a><br><a href="https://netbeans.apache.org/download/index.html">NetBeans</a></p><p>目前在用的就是 IntellijIdea 了,其他的基本不用了.只有一个 NetBeans 在某些场景下是有优势的,那就是JavaSE GUI开发的时候.</p><h1 id="清除广告"><a href="#清除广告" class="headerlink" title="清除广告"></a>清除广告</h1><p><a href="https://apps.apple.com/us/app/adblock-pro-for-safari/id1018301773">AdBlock Pro</a> 清除Safari广告用;<br>看动漫太多的广告了,Chrome 上清除广告很容易,Safari就只能依赖这个plugin了.</p><h1 id="database"><a href="#database" class="headerlink" title="database"></a>database</h1><p><a href="https://www.jetbrains.com/datagrip/">DataGrip</a><br>一个客户端,支持查看所有的数据库,jetbrains太香了.</p><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><p><a href="https://macgrid.app/">Grid</a></p><p>windows 系统有个自动管理窗口的功能,这个软件就是在Mac上实现类似的功能;</p><h1 id="扩展屏幕"><a href="#扩展屏幕" class="headerlink" title="扩展屏幕"></a>扩展屏幕</h1><p><a href="https://github.com/pavlobu/deskreen">Deskreen</a><br>只要有个浏览器就可以实现屏幕的扩展,有时候可以将自己的iPad用上.</p><h1 id="statusbar-隐藏图标"><a href="#statusbar-隐藏图标" class="headerlink" title="statusbar 隐藏图标"></a>statusbar 隐藏图标</h1><p><a href="https://github.com/Mortennn/Dozer">Dozer</a><br><a href="https://www.macbartender.com/">Bartender</a></p><p>Dozer是开源的,Bartender 是收费的.</p><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p><a href="https://app.diagrams.net/">draw.io</a><br><a href="https://www.omnigroup.com/omnigraffle/">OmniGraffle</a></p><p>draw.io 比较简单;<br>OmniGraffle 是收费的,而且入门的门槛很高.但是自定义很方便;</p><h1 id="屏幕用时记录"><a href="#屏幕用时记录" class="headerlink" title="屏幕用时记录"></a>屏幕用时记录</h1><p><a href="https://apps.apple.com/cn/app/eye-monitor/id1527031341">Eye Monitor</a><br><a href="https://www.rescuetime.com/">RescueTime</a></p><p>第一个是用来当前屏幕用了多久,提醒使用者可以休息了;<br>RescueTime 可以将所有使用的时间进行归类,每星期一封邮件,也可以在控制台上查看;</p><h1 id="笔记类"><a href="#笔记类" class="headerlink" title="笔记类"></a>笔记类</h1><p><a href="https://www.focalboard.com/">Focalboard</a><br><a href="https://www.notion.so/">Notion </a><br><a href="https://www.wolai.com/">我来</a><br><a href="https://www.onenote.com/hrd">OneNote</a><br><a href="https://www.yuque.com/dashboard">语雀</a></p><p>OneNote 传统的笔记本,最好的点在于,他就像一个实体的笔记本概念.<br>Notion 现在很火爆的笔记本,可以实现很多的功能,报表,看板,自定义数据库等等;<br>Focalboard 作为Notion的开源替代版本;最重要是有看板;<br>我来是国产的notion,目前还有待完善;<br>语雀是蚂蚁金服出品,传统的笔记当中做的比较完善的,加上在线的Markdown渲染的很好,有免费的cdn,速度很快;</p><h1 id="破解反编译"><a href="#破解反编译" class="headerlink" title="破解反编译"></a>破解反编译</h1><p>Hopper Disassembler<br>IDA Pro 7.0</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>Microsoft Edge<br>chrome<br>Firefox<br>TorBrowser</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>Microsoft To Do</p><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>NeteaseMusic</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>Postman</p><h1 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h1><p><a href="https://zh.snipaste.com/">Snipaste</a><br>截图软件很多,偏爱他的原因是截图完之后,可以将截出来的图片pin在屏幕上,常有需要对比图片的时候,这样可以pin多个,放在一起对比.</p><h1 id="快捷打开"><a href="#快捷打开" class="headerlink" title="快捷打开"></a>快捷打开</h1><p><a href="https://shortcatapp.com/">Shortcat</a><br>快速触达系统的功能的快捷方式.</p><h1 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h1><p>Telegram Lite</p><h1 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h1><p><a href="https://totalfinder.binaryage.com/">TotalFinder</a><br>增加Mac自带的Finder;</p><h1 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h1><p>ShadowsocksX-NG</p><h1 id="将网页转成App"><a href="#将网页转成App" class="headerlink" title="将网页转成App"></a>将网页转成App</h1><p><a href="https://www.bzgapps.com/unite">Unite</a><br>可以将一个网页转换成Mac App,其实他还是一个内嵌的网页;方便点,我用来将微信读书生成一个App;</p><h1 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h1><p><a href="https://theunarchiver.com/">The Unarchiver</a><br>免费好用,支持很多的压缩方式;</p><h1 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h1><p><a href="https://www.scitools.com/">Understand</a><br>Windows下有一个叫SourceInsight的神奇软件,Understand是Mac的SourceInsight;</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>Visual Studio Code</p><h1 id="调试网络"><a href="#调试网络" class="headerlink" title="调试网络"></a>调试网络</h1><p>Wireshark</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p>XMind ZEN</p><h1 id="显示状态栏"><a href="#显示状态栏" class="headerlink" title="显示状态栏"></a>显示状态栏</h1><p><a href="https://github.com/gao-sun/eul">eul</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cronet_build</title>
    <link href="/2021/06/02/cronet-build/"/>
    <url>/2021/06/02/cronet-build/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>记录编译Cronet for Android 的过程和步骤.</p><span id="more"></span><h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><ol><li>install  depot_tools</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></code></pre></td></tr></table></figure><ol start="2"><li>添加进path,或者 .bashrc/.zshrc</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将 /path/to/depot_tools 天换成自己安装的目录即可</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/path/to/depot_tools&quot;</span></span><br></code></pre></td></tr></table></figure><p>如果安装的位置是home目录下,上述命令切勿使用 <em>~</em>,使用绝对路径或者 HOME 替代.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$&#123;HOME&#125;</span>/depot_tools&quot;</span></span><br></code></pre></td></tr></table></figure><p>我的安装路径是  ~/ide/depot_tools</p><p>所以,我执行的命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$&#123;HOME&#125;</span>/ide/depot_tools&quot;</span></span><br></code></pre></td></tr></table></figure><h1 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h1><ol><li>找个目录,clone代码,我选择的是   ~/workspace/chromium</li><li>拉取代码,因为我不想要history,如果想要history,去掉 –no-history 即可.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 这个命令是第一次拉取代码使用</span><br><span class="hljs-meta">$</span><span class="bash"> fetch --nohooks --no-history chromium</span><br></code></pre></td></tr></table></figure><p>根据网速,快的话办小时,慢的话,数小时之后完成. 20G的东西，我的网速很慢，过了一夜吧，也没具体看多久，这个工具有个问题，没有进度条。。。<br>当命令结束之后,目录下就会出现隐藏文件.gclient 和 文件夹 src.<br>​<br>假如中间中断过，或者直接拷贝了一份已有的源码，非第一次拉取代码,可能会提示如下内容。<br>​<br><img src="/img/cronet_build/sync_warning.png" alt="sync warning"></p><h2 id="非初次同步-则执行同步代码的命令"><a href="#非初次同步-则执行同步代码的命令" class="headerlink" title="非初次同步,则执行同步代码的命令"></a>非初次同步,则执行同步代码的命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gclient sync</span><br></code></pre></td></tr></table></figure><p>进入漫长的等待…</p><p><img src="/img/cronet_build/sync_proceed.png" alt="sync_proceed"></p><p>同步完成,自动执行 gclient runhooks 命令.</p><p><img src="/img/cronet_build/sync_success.png" alt="sync_success"></p><h1 id="切换到src目录下"><a href="#切换到src目录下" class="headerlink" title="切换到src目录下"></a>切换到src目录下</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">cd</span> src</span><br></code></pre></td></tr></table></figure><h1 id="安装额外依赖"><a href="#安装额外依赖" class="headerlink" title="安装额外依赖"></a>安装额外依赖</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./build/install-build-deps.sh</span><br></code></pre></td></tr></table></figure><p>依赖比较多,安装需要点时间,约1G的空间大小.</p><p>我安装的时候,还遇到一个问题</p><p><img src="/img/cronet_build/sync_error_font.png" alt="sync_error_font"></p><p>试了很多办法,还是不行,就按照提示的,跳过这个字体库的安装.<br>​</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./build/install-build-deps.sh --no-chromeos-fonts</span><br><br></code></pre></td></tr></table></figure><h1 id="Run-the-hooks"><a href="#Run-the-hooks" class="headerlink" title="Run the hooks"></a>Run the hooks</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gclient runhooks</span><br></code></pre></td></tr></table></figure><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><h2 id="需求一-Building-Cronet-for-development-and-debugging"><a href="#需求一-Building-Cronet-for-development-and-debugging" class="headerlink" title="需求一: Building Cronet for development and debugging"></a>需求一: Building Cronet for development and debugging</h2><h3 id="第一步-设置out-dir-生成ninja文件"><a href="#第一步-设置out-dir-生成ninja文件" class="headerlink" title="第一步: 设置out_dir,生成ninja文件"></a>第一步: 设置out_dir,生成ninja文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./components/cronet/tools/cr_cronet.py gn --out_dir=out/Cronet</span><br></code></pre></td></tr></table></figure><p>在linux进行编译,则自动生成Android 库,在Mac上,则会生成iOS库.</p><p>这个命令执行完成之后,会影响之前编译在out/Cronet目录中的内容.</p><p>如果 –out_dir 参数省略的话,就输出目录就会默认变成 out/Debug 和 out/Release,分别存放debug和release的输出内容.</p><p><img src="/img/cronet_build/build_gn_ninja.png" alt="build_gn_ninja"></p><h3 id="第二步-Running-the-ninja-files"><a href="#第二步-Running-the-ninja-files" class="headerlink" title="第二步: Running the ninja files"></a>第二步: Running the ninja files</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ninja -C out/Cronet cronet_package</span><br></code></pre></td></tr></table></figure><p><img src="/img/cronet_build/build_success.png" alt="build_success"></p><h3 id="生成物解释"><a href="#生成物解释" class="headerlink" title="生成物解释"></a>生成物解释</h3><p>编译完,用作Android开发的库都在 chromium/src/out/Cronet/cronet 目录下.</p><p><img src="/img/cronet_build/build_gn_dir.png" alt="build_gn_dir"><br>​</p><ol><li>Android的jar包: 该目录下的所有jar文件,就是需要的jar包;</li><li>Android的动态库: libs目录下有对应的so文件;</li><li>符号表: 对应的符号信息在symbols目录下,用于线上crash或其他栈信息的mapping;</li><li>头文件: include目录下有对应的头文件.</li><li>反混淆文件: 也在该目录下.</li></ol><h2 id="需求二-build-mobile-release"><a href="#需求二-build-mobile-release" class="headerlink" title="需求二: build mobile release"></a>需求二: build mobile release</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./components/cronet/tools/cr_cronet.py gn --release</span><br><span class="hljs-meta">$</span><span class="bash"> ninja -C out/Release cronet_package</span><br></code></pre></td></tr></table></figure><p><img src="/img/cronet_build/mobile_release.png" alt="mobile_release"></p><h2 id="需求三-其他abi"><a href="#需求三-其他abi" class="headerlink" title="需求三: 其他abi"></a>需求三: 其他abi</h2><p>默认不指定参数的情况下,生成的是 ARMv7 32位的库,如果需要其他版本的库,可以通过添加如下参数,进行生成.</p><h3 id="方案一是-修改-cr-cronet-py-文件的-gn-args-变量-按照需求修改成如下的值"><a href="#方案一是-修改-cr-cronet-py-文件的-gn-args-变量-按照需求修改成如下的值" class="headerlink" title="方案一是,修改 cr_cronet.py 文件的 gn_args 变量,按照需求修改成如下的值."></a>方案一是,修改 <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/cronet/tools/cr_cronet.py">cr_cronet.py</a> 文件的 gn_args 变量,按照需求修改成如下的值.</h3><p>​</p><ul><li>For ARMv8 64-bit: target_cpu=”arm64”</li><li>For x86 32-bit: target_cpu=”x86”</li><li>For x86 64-bit: target_cpu=”x64”</li></ul><p><img src="/img/cronet_build/cr_cronet.py.png" alt="cr_cronet.py"></p><h3 id="方案二-交互式-不需要修改文件"><a href="#方案二-交互式-不需要修改文件" class="headerlink" title="方案二: 交互式,不需要修改文件"></a>方案二: 交互式,不需要修改文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 交互修改参数</span><br><span class="hljs-meta">$</span><span class="bash"> gn args out/Cronet</span><br><br></code></pre></td></tr></table></figure><p>会弹出输入界面,可以输入需要的参数,比如(这些参数我是参考的默认debug包的参数,只是添加了开头有的target_cpu部分)<br>​</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">target<span class="hljs-emphasis">_cpu=&quot;arm64&quot;</span><br><span class="hljs-emphasis">target_</span>cpu=&quot;arm&quot;<br>target<span class="hljs-emphasis">_cpu=&quot;x86&quot;</span><br><span class="hljs-emphasis">target_</span>os = &quot;android&quot;<br>enable<span class="hljs-emphasis">_websockets = false</span><br><span class="hljs-emphasis">disable_</span>file<span class="hljs-emphasis">_support = true</span><br><span class="hljs-emphasis">disable_</span>ftp<span class="hljs-emphasis">_support = true</span><br><span class="hljs-emphasis">disable_</span>brotli<span class="hljs-emphasis">_filter = false</span><br><span class="hljs-emphasis">is_</span>component<span class="hljs-emphasis">_build = false</span><br><span class="hljs-emphasis">use_</span>crash<span class="hljs-emphasis">_key_</span>stubs = true<br>ignore<span class="hljs-emphasis">_elf32_</span>limitations = true<br>use<span class="hljs-emphasis">_partition_</span>alloc = false<br>include<span class="hljs-emphasis">_transport_</span>security<span class="hljs-emphasis">_state_</span>preload<span class="hljs-emphasis">_list = false</span><br><span class="hljs-emphasis">use_</span>platform<span class="hljs-emphasis">_icu_</span>alternatives = true<br>use<span class="hljs-emphasis">_errorprone_</span>java<span class="hljs-emphasis">_compiler = true</span><br><span class="hljs-emphasis">enable_</span>reporting = true<br>use<span class="hljs-emphasis">_hashed_</span>jni<span class="hljs-emphasis">_names = true</span><br></code></pre></td></tr></table></figure><p>​</p><p>Tip: 其实最终的参数存在 out/Cronet/args.gn 这个文件里,也可以直接修改这个文件.</p><p><img src="/img/cronet_build/args.gn.png" alt="args.gn"></p><p>执行编译操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ninja -C out/Cronet cronet_package</span><br></code></pre></td></tr></table></figure><p>​</p><p><img src="img/cronet_build/abi_success.png" alt="abi_success"></p><p>生成的so文件在 src/out/Cronet/cronet/libs 下,因为我之前编译过 x86的,所以有两个.</p><p><img src="/img/cronet_build/abi_so.png" alt="abi_so"></p><h1 id="其他-iOS编译"><a href="#其他-iOS编译" class="headerlink" title="其他,iOS编译"></a>其他,iOS编译</h1><p>曾经也编译过iOS版本,步骤差不多,按照文档来,但是当时有个问题,在此记录下.</p><ol><li>按照<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/ios/build_instructions.md">iOS编译文档</a> 操作执行,生成需要的文件夹;</li><li>如果当时fetch的时候,参数不是 iOS,则需要确认 .gclient ,最后一行有  target_os = [ “ios” ]   ,然后再执行 gclient sync,下载iOS的依赖; <a href="https://chromium.googlesource.com/chromium/src/+/0e94f26e8/docs/ios_build_instructions.md">文档说明</a></li></ol><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://chromium.googlesource.com/chromium/src/+/HEAD/components/cronet/build_instructions.md">Cronet build instructions</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cronet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp学习之简介(1)</title>
    <link href="/2021/02/09/okhttp-1/"/>
    <url>/2021/02/09/okhttp-1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>回顾一下 OKHttp 这个优秀库,画了张思维导图.</p><p><img src="/img/net/OKHttp_summary.png" alt="OKHttp的分解图"></p><p><img src="/img/net/OKHttp_key_class.png" alt="OKHttp的关键路径图"></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOSP编译</title>
    <link href="/2020/09/06/aosp_build/"/>
    <url>/2020/09/06/aosp_build/</url>
    
    <content type="html"><![CDATA[<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p>最近给电脑换了块SSD，装了Ubuntu 18.04。之前的aosp也不想copy过来了，直接重新编译一份，顺带看下新的SSD带来的提效。<br>因为手机是 nexus 6p，aosp 最后支持到 8.1. 记录下编译需要的操作。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p>open jdk(<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure></li><li><p>repo(<a href="https://gerrit.googlesource.com/git-repo/">https://gerrit.googlesource.com/git-repo/</a>)</p></li></ol><ul><li><p>AUTO</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install repo<br></code></pre></td></tr></table></figure></li><li><p>MANUALLY</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir -p ~/.bin</span><br><span class="hljs-meta">$</span><span class="bash"> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOME&#125;</span>/.bin:<span class="hljs-variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/.bin/repo</span><br><span class="hljs-meta">$</span><span class="bash"> chmod a+rx ~/.bin/repo</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>AOSP <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">mirror</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir aosp<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>git config --global user.email &quot;tinggengyan@gmail.com&quot;<br>git config --global user.name &quot;Tinggeng Yan&quot;<br><br>sudo apt install python<br><br>cd aosp<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 切换指定版本分支</span> <br>repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-8.1.0_r52 --depth=1 --repo-url=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/ --repo-branch=stable<br><br>repo sync --current-branch<br><br></code></pre></td></tr></table></figure><ol start="4"><li>build</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib<br>sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386<br>sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386<br>sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev<br>sudo apt-get install git-core gnupg flex bison gperf build-essential<br>sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib<br>sudo apt-get install libc6-dev-i386<br>sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev<br>sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4<br>sudo apt-get install lib32z-dev ccache<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>export LC_ALL=C<br><br>source build/envsetup.sh &amp;&amp; lunch<br><br>make -j 4<br><br></code></pre></td></tr></table></figure><ol start="5"><li>flash into nexus 6p</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/aosp/out/target/product/angler<br><br>adb reboot bootloader<br><br>fastboot devices<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">下面这条命令可选</span><br><span class="hljs-meta">#</span><span class="bash">fastboot flashall -w</span><br><span class="hljs-meta">#</span><span class="bash">-w 选项会清除设备上的 /data 分区；</span><br><span class="hljs-meta">#</span><span class="bash">该选项在您第一次刷写特定设备时非常有用，但在其他情况下则没必要使用。</span><br><br>fastboot flash vendor vendor.img<br>fastboot flash boot boot.img<br>fastboot flash recovery recovery.img<br>fastboot flash system system.img<br>fastboot flash userdata userdata.img<br>fastboot flash cache cache.img<br><br>fastboot reboot<br><br></code></pre></td></tr></table></figure><h2 id="emulator"><a href="#emulator" class="headerlink" title="emulator"></a>emulator</h2><p>需要编译对应的模拟器的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">source build/envsetup.sh<br><br>lunch 2 #这里填序号aosp_arm64-eng为2<br><br>make -j 4<br><br>emulator<br></code></pre></td></tr></table></figure><p>如果编译完成后关闭了终端窗口，则需要用以下方式启动模拟器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>source build/envsetup.sh<br><br>lunch 2 #这里填序号aosp_arm64-eng为2<br><br>emulator<br><br></code></pre></td></tr></table></figure><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><ol><li>可能出现的错误<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">error: insufficient permissions for device: udev requires plugdev group membership<br></code></pre></td></tr></table></figure></li></ol><p>add group</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG plugdev $LOGNAME<br></code></pre></td></tr></table></figure><p><a href="https://developer.android.com/studio/run/device">ref</a></p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://developer.sony.com/develop/open-devices/guides/aosp-build-instructions/build-aosp-nougat-8-1-oreo-4-4/#tutorial-step-2">sony developer</a><br><a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds">version branch AOSP tags</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aosp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity启动流程概述</title>
    <link href="/2020/07/23/activity-launch-process-1/"/>
    <url>/2020/07/23/activity-launch-process-1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>花了点时间,debug了一下系统,跟踪了一下Activity的启动流程.画了一张图,作为综述.<br>分析的 <code>compileSdkVersion</code> 为 <strong>28</strong>.<br>用的是 draw.io 画的,<a href="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/source/img/activity_process/AndroidActivitySequenceDiagram.drawio">源文件</a>.</p><p><img src="/img/activity_process/AndroidActivitySequenceDiagram.png" alt="概述图"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidStudio调试framework源码</title>
    <link href="/2020/06/23/as-debug-framework/"/>
    <url>/2020/06/23/as-debug-framework/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>debug 是学习流程最快的方式,也是验证想法最好的方法.记录 Androidstudio 如何debug Android framework的代码.</p><span id="more"></span><h2 id="使用无-AOSP-的代码-Java层"><a href="#使用无-AOSP-的代码-Java层" class="headerlink" title="使用无 AOSP 的代码(Java层)"></a>使用无 AOSP 的代码(Java层)</h2><p>这是最简单方便的方式了.</p><ol><li>下载某个版本的 Android Source code</li></ol><p><img src="/img/as_debug_framework/45b1b25e.png" alt="45b1b25e.png"></p><p>确认 <em>Source code</em> 正确下载了.</p><p><img src="/img/as_debug_framework/c974a437.png" alt="c974a437.png"></p><ol start="2"><li>新建项目,所用的 <code>compile SDK </code> 版本为需要调试的代码版本</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    <span class="hljs-comment">// 设置成需要需要分析的,且已下载源码的版本</span><br>    compileSdkVersion <span class="hljs-number">29</span><br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>新建并启动对应版本的模拟器.</li></ol><p><img src="/img/as_debug_framework/d0be67cc.png" alt="d0be67cc.png"></p><ol start="4"><li>打断点;</li></ol><p>这里以系统的 <strong>ActivityManagerService</strong> 为例.<br>因为<strong>ActivityManagerService</strong> 并未导出到<strong>Android.jar</strong>,所以无法直接搜索定位到 <strong>.java</strong>文件,所以采用双击<strong>shift</strong>的方式,检索文件.<br><img src="/img/as_debug_framework/ee514167.png" alt="ee514167.png"></p><ol start="5"><li>attach 到对应的进程,运行,查看断点.</li></ol><p><strong>ActivityManagerService</strong>  这个类是在系统 <strong>system_process</strong> 进程中的,所以,需要对<strong>system_process</strong> 进程进行 <strong>attach</strong> 操作.<br><img src="/img/as_debug_framework/9e039bde.png" alt="9e039bde.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此,经过如上操作,就可以对某个类进行debug操作了.对于分析framework代码也是方便的很.</p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>有时候还是会遇到代码行号不匹配,debug定位的代码行号不对,目前原因未知,应该是source code 和生成模拟器镜像的代码有出入.<br>没有好的解决办法,有个替代的方案.</p><ol><li>断点后,有明确的thread stack信息;</li><li>找到最早一个可以定位准备行号的函数;</li><li>针对这个函数进行 findByUsage,在查出的结果中,查找stack信息指引的函数.</li></ol><h1 id="使用-AOSP-的源码进行调试"><a href="#使用-AOSP-的源码进行调试" class="headerlink" title="使用 AOSP 的源码进行调试"></a>使用 AOSP 的源码进行调试</h1><p>上述的方法基本能满足常见的debug需求了.但是有个前提是,debug的设备基本只能是模拟器或者装了官方release镜像的亲儿子.<br>对于有修改ROM需求的情况下,debug 则需要导入 aosp 中framework 的代码. 对应的运行设备得是运行了自定义ROM的设备.</p><h2 id="生成-android-ipr-文件"><a href="#生成-android-ipr-文件" class="headerlink" title="生成 android.ipr 文件"></a>生成 android.ipr 文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 1. 编译 idegen模块<br>mmm development/tools/idegen/<br><br>// 2. 生成<br>./development/tools/idegen.sh<br><br></code></pre></td></tr></table></figure><p>这个文件就代表了AS里的一个project.</p><h2 id="修改-android-iml-文件"><a href="#修改-android-iml-文件" class="headerlink" title="修改 android.iml 文件"></a>修改 android.iml 文件</h2><p>同时还会生成一个 iml文件,代表了project的配置情况,可以用于配置加载哪些配置.<br>AOSP巨大,可以只加载需要关注的模块,如 framework 和 Package 部分.<br>所以需要修改 android.iml 文件,将不需要的文件进行exclude.</p><h2 id="AS-打开-ipr-文件"><a href="#AS-打开-ipr-文件" class="headerlink" title="AS 打开 ipr 文件"></a>AS 打开 ipr 文件</h2><h3 id="可能遇到问题"><a href="#可能遇到问题" class="headerlink" title="可能遇到问题"></a>可能遇到问题</h3><p>导入可能遇到问题 <code>External file changes sync may be slow: The current inotify(7) watch limit is too low.</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim fs.inotify.max_user_watches = 524288<br><br>sudo sysctl -p --system<br><br></code></pre></td></tr></table></figure><p>重启即可;</p><h2 id="代码索引跳转"><a href="#代码索引跳转" class="headerlink" title="代码索引跳转"></a>代码索引跳转</h2><p>为了跳转到aosp的Java文件,而不是android.jar的class文件,需要调整 project struct.</p><ol><li>新建一个 jdk,此处为 jdk_none, 删除所有的path;</li></ol><p><img src="/img/as_debug_framework/create_jdk.png" alt="create_jdk.png"></p><ol start="2"><li><p>新建一个 android sdk,依赖 jdk_none;<br><img src="/img/as_debug_framework/create_sdk_with_jdk.png" alt="create_sdk_with_jdk.png"></p></li><li><p>project 依赖的sdk切换成第2步新建的SDK即可;</p></li></ol><h2 id="让模拟器使用自定义的ROM"><a href="#让模拟器使用自定义的ROM" class="headerlink" title="让模拟器使用自定义的ROM"></a>让模拟器使用自定义的ROM</h2><ol><li>source ./build/envsetup.sh</li><li>lunch ,选择对应的 模拟器需要的API</li><li>emulator</li></ol><blockquote><p>自己编译编译出的ROM位置” ……/aosp/out/target/product/generic_x86_64 </p></blockquote><h3 id="附-我还没试过"><a href="#附-我还没试过" class="headerlink" title="附,我还没试过"></a>附,我还没试过</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> emulator -avd Nexus5-API22 -verbose -no-boot-anim -system (the path of system.img)</span><br></code></pre></td></tr></table></figure><h1 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h1><ol><li>第一种自然是方便的,要求比较低,对机器的性能要求也不高.有个劣势: 对于AIDL编译生成的Java文件,无法进行索引和导航.但是,可以借助官方的代码搜索网站进行弥补,搜索网站可以索引soong编译期间生成的Java代码: <a href="https://cs.android.com/android/platform/superproject">https://cs.android.com/android/platform/superproject</a> </li><li>AOSP的方式是灵活性更大,中间代码索引也方便. 就是性能要求比较高.</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://www.jianshu.com/p/a19dcb06cd53">导入AOSP</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下 Understand 的初步配置</title>
    <link href="/2020/06/19/tool-understand/"/>
    <url>/2020/06/19/tool-understand/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前一直寻找一款类似于windows上的sourceinsight的软件,后来无意发现 Understand,感觉挺好,熟悉一下,可以用来看代码.体验不错.</p><span id="more"></span><h2 id="导入流程"><a href="#导入流程" class="headerlink" title="导入流程"></a>导入流程</h2><p>和sourceinsight一样,都是新建一个project,在此基础上进行代码的阅读和修改;<br><img src="/img/efficiency_tool_understand/e5d3267c.png" alt="e5d3267c.png"><br><img src="/img/efficiency_tool_understand/e34dd270.png" alt="e34dd270.png"><br><img src="/img/efficiency_tool_understand/4ddef3ef.png" alt="4ddef3ef.png"></p><ol><li>new project </li><li>import project files</li></ol><h2 id="部分实用快捷键"><a href="#部分实用快捷键" class="headerlink" title="部分实用快捷键"></a>部分实用快捷键</h2><ol><li>command + F:</li></ol><ul><li>在侧边的文件栏可以按照文件名进行搜索;</li><li>在打开的文件内可以搜索匹配的关键词;</li></ul><ol start="2"><li>command + G:</li></ol><p>在搜索的基础上可以查找匹配的结果的下一项;</p><ol start="3"><li>command +shift + G:</li></ol><p>在搜索的基础上可以查找匹配的结果的上一项,即反向查找;</p><ol start="4"><li>command + F3</li></ol><p>搜索选中的内容</p><ol start="5"><li>command + option + p/n<br>返回前一个/下一个修改的地方</li></ol><h2 id="部分实用的操作"><a href="#部分实用的操作" class="headerlink" title="部分实用的操作"></a>部分实用的操作</h2><ol><li>绘图能力<br><img src="/img/efficiency_tool_understand/a520cff1.png" alt="a520cff1.png"></li></ol><ul><li>uml 类图<br>在类名上右击,<code>Graphical Views</code> -&gt; <code>UML Class Diagram</code></li><li>查看选中类调用其他类的关系图(单向的调用)<br>在类名上右击,<code>Graphical Views</code> -&gt; <code>Cluster call</code></li><li>查看选中类和其他之间关系图(单向和双向的调用都会列出)<br>在类名上右击,<code>Graphical Views</code> -&gt; <code>Cluster callby Butterfly</code></li><li>查看选中类内部的调用关系<br>在类名上右击,<code>Graphical Views</code> -&gt; <code>Cluster callby Internal</code></li><li>查看选中类被哪些其他的类调用(单向的被调用)<br>在类名上右击,<code>Graphical Views</code> -&gt; <code>Cluster callby</code></li></ul><ol start="2"><li>预览能力,非常好用的功能<br><img src="/img/efficiency_tool_understand/8e21f7d4.png" alt="8e21f7d4.png"></li></ol><p>在类名上,右击 <code>View Information</code> -&gt; <code>Reference by Flat List</code>: 查看类被引用的列表.<br>注: 如果选中的是方法名的话,这里展示的就是方法被引用的列表了.</p><ol start="3"><li>文件搜索能力</li></ol><p><img src="/img/efficiency_tool_understand/aed73fba.png" alt="aed73fba.png"><br>除了直接使用搜索以外,可以在 <code>Entity Filter</code> 里进行过滤文件.</p><ol start="4"><li>收藏夹<br><img src="/img/efficiency_tool_understand/993c3f30.png" alt="993c3f30.png"></li></ol><p>用以将需要分析的文件分组</p><ol start="5"><li>查看调用链<br><img src="/img/efficiency_tool_understand/e2e50df5.png" alt="e2e50df5.png"></li></ol><p>通过选中方法右击 <code>explore</code> -&gt; <code>explore called by/Calls</code>,可以看不到方法被谁调用,自身又调用了谁,非常非常实用.</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li>文件的检索,快捷键<br>目前试用,有几个点比较不舒适,文件的检索能力,没有找到对应的快捷键,能迅速的搜索文件.<br>退而求其次,采用为<code>Entity Filter</code> 自定义快捷键的方式,来达到此目的.</li></ol><p><img src="/img/efficiency_tool_understand/5e5424bf.png" alt="5e5424bf.png"></p><p>当前我采用的是 <code>control + e</code>,目前看能满足需求.</p><ol start="2"><li>在 <code>information</code> 里搜索关键词超级慢;</li><li>没有不可编辑的选项<br>阅读代码的时候,有时不小心误触什么键,可能导致代码变更,需要设置全部文件均不可修改. 不过这点可以通过权限控制,或者干脆不设置,小问题.</li><li>没办法快捷键检索类的属性和方法<br>目前可以查看属性只能通过<code>Information</code>. 方法可以通过菜单栏处的<code>scope list</code> 查看.没有快捷键进行关键词搜索,只能鼠标,这点太大的缺陷.关于这点,还是IDE或者VSC 比较方便.目前这个只能通过选中文件,在光标处于选中文件编辑区的情况下, <code>commnand + f</code> 进行检索,检索的顺序还不能模糊匹配.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Understand</tag>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdk携带的一个HttpServer实现</title>
    <link href="/2020/04/20/jdk-HttpServer/"/>
    <url>/2020/04/20/jdk-HttpServer/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>记录一个意外发现的一个类 <code>com.sun.net.httpserver.HttpsServer</code>. 一个 Http 的 Server 端.</p><span id="more"></span><h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><ol><li>适用于泛前端类开发者,在无后端服务的情况下,可以用来mock数据或者mock后端行为,非常灵活.</li><li>适用于网络库的开发者,测试库的行为;</li></ol><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol><li>目前不支持<code>HTTP2</code>协议.</li></ol><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="自定义一个-HTTP-服务"><a href="#自定义一个-HTTP-服务" class="headerlink" title="自定义一个 HTTP 服务;"></a>自定义一个 HTTP 服务;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpsServer server = HttpsServer.create(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8500</span>), <span class="hljs-number">0</span>);<br>HttpsConfigurator httpsConfigurator = <span class="hljs-keyword">new</span> HttpsConfigurator(SSLContext.getDefault());<br>server.setHttpsConfigurator(httpsConfigurator);<br>HttpContext context = server.createContext(<span class="hljs-string">&quot;/example&quot;</span>);<br>context.setHandler(<span class="hljs-keyword">new</span> CustomHttpHandler());<br>server.start();<br></code></pre></td></tr></table></figure><p>该 Http 服务,是在本机的 <code>8500</code> 端口启动的; 根目录为 <code>example</code>. 所以,直接通过 <code>http://127.0.0.1:8500/example</code> 即可访问.</p><h3 id="Server-的行为定义"><a href="#Server-的行为定义" class="headerlink" title="Server 的行为定义"></a>Server 的行为定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomHttpHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpExchange exchange)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        URI requestURI = exchange.getRequestURI();<br>        printRequestInfo(exchange);<br>        String response = <span class="hljs-string">&quot;This is the response at &quot;</span> + requestURI;<br><br>        exchange.sendResponseHeaders(<span class="hljs-number">200</span>, <span class="hljs-number">0</span>);<br><br>        OutputStream os = exchange.getResponseBody();<br>        os.write(response.getBytes());<br>        os.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printRequestInfo</span><span class="hljs-params">(HttpExchange exchange)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-- headers --&quot;</span>);<br>        Headers requestHeaders = exchange.getRequestHeaders();<br>        requestHeaders.entrySet().forEach(System.out::println);<br><br>        System.out.println(<span class="hljs-string">&quot;-- principle --&quot;</span>);<br>        HttpPrincipal principal = exchange.getPrincipal();<br>        System.out.println(principal);<br><br>        System.out.println(<span class="hljs-string">&quot;-- HTTP method --&quot;</span>);<br>        String requestMethod = exchange.getRequestMethod();<br>        System.out.println(requestMethod);<br><br>        System.out.println(<span class="hljs-string">&quot;-- query --&quot;</span>);<br>        URI requestURI = exchange.getRequestURI();<br>        String query = requestURI.getQuery();<br>        System.out.println(query);<br><br><br>        InputStream requestBody = exchange.getRequestBody();<br>        <span class="hljs-keyword">if</span> (requestBody == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> available = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            available = requestBody.available();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;request body available:&quot;</span> + available);<br>        printMessage(requestBody);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(InputStream requestBody)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> read = requestBody.read(buffer);<br>                <span class="hljs-keyword">if</span> (!(read &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;<br>                System.out.println(<span class="hljs-string">&quot;body:::::&quot;</span> + <span class="hljs-keyword">new</span> String(buffer));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><blockquote><p>生成自签的证书的命令如下:<br>keytool -genkey -alias alias -keyalg RSA -keystore keystore.jks -keysize 2048</p></blockquote><h3 id="自定义一个-Https-服务"><a href="#自定义一个-Https-服务" class="headerlink" title="自定义一个 Https 服务;"></a>自定义一个 Https 服务;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// setup the socket address</span><br>    InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8500</span>);<br><br>    <span class="hljs-comment">// initialise the HTTPS server</span><br>    HttpsServer httpsServer = HttpsServer.create(address, <span class="hljs-number">0</span>);<br>    SSLContext sslContext = SSLContext.getInstance(<span class="hljs-string">&quot;TLS&quot;</span>);<br><br>    <span class="hljs-comment">// initialise the keystore</span><br>    <span class="hljs-comment">// 记得替换密码</span><br>    <span class="hljs-keyword">char</span>[] password = <span class="hljs-string">&quot;123456&quot;</span>.toCharArray();<br>    KeyStore ks = KeyStore.getInstance(<span class="hljs-string">&quot;JKS&quot;</span>);<br>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;keystore.jks&quot;</span>);<br>    ks.load(fis, password);<br><br>    <span class="hljs-comment">// setup the key manager factory</span><br>    KeyManagerFactory kmf = KeyManagerFactory.getInstance(<span class="hljs-string">&quot;SunX509&quot;</span>);<br>    kmf.init(ks, password);<br><br>    <span class="hljs-comment">// setup the trust manager factory</span><br>    TrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class="hljs-string">&quot;SunX509&quot;</span>);<br>    tmf.init(ks);<br><br>    <span class="hljs-comment">// setup the HTTPS context and parameters</span><br>    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="hljs-keyword">null</span>);<br>    httpsServer.setHttpsConfigurator(<span class="hljs-keyword">new</span> HttpsConfigurator(sslContext) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpsParameters params)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// initialise the SSL context</span><br>                SSLContext context = getSSLContext();<br>                SSLEngine engine = context.createSSLEngine();<br>                params.setNeedClientAuth(<span class="hljs-keyword">false</span>);<br>                params.setCipherSuites(engine.getEnabledCipherSuites());<br>                params.setProtocols(engine.getEnabledProtocols());<br><br>                <span class="hljs-comment">// Set the SSL parameters</span><br>                SSLParameters sslParameters = context.getSupportedSSLParameters();<br>                params.setSSLParameters(sslParameters);<br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Failed to create HTTPS port&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    httpsServer.createContext(<span class="hljs-string">&quot;/example&quot;</span>, <span class="hljs-keyword">new</span> SimpleHttpsServer.SimpleHandler());<br>    httpsServer.start();<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Failed to create HTTPS server on port &quot;</span> + <span class="hljs-number">8500</span> + <span class="hljs-string">&quot; of localhost&quot;</span>);<br>    exception.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义Https服务处理"><a href="#自定义Https服务处理" class="headerlink" title="自定义Https服务处理"></a>自定义Https服务处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHttpsServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpHandler</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpExchange t)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            printRequestInfo(t);<br>            String response = <span class="hljs-string">&quot;This is the response&quot;</span>;<br>            HttpsExchange httpsExchange = (HttpsExchange) t;<br>            httpsExchange.getResponseHeaders().add(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>            httpsExchange.sendResponseHeaders(<span class="hljs-number">200</span>, response.getBytes().length);<br>            OutputStream os = httpsExchange.getResponseBody();<br>            os.write(response.getBytes());<br>            os.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printRequestInfo</span><span class="hljs-params">(HttpExchange exchange)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-- headers --&quot;</span>);<br>        Headers requestHeaders = exchange.getRequestHeaders();<br>        requestHeaders.entrySet().forEach(System.out::println);<br><br>        System.out.println(<span class="hljs-string">&quot;-- protocol --&quot;</span>);<br>        String protocol = exchange.getProtocol();<br>        System.out.println(protocol);<br><br><br>        System.out.println(<span class="hljs-string">&quot;-- principle --&quot;</span>);<br>        HttpPrincipal principal = exchange.getPrincipal();<br>        System.out.println(principal);<br><br>        System.out.println(<span class="hljs-string">&quot;-- HTTP method --&quot;</span>);<br>        String requestMethod = exchange.getRequestMethod();<br>        System.out.println(requestMethod);<br><br>        System.out.println(<span class="hljs-string">&quot;-- query --&quot;</span>);<br>        URI requestURI = exchange.getRequestURI();<br>        String query = requestURI.getQuery();<br>        System.out.println(query);<br><br><br>        InputStream requestBody = exchange.getRequestBody();<br>        <span class="hljs-keyword">if</span> (requestBody == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> available = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            available = requestBody.available();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;request body available:&quot;</span> + available);<br>        printMessage(requestBody);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(InputStream requestBody)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> read = requestBody.read(buffer);<br>                <span class="hljs-keyword">if</span> (!(read &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;<br>                System.out.println(<span class="hljs-string">&quot;body content is: &quot;</span> + <span class="hljs-keyword">new</span> String(buffer));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1><p>如果知道实现了Http2的,还望告知.</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NDK学习之JNI_Tip</title>
    <link href="/2020/02/13/ndk-jni-tip/"/>
    <url>/2020/02/13/ndk-jni-tip/</url>
    
    <content type="html"><![CDATA[<h1 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h1><p>本篇是对于 <code>Google NDK GUIDES</code> 中 JNI tips 的总结,是关于 JNI <strong>开发过程</strong> 中的一些原则和注意点,没有原理. 所有的内容适用于 Java 和 Kotlin.</p><p class="note note-primary">约定</p>- managed code (Java/kotlin编写的代码)- native code  (C/C++编写的代码)<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><p>整体上大的原则是: 尽量减少 JNI 层的操作. 故而有以下3点注意事项,重要性由高到低依次为:</p><ol><li>JNI 层调用传递的数据尽量少,调用的频率尽量低;</li><li>JNI Java 调用 native 避免异步调用,异步操作都放在 Java 层.这指的是 JNI 调用,不包含 native 库自身有些异步操作;</li><li>JNI 操作涉及到的线程越少越好.即使要用线程池,也是由线程池的管理者负责JNI之间的交互,而不是由工作线程直接负责交互;</li><li>为了方便维护和重构, 保证JNI相关的代码在固定的位置,容易辨认,且接口尽量少;</li></ol><h2 id="JavaVM-amp-JNIEnv"><a href="#JavaVM-amp-JNIEnv" class="headerlink" title="JavaVM &amp; JNIEnv"></a>JavaVM &amp; JNIEnv</h2><ul><li>二者本质上都是指向函数表的<strong>指针的指针</strong>.</li><li>虽然理论上来说,每个进程可以有多个 JavaVM 对象,但是 Android 规定,每个进程只能有一个 JavaVM ;</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>JNIEnv 是个<strong>线程局部变量</strong>,线程不可共享,请勿在线程之间共享 JNIEnv 对象; 如若无其他方式获取 JNIEnv,可以采如下方式;<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">JNIEnv* env;<br>vm-&gt;AttachCurrentThread(&amp;env, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 此处的 vm 即为JavaVM 对象,可以处理成全局单例;</span><br></code></pre></td></tr></table></figure></li><li>由于 JavaVM &amp; JNIEnv 在 C 和 C++ 中的定义是不一样(“jni.h” 中包含了二者的不同定义,根据包含”jni.h”的是C还是C++),所以,如果头文件会在 C/C++ 中共享的话,则不能简单的 include,头文件中的方法声明就需要根据C/C++做区分处理;</li></ol><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul><li>所有的线程都是 Linux 线程,都归属内核调度<ul><li>Java/kotlin 创建; </li><li>native 创建,然后 <em>AttachCurrentThread</em> 到 JavaVM 上; </li></ul></li><li>创建线程最好的方式是通过 Java/kotlin 创建<ul><li>好处一: 有充足的栈空间;</li><li>好处二: 相对 native 创建线程,可以分配正确的 ThreadGroup;</li><li>好处三: 通过 JNI 调用的 native 代码可以使用和 Java 中相同的 classloader;</li><li>好处四: 相对 native 创建线程,方便设置线程 name,在 debug 的时候很方便;</li></ul></li><li>native 方式创建线程,并 attach<ul><li>在 Java 层相应的创建一个 java.lang.Thread 对象;</li><li>新建的线程添加进 “main” ThreadGroup,debug 时,就可以看到了;</li><li>对一个 AttachCurrentThread 过的线程上再次 AttachCurrentThread 无副作用;</li></ul></li><li>Android 不会挂起正在执行 native 代码的线程<ul><li>GC 或者 debug 的时候,即使发出了挂起的请求,也只会在下次进行 JNI 请求的时候挂起;</li></ul></li><li>已经 attach 过的线程退出时,必须调用 DetachCurrentThread 方法<ul><li>如果调用不方便,可以通过 pthread_key_create 定义一个 析构函数,在线程退出的时候,调用 DetachCurrentThread;</li></ul></li></ul><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ol><li>在 native 层线程在未 attach 之前,是没有 JNIEnv 的,<strong>不能进行 JNI 操作</strong>;</li><li>线程资源优先通过 Java 层创建;</li><li>JNI 调用的 native 方法过于耗时会影响 CPU 调度,间接影响主线程,注意 native 方法的耗时;</li></ol><h2 id="jclass-jmethodID-and-jfieldID"><a href="#jclass-jmethodID-and-jfieldID" class="headerlink" title="jclass, jmethodID, and jfieldID"></a>jclass, jmethodID, and jfieldID</h2><ul><li><p>JNI native 层访问 Java 层的<strong>属性</strong>的时候,则需要以下三个步骤;</p><ul><li>jclass,引用实例对应的 jclass 对象,通过 findclass  获取;</li><li>jfieldID,属性对应的 ID,通过 GetFieldID  获取;</li><li>根据属性的变量类型,通过对应方法获取该对象实例的属性的值,如 GetIntField;</li></ul></li><li><p>JNI native 层访问 Java 层的<strong>方法</strong>的时候,则需要以下三个步骤;</p><ul><li>jclass,引用实例对应的 jclass 对象,通过 findclass  获取;</li><li>jmethodID,方法对应的 ID,通过 GetMethodID  获取;</li><li>根据方法的签名,通过对应方法调用方法,如 CallIntMethod;</li></ul></li><li><p>关于 jfieldID 和 jmethodID 的查找是需要经过字符串比较的,然一旦已经存在 jfieldID 和 jmethodI,获取值/方法调用 是很快的.</p></li><li><p>jfieldID 和 jmethodID 本质上,只是指向内部运行时数据结构的指针;</p></li><li><p>jfieldID 和 jmethodID  只要 class 没有被卸载,是一直有效的; 但是在 Android 上,虽然概率很低,但是 class 也是可能被卸载的,所以,需要做好安全防护工作;</p></li></ul><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ol><li>为了性能考虑,缓存 jfieldID 和 jmethodID; 因为每个进程只有一个 JavaVM,所以在 native 代码中的 static 存储区域中缓存是合适的.</li><li>与 jfieldID 和 jmethodID 不同,jclass 是个 class 的引用,缓存的时候,必须用 <strong>GlobalRef</strong> 进行保护;</li></ol><p>综上,缓存 ID的最佳方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * We use a class initializer to allow the native code to cache some</span><br><span class="hljs-comment">     * field offsets. This native function looks up and caches interesting</span><br><span class="hljs-comment">     * class/field/method IDs. Throws on failure.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        nativeInit();<br>    &#125;<br></code></pre></td></tr></table></figure><p>在 C/C++ 层面实现 nativeInit 方法,进行 ID 的查找和缓存,这样只会在 class 加载时候调用一次,卸载重新加载也会得到调用,可以保证安全;</p><h2 id="Local-and-global-references"><a href="#Local-and-global-references" class="headerlink" title="Local and global references"></a>Local and global references</h2><p>该特性适用于所有继承了 jobject 类的对象: jclass,jstring,jarray;<br><img src="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/images/types4.gif" alt="jobject的继承关系"><br>如未特殊说明,以下的对象也都是指的 jobject 或者其子类对应的对象;</p><h3 id="Local-references"><a href="#Local-references" class="headerlink" title="Local references"></a>Local references</h3><p>通过 JNI 传递到 native 方法的所有 object 参数以及 native 方法返回的 object 对象,都是 <strong>“local reference”</strong>.<br>特点: 在 <strong>当前线程</strong> 的 <strong>当前 native 方法生命周期内</strong> (条件),该 “local reference” 是有效的.不满足这个条件,即使对象依旧存活,依然是无效的. 换句话说:在 return java 之前都是有效的;</p><h4 id="Local-的限制"><a href="#Local-的限制" class="headerlink" title="Local 的限制"></a>Local 的限制</h4><p>native 函数结束之后, local 引用就会失效,但是有时候需要使用大量的 local 引用.典型的像在遍历数组的时候,需要大量创建 local 引用,这时就需要手动释放(DeleteLocalRef),而不应该依赖 JNI 处理.</p><ul><li>例外:<br>一个 native 创建的线程,执行过 AttachCurrentThread 操作,在 detach 之前,程序并不会自动删除 local 引用,创建的任何local 都需要自己手动删除.</li></ul><h5 id="8-0-之前-和具体版本相关"><a href="#8-0-之前-和具体版本相关" class="headerlink" title="8.0 之前(和具体版本相关)"></a>8.0 之前(和具体版本相关)</h5><p>只预留了 16 个了 local 引用的 slot(槽位),超过的,要自己手动释放,否则会crash.也可以使用 EnsureLocalCapacity/PushLocalFrame 来增加槽位.<br>实测下来: 每个槽位对应 32 个引用,所以,16个槽位,可以存放 512 个 local 引用;</p><h5 id="8-0-之后"><a href="#8-0-之后" class="headerlink" title="8.0 之后"></a>8.0 之后</h5><p>不限制数量.</p><h3 id="global-references"><a href="#global-references" class="headerlink" title="global references"></a>global references</h3><p>global 正好是为了突破 local 所产生的限制: 当前线程 与 当前 native 方法;<br>通过  NewGlobalRef 和 NewWeakGlobalRef (可以接收 local 和 global 引用作为参数) 来创建 global 引用,只有调用在 DeleteGlobalRef 之后才会失效;</p><h3 id="引用的适用范围"><a href="#引用的适用范围" class="headerlink" title="引用的适用范围"></a>引用的适用范围</h3><p>对于接收引用的 native 方法,可以接收 local 引用 和 global 引用,除了生命周期以外,用法一致;</p><h4 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h4><p>从 Android4.0 开始,weak global 引用才可像其他的引用一样使用,在此之前,只可用于 NewLocalRef, NewGlobalRef, and DeleteWeakGlobalRef.</p><h3 id="引用之间的比较"><a href="#引用之间的比较" class="headerlink" title="引用之间的比较"></a>引用之间的比较</h3><p>对于指向<strong>相同对象</strong>的<strong>不同引用</strong>的<strong>值是很可能不一样</strong>的.例如,针对同一个对象连续调用 NewGlobalRef 返回的引用,值就可能不同.所以对于两个不同的引用,判断是否指向同一个对象,用 <strong>IsSameObject</strong> 函数判断,千万不要用 <strong>==</strong> .</p><ul><li>特性带来的影响:</li></ul><ol><li>不能假设 native 层中的对象引用是常量或者唯一的; </li><li>同一个方法的两次调用,表示对象的引用可能是不同;</li><li>不同对象的引用可能具有相同的值;</li></ol><p>故而,切勿将 jobject 作为键;</p><h3 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点:"></a>注意点:</h3><ol><li>引用仅针对 jobject 及其子类. 而 jfieldID 和  jmethodID 不适用,不应该传递给 NewGlobalRef</li><li>GetStringUTFChars 和 GetByteArrayElements 返回的是原始数据指针,非对象引用,他们可以在线程间传递,在执行对应的 release 之前,一直有效</li><li>总的来说, native 代码中创建的 local 引用,及时的显式 delete</li><li>谨慎使用全局引用,太多的全局引用会导致调试困难</li><li>引用是否指向同一个对象,用 IsSameObject 方法</li><li>典型的使用代码:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">jclass localClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;MyClass&quot;</span>);<br>jclass globalClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(localClass));<br></code></pre></td></tr></table></figure></li></ol><h2 id="UTF-8-and-UTF-16-strings"><a href="#UTF-8-and-UTF-16-strings" class="headerlink" title="UTF-8 and UTF-16 strings"></a>UTF-8 and UTF-16 strings</h2><h3 id="Java-与-JNI-编码不一致"><a href="#Java-与-JNI-编码不一致" class="headerlink" title="Java 与 JNI 编码不一致"></a>Java 与 JNI 编码不一致</h3><ul><li>Java 中用的字符编码是 UTF-16</li><li>JNI 为了方便起见,采用的是 Modified UTF-8(将 \u0000 编码成 <em>0xc0 0x80</em> ,而不是 <em>0x00</em>,这样得到的字符串,就是一个 C-style 的字符串)</li></ul><h4 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h4><ul><li>优点: JNI 中可以直接用 libc 字符串相关的函数;</li><li>缺点: 标准的 UTF-8 的数据传递给 JNI 函数时,可能无法正常工作;</li></ul><h2 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h2><ol><li>如果可行的话,就全部转成 UTF-16,这样操作的最快.</li><li>GetStringChars:返回的是 UTF-16 的数据,UTF-16 的字符串是没有结尾的符号的,C style 的字符串函数是没法判断结尾的,所以,如果用 UTF-16 的话,需要自己维护一个字符串<strong>长度</strong>和 jchar 指针.</li><li>GetStringUTFChars:返回的是 Modified UTF-8 的数据,可以直接用 C style 的字符串函数.</li><li>GetStringChars 返回值是 jchar 指针,GetStringUTFChars 返回的是 char*,都是原始数据的指针,而不是前一个section里的 reference,在调用对应的 release 方法之前,都是有效的,不用担心作用域问题;相应的,不用时,及时 release;</li><li>NewStringUTF:参数必须是 Modified UTF-8 格式的,切勿将文件流或者网络下载的标准 UTF-8 格式的数据直接传;</li></ol><h2 id="处理建议"><a href="#处理建议" class="headerlink" title="处理建议"></a>处理建议</h2><h3 id="策略一"><a href="#策略一" class="headerlink" title="策略一:"></a>策略一:</h3><p>JNI jstring 通过 Java 层的 String 的 getBytes(“UTF-8”) 方法来获取标准 UTF-8 格式的字符串;<br>当 JNI 返回 Java 层数据时,Java 层可以通过 String 对应的构造方法处理;</p><h3 id="策略二"><a href="#策略二" class="headerlink" title="策略二:"></a>策略二:</h3><p>在 native 层面进行编码的转换,JNI 不变,依旧使用 Modified UTF-8,通过算法处理编码转换.</p><h2 id="Primitive-arrays"><a href="#Primitive-arrays" class="headerlink" title="Primitive arrays"></a>Primitive arrays</h2><p>JNI 提供的数组操作需要一个一个的操作,有些麻烦.原生数组可以使得数组像被 native 中定义的数组一样,可以被直接操作.</p><p>为了高效 Get<PrimitiveType>ArrayElements(array,isCopy) 系列的函数,既可以返回真实数组的指针,也可以分配内存,拷贝到 native;</p><ol><li>无论哪种,指针在调用 release 之前,都是有效的.</li><li>如果未采用复制方式,返回的真实数组指针,那么,数组的对象将会固定不变,即使是在 GC 进行堆压缩的时候.</li><li>get 的数组,需要进行 release,并且不能对一个空指针进行 release.</li></ol><p>release 方法有个 mode 参数,执行的效果取决于 Get<PrimitiveType>ArrayElements 方法返回的指针是指向的原始数据,还是复制的内存拷贝;</p><ol><li>0<ul><li>a. Actual: 数组对象取消固定.</li><li>b. Copy: 数据重新拷贝回去,原先分配的内存空间<strong>释放</strong>.</li></ul></li><li>JNI_COMMIT<ul><li>a. Actual: does nothing.</li><li>b. Copy: 数据重新拷贝回去,原先分配的内存空间<strong>并不释放</strong>.</li></ul></li><li>JNI_ABORT<ul><li>a. Actual: 数组对象取消固定. 之前的写入已经生效.</li><li>b. Copy: 原先分配的内存空间释放,数据操作丢失.</li></ul></li></ol><p>一个常见的错误是: 如果 isCopy 是 false,则可以省略 release 操作,这个是非常错误的做法,因为不进行 release 的话,则原始数据将会一直固定,得不到回收器的回收.<br>其次需要注意: JNI_ABORT 并不会释放数组,需要以其他的 mode 再次调用 release 进行释放,这个是很容易犯错的;比如, JNI_ABORT 之后,再调用 0;</p><h3 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h3><ol><li>根据需求,决定 Get<PrimitiveType>ArrayElements 是否 copy 数组到 native </li><li>无论何种方式获取的数组,都需要 release</li><li>release(JNI_ABORT) 并不会释放数组,需要再调用 release(0)</li></ol><h2 id="Region-calls"><a href="#Region-calls" class="headerlink" title="Region calls"></a>Region calls</h2><p>如对 Get<PrimitiveType>ArrayElements 和 GetStringChars 的需求都是 <strong>copy=true</strong> 的话,则 Region call 会是个不错的替代方案,提供了更多的灵活性和更好的性能.</p><h3 id="考虑一个场景-需要字节数组中的-len-长度的部分"><a href="#考虑一个场景-需要字节数组中的-len-长度的部分" class="headerlink" title="考虑一个场景: 需要字节数组中的 len 长度的部分"></a>考虑一个场景: 需要字节数组中的 len 长度的部分</h3><ol><li>采用 Get<PrimitiveType>ArrayElements<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// </span><br>jbyte* data = env-&gt;<span class="hljs-built_in">GetByteArrayElements</span>(array, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (data != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">memcpy</span>(buffer, data, len); <span class="hljs-comment">// extra,copy part</span><br>    env-&gt;<span class="hljs-built_in">ReleaseByteArrayElements</span>(array, data, JNI_ABORT);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>采用 GetByteArrayRegion <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">env-&gt;<span class="hljs-built_in">GetByteArrayRegion</span>(array, <span class="hljs-number">0</span>, len, buffer);<br></code></pre></td></tr></table></figure></li></ol><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th align="center">方案</th><th align="left">代码书写</th><th align="left">JNI调用次数</th><th align="left">固定Java数组</th></tr></thead><tbody><tr><td align="center">方式一</td><td align="left">复杂,需要执行额外的一次复制操作</td><td align="left">2</td><td align="left">固定</td></tr><tr><td align="center">方式二</td><td align="left">简洁,出错率低</td><td align="left">1</td><td align="left">不固定</td></tr></tbody></table><p>有 Get,也同样有对应的 Set 方法,用于将数据复制回数组或者字符串;</p><h3 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h3><ol><li>当需要对数组或者字符串进行<strong>copy</strong>操作时候,优先用对应的 Region 操作</li></ol><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ol><li>当发生异常的时候,大多数的 JNI 方法将不能调用,只有固定的几个方法能调用,参见 <a href="https://developer.android.com/training/articlesperf-jni#exceptions_1">仍可以调用的方法</a></li><li>由代码中断触发的异常,并不会释放 native 的栈信息,Android 目前也不支持 C++ 的 Exception; JNI 通过 Throw 和 ThrowNew 指令,只是在当前的线程中设置了一个异常的指针,等到 native 方法结束,返回 Java 层的时候,这时候才会被处理.</li><li>JNI 无法持有 Throwable 这个对象,如果需要在 native 层处理异常,需要 findclass Java 层的 Throwable 类,通过相关方法处理.</li></ol><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol><li>少部分可以通过检查返回值,检查比较简单,比如 NewString,判断返回值是否为 null,进行判断.</li><li>大部分需要主动检查异常,比如 CallObjectMethod 函数,因为一旦抛出异常,此时的返回值是无效的.</li></ol><h3 id="涉及到的-JNI-方法"><a href="#涉及到的-JNI-方法" class="headerlink" title="涉及到的 JNI 方法"></a>涉及到的 JNI 方法</h3><ol start="5"><li>ExceptionCheck 与 ExceptionOccurred, 进行异常的检查和捕获. </li><li>ExceptionClear 可以清除异常,但是清除异常不是一个好的处理手段.</li></ol><h3 id="注意点-7"><a href="#注意点-7" class="headerlink" title="注意点"></a>注意点</h3><ol><li>通过 ExceptionCheck 检测是否有异常,通过 Throw 抛出到 Java 层进行处理.</li><li>如果异常是可以忽略的,先 ExceptionClear,再继续执行其他 JNI 操作,否则会 crash.</li></ol><h2 id="Extended-checking"><a href="#Extended-checking" class="headerlink" title="Extended checking"></a>Extended checking</h2><p>JNI 对错误的检查很少,所以 Android 提供了一种称为 <strong>CheckJNI</strong> 的模式,通过修改 <em>JavaVM</em> 和 <em>JNIEnv</em> 的函数表指针,实现在调用所有的 JNI 函数之前,都会进行一系列的检查.</p><p><a href="https://developer.android.google.cn/training/articles/perf-jni#extended-checking">具体的检查项</a>: </p><h3 id="注意点-8"><a href="#注意点-8" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p>模拟器: 默认开启</p></li><li><p>rooted device</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell stop<br>adb shell setprop dalvik.vm.checkjni true<br>adb shell start<br></code></pre></td></tr></table></figure><p>开启后会在 logcat 里看到 <em>D AndroidRuntime: CheckJNI is ON</em></p></li><li><p>regular device: 不会影响正在运行的App,而且开启时,所有启动的App都会检查.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 设备重启后失效<br>adb shell setprop debug.checkjni 1<br></code></pre></td></tr></table></figure><p>开启后会在 logcat 里看到 <em>D Late-enabling CheckJNI</em></p></li><li><p>针对单个App进行检查<br>android:debuggable 设置为 true 即可,正常的 debug版本不需要手动配置,Android build-tool 会自动设置;</p></li></ol><h2 id="Native-libraries"><a href="#Native-libraries" class="headerlink" title="Native libraries"></a>Native libraries</h2><h3 id="加载动态库的方式"><a href="#加载动态库的方式" class="headerlink" title="加载动态库的方式"></a>加载动态库的方式</h3><p>以下以打包出的动态so文件为: <strong>lib名字.so</strong> 为例.</p><ol><li><p>系统默认方式加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;名字&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官方推荐 ReLinker 方式<br>在旧版本 Android 的 PackageManager 有 bug 在 App 升级时 so 库可能没有成功复制到 /data/data/packageName/lib/ 下,导致 “java.lang.UnsatisfiedLinkError”,故而 Google 推荐用  <a href="https://github.com/KeepSafe/ReLinker">ReLinker</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReLinker.loadLibrary(context, <span class="hljs-string">&quot;名字&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Facebook SoLoader<br>ReLinker 不能解决 so 依赖问题, <a href="https://github.com/facebook/SoLoader">SoLoader</a> 可以解决这个问题.<br>PS: 接入复杂,我还没玩过.可以参考 Facebook 的 RN 和 fresco.</p></li></ol><h3 id="确保运行时可以查找-native-方法"><a href="#确保运行时可以查找-native-方法" class="headerlink" title="确保运行时可以查找 native 方法"></a>确保运行时可以查找 native 方法</h3><h4 id="RegisterNatives-显式的注册"><a href="#RegisterNatives-显式的注册" class="headerlink" title="RegisterNatives 显式的注册"></a>RegisterNatives 显式的注册</h4><ol><li>实现  JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved)</li><li>在 JNI_OnLoad 方法中,使用 RegisterNatives 注册所有的 native方法</li><li>加参数 -fvisibility=hidden 可以保证 只有 JNI_OnLoad 被导出,这样的 so 文件更小,更快,且能避免和App中加载的其他so冲突,但是这会带来一个问题,crash的时候,栈信息会更少</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">void</span>* reserved)</span> </span>&#123;<br>    JNIEnv* env;<br>    <span class="hljs-keyword">if</span> (vm-&gt;<span class="hljs-built_in">GetEnv</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;<br>        <span class="hljs-keyword">return</span> JNI_ERR;<br>    &#125;<br><br>    <span class="hljs-comment">// Find your class. JNI_OnLoad is called from the correct class loader context for this to work.</span><br>    jclass c = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;com/example/app/package/MyClass&quot;</span>);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> JNI_ERR;<br><br>    <span class="hljs-comment">// Register your class&#x27; native methods.</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> JNINativeMethod methods[] = &#123;<br>        &#123;<span class="hljs-string">&quot;nativeFoo&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(nativeFoo)&#125;,<br>        &#123;<span class="hljs-string">&quot;nativeBar&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;I)Z&quot;</span>, <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(nativeBar)&#125;,<br>    &#125;;<br>    <span class="hljs-keyword">int</span> rc = env-&gt;<span class="hljs-built_in">RegisterNatives</span>(c, methods, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(methods)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(JNINativeMethod));<br>    <span class="hljs-keyword">if</span> (rc != JNI_OK) <span class="hljs-keyword">return</span> rc;<br><br>    <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点: </p><ul><li>前端即可检查方法是否存在.</li><li>可以仅导出 JNI_OnLoad 方法,使得共享库更小,更快.</li></ul><h4 id="使用-dlsym-动态查找"><a href="#使用-dlsym-动态查找" class="headerlink" title="使用 dlsym 动态查找"></a>使用 dlsym 动态查找</h4><ol><li>Java 类中声明一个 native 标识的方法.</li><li>借助 AndroidStudio 自动生成对应的 native 方法,方法名的生成规则为: <em>Java_点全部换成下划线的packageName_methodName</em>.<br>目前 AndroidStudio 自动生成这类代码的能力很强了.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_me_ele_wp_ndkstudy_MainActivity_stringFromJNI</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        JNIEnv *env,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject <span class="hljs-comment">/* this */</span>)</span> </span>&#123;<br>    std::string hello = <span class="hljs-string">&quot;Hello from C++&quot;</span>;<br>    <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(hello.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>优点:</p><ul><li>优点在于编写的代码较少,尤其借助 AndroidStudio,快捷方便.<br>缺点:</li><li>即使是一个参数的错误,也只能等到运行时调用的时候,才能发现.</li></ul><h3 id="native-中加载-Java-类"><a href="#native-中加载-Java-类" class="headerlink" title="native 中加载 Java 类"></a>native 中加载 Java 类</h3><ul><li><p>JNI_OnLoad 方法中的 FindClass<br>FindClass 函数的调用,用来查找和加载 Java 类所用的 classloader 与加载 so 文件的那个类所用的 classloader 是同一个,也就是说,在哪个类加载 so 文件,就用哪个类的 classloader.</p></li><li><p>其他地方 FindClass 函数的调用</p></li></ul><ol><li>使用的是 Java 栈顶关联的 classloader</li><li>如果不存在 Java 栈(native 线程,attach 到 VM 上),则使用 system classloader.</li></ol><blockquote><p>所以,在 JNI_OnLoad 中,查找出所有的 jclass,并进行缓存,是最好的选择.一旦成功获取 jclass,可以任何线程中共享 jclass;</p></blockquote><h3 id="注意点-9"><a href="#注意点-9" class="headerlink" title="注意点"></a>注意点</h3><ol><li>优先选择 ReLinker 进行 so 文件加载.</li><li>如果只有一个类有 native 的方法,so 文件的加载,则可以选择放在在该类的静态代码块中进行加载;否则,请在 Application 中进行加载,以确保 App 调用native 方法前,so 文件已经得到正确的加载.</li><li>方法的注册,看自己的选择. RegisterNatives 优点相对明显些,如果 native 方法数量不多,二者皆可.</li><li>native 如果用到 jclass,建议在 JNI_OnLoad 方法中进行缓存,避免出错.</li></ol><h2 id="64-bit-considerations"><a href="#64-bit-considerations" class="headerlink" title="64-bit considerations"></a>64-bit considerations</h2><h3 id="注意点-10"><a href="#注意点-10" class="headerlink" title="注意点"></a>注意点</h3><ol><li>为了支持 64 位的架构,Java 层存储 native 层的指针时,需要用 <strong>long</strong> 类型,而不是 <strong>int</strong>类型.</li></ol><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="UnsatisfiedLinkError-如何处理"><a href="#UnsatisfiedLinkError-如何处理" class="headerlink" title="UnsatisfiedLinkError 如何处理?"></a>UnsatisfiedLinkError 如何处理?</h2><h3 id="Library-名字-not-found"><a href="#Library-名字-not-found" class="headerlink" title="Library 名字 not found"></a>Library 名字 not found</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">java.lang.UnsatisfiedLinkError: Library 名字 <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><ol><li>如日志所述,确实没找到 so 文件;</li><li>so 文件存在,App 无权访问;<br>通过 <em>adb shell ls -l <path></em> 检查 so 文件是否存在,并检查App 是否有访问的权限;</li><li>so 库不是通过 NDK 打包的,库中有些函数,在设备上找不到.</li></ol><h3 id="No-implementation-found-for-functionName"><a href="#No-implementation-found-for-functionName" class="headerlink" title="No implementation found for functionName"></a>No implementation found for functionName</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">java.lang.UnsatisfiedLinkError: myfunc<br>        at Foo.<span class="hljs-built_in">myfunc</span>(Native Method)<br>        at Foo.<span class="hljs-built_in">main</span>(Foo.java:<span class="hljs-number">10</span>)<br>W/<span class="hljs-built_in">dalvikvm</span>(  <span class="hljs-number">880</span>): No implementation found <span class="hljs-keyword">for</span> native LFoo;.<span class="hljs-built_in">myfunc</span> ()V<br><br></code></pre></td></tr></table></figure><ol><li>so 库未成功加载,可以通过 logcat 检查加载 so 库的日志;</li><li>方法的名字或者签名不匹配;<br> a. 函数未 <em>extern “C JNIEXPORT</em>;<br> b. 显式注册时,签名不对.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javap -s JavaClassName<br></code></pre></td></tr></table></figure>这个命令可以检查Java方法的签名.</li></ol><h2 id="FindClass-失败"><a href="#FindClass-失败" class="headerlink" title="FindClass 失败"></a>FindClass 失败</h2><ol><li>检查类名,方法名,签名等字符串是否写错,同时检查是否被混淆;</li><li>classloader 的问题: findclass 想在 native 代码关联的 classloader 中搜索类.如果此时是自己创建的 native 线程,再 attach 到 javavm 上,则会在系统 classloader 中查找,如果是自定义的类,必然失败;</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>JNI_OnLoad 中执行一次 FindClass 查找，然后缓存类引用,各个线程则可以放心使用,<strong>优先推荐</strong>.</li><li>通过声明 native 方法来获取 Class 参数: 声明一个有 class 参数的 native 方法,Java 层将 class 传入.这个有些麻烦.</li></ol><h2 id="native-层和-Java-层共享原始数据"><a href="#native-层和-Java-层共享原始数据" class="headerlink" title="native 层和 Java 层共享原始数据"></a>native 层和 Java 层共享原始数据</h2><p>存在以下几种方式</p><ol><li><p>数据转换成 byte 数组,两边都处理 byte 数组<br>Java 层处理起来是很快的,但是 native 层是无法保证不进行 copy 操作的. GetByteArrayElements  和 GetPrimitiveArrayCritical 可以返回 Java 堆上的原始数据的指针,然而有时候,是会在 native 的堆上分配一块空间,再将数据 copy 到 native 堆上的这块空间.</p></li><li><p>直接字节缓存.<br>用 java.nio.ByteBuffer.allocateDirect,JNI 中的 NewDirectByteBuffer 函数来创建直接字节缓存,这个不像常规的 Java 字节 buffer 分配,这部分内存不是在 Java 堆上分配,这部分内存空间,可以交由 native 直接访问(通过 GetDirectBufferAddress 方法地址).<br>这个的弊端是: Java 层对这部分数据分访问可能很慢;</p></li></ol><p>使用哪种方法取决于</p><ol><li>大部分的数据访问是否是通过 Java/C++ ?</li><li>这部分数据最终是否需要传给系统 API?这部分 API 接收的数据格式是什么?(例如，如果数据最终传递给采用 byte[] 的函数，则采用 ByteBuffer 就不合适)</li></ol><p>如果二者差不多,优先使用直接字节缓存.</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://developer.android.google.cn/training/articles/perf-jni#top_of_page">Android JNI Tip</a></li><li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface Specification</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDK</tag>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个开源的Java版的mockserver</title>
    <link href="/2019/10/14/mockserver-java-primer/"/>
    <url>/2019/10/14/mockserver-java-primer/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>记录另外一个mockserver的库使用方式. API 更加丰富.</p><span id="more"></span><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">compile <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;org.mock-server&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;mockserver-netty&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;5.6.1&#x27;</span><br>compile <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;log4j&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;log4j&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;1.2.17&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="最简单的使用方式-请求-gt-返回mock的response"><a href="#最简单的使用方式-请求-gt-返回mock的response" class="headerlink" title="最简单的使用方式, 请求 -&gt; 返回mock的response"></a>最简单的使用方式, 请求 -&gt; 返回mock的response</h2><ul><li>Server端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 8000端口启动服务</span><br>        ClientAndServer.startClientAndServer(<span class="hljs-number">8000</span>);<br><br>        <span class="hljs-comment">// 2. new 一个操作服务端行为的实例</span><br>        MockServerClient serverClient = <span class="hljs-keyword">new</span> MockServerClient(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8000</span>);<br><br>        <span class="hljs-comment">// 3. 定义服务端的行为</span><br>        serverClient<br>                .when(request()<br>                        .withMethod(<span class="hljs-string">&quot;GET&quot;</span>)<br>                        .withPath(<span class="hljs-string">&quot;/path1/function1&quot;</span>))<br>                .respond(response()<br>                        .withStatusCode(<span class="hljs-number">200</span>)<br>                        .withBody(<span class="hljs-string">&quot;body200&quot;</span>));<br><br><br>        serverClient<br>                .when(request()<br>                        .withMethod(<span class="hljs-string">&quot;GET&quot;</span>)<br>                        .withPath(<span class="hljs-string">&quot;/path2/function2&quot;</span>)<br>                        .withCookies(cookie(<span class="hljs-string">&quot;session&quot;</span>, <span class="hljs-string">&quot;4930456C-C718-476F-971F-CB8E047AB349&quot;</span>))<br>                        .withQueryStringParameters(param(<span class="hljs-string">&quot;cartId&quot;</span>, <span class="hljs-string">&quot;055CA455-1DF7-45BB-8535-4F83E7266092&quot;</span>)))<br>                .respond(response()<br>                        .withStatusCode(<span class="hljs-number">307</span>)<br>                        .withBody(<span class="hljs-string">&quot;body307&quot;</span>));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Client 端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockTestClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>        Request request = <span class="hljs-keyword">new</span> Request.Builder().url(<span class="hljs-string">&quot;http://localhost:8000/path1/function1&quot;</span>)<br>                .build();<br>        Response response = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            response = client.newCall(request).execute();<br>            System.out.println(response.body().string());<br>        &#125; <span class="hljs-keyword">catch</span> (<br>                IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上先记录最简单的使用,还有forward,callback,verify,retrieve,感觉用的不多,暂不记录,需要的时候再说吧.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/jamesdbloom/mockserver">mockserverRepo</a></li><li><a href="http://www.mock-server.com/#what-is-mockserver">mockserverPage</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>okhttp自带的mockserver教程</title>
    <link href="/2019/10/13/mockserver_primer/"/>
    <url>/2019/10/13/mockserver_primer/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇记录okhttp自带的mockserver这个库的使用方式.</p><p>作为一个网络库,okhttp自身也实现了一个mockserver,以方便写测试用例,这个库是独立的,也可以单独使用.</p><p>用作平时简单的mock数据,进行测试,很方便</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>此处以Android为例,Java除了依赖方式有点差异,其他一致;</p><ol><li>添加依赖</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">androidTestImplementation(<span class="hljs-string">&#x27;com.squareup.okhttp3:mockwebserver:3.13.1&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>代码使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockRes</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MockWebServer server = <span class="hljs-keyword">new</span> MockWebServer();<br>    <span class="hljs-keyword">public</span> OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleTest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 构造一个mock的 response</span><br>        MockResponse mockResponse = <span class="hljs-keyword">new</span> MockResponse().setBody(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">// 添加到 server 中,server中将会按照FIFO的方式进行返回</span><br>        <span class="hljs-comment">// enqueue 一个,下次请求就返回队列中最靠前的,是同步的</span><br>        server.enqueue(mockResponse);<br><br>        <span class="hljs-comment">// 同步发起请求,虽然此处添加了path,实则在不自定义dispatcher的请求下,是不会影响前一步mockresponse的返回的</span><br>        Response executeRes = executeSynchronously(<span class="hljs-string">&quot;/a&quot;</span>);<br><br>        <span class="hljs-comment">// 消费mock的结果</span><br>        assertNotNull(executeRes);<br>        <span class="hljs-keyword">try</span> &#123;<br>            assertEquals(<span class="hljs-string">&quot;abc&quot;</span>, executeRes.body().string());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customDispatch</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 采用自定义 dispatcher 之后,就不能再 调用 server.enqueue(mockResponse) 方法,所有的mock行为均定义在 Dispatcher 类中</span><br>        server.setDispatcher(<span class="hljs-keyword">new</span> Dispatcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> MockResponse <span class="hljs-title">dispatch</span><span class="hljs-params">(RecordedRequest request)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/a&quot;</span>.equals(request.getPath())) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MockResponse().setBody(<span class="hljs-string">&quot;A&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MockResponse().setBody(<span class="hljs-string">&quot;O&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 同步发起请求,path 为 /a 怎么应该返回body 是 A</span><br>        Response executeRes = executeSynchronously(<span class="hljs-string">&quot;/a&quot;</span>);<br><br>        <span class="hljs-comment">// 消费mock的结果</span><br>        assertNotNull(executeRes);<br>        <span class="hljs-keyword">try</span> &#123;<br>            assertEquals(<span class="hljs-string">&quot;A&quot;</span>, executeRes.body().string());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 同步发起请求,path 为 /b 怎么应该返回body 是 O</span><br>        Response bRes = executeSynchronously(<span class="hljs-string">&quot;/b&quot;</span>);<br><br>        <span class="hljs-comment">// 消费mock的结果</span><br>        assertNotNull(bRes);<br>        <span class="hljs-keyword">try</span> &#123;<br>            assertEquals(<span class="hljs-string">&quot;O&quot;</span>, bRes.body().string());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Response <span class="hljs-title">executeSynchronously</span><span class="hljs-params">(String path, String... headers)</span> </span>&#123;<br>        Request.Builder builder = <span class="hljs-keyword">new</span> Request.Builder();<br>        builder.url(server.url(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = headers.length; i &lt; size; i += <span class="hljs-number">2</span>) &#123;<br>            builder.addHeader(headers[i], headers[i + <span class="hljs-number">1</span>]);<br>        &#125;<br>        Call call = client.newCall(builder.build());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> call.execute();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/square/okhttp/blob/okhttp_3.13.x/okhttp-tests/src/test/java/okhttp3/CallTest.java">okhttp测试</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工程能力之C4模型</title>
    <link href="/2019/04/13/engineering-c4model/"/>
    <url>/2019/04/13/engineering-c4model/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>刚在InfoQ上看到一篇介绍C4Model的文章,觉得这个模型设计的很赞,很有指导意义,做个简单的记录.</p><span id="more"></span><h1 id="Why-为什么需要架构图"><a href="#Why-为什么需要架构图" class="headerlink" title="Why,为什么需要架构图?"></a>Why,为什么需要架构图?</h1><p><code>ThoughtWorks中国</code> 文章中有几句话我觉得很有道理,这里直接摘抄.</p><blockquote><p>“纸上的不是架构，每个人脑子里的才是” ; “那些精妙的方案之所以落不了地，是因为没有在设计上兼容人类的愚蠢”。</p></blockquote><p>我觉得,软件工程,或者软件中的术语发明的原因就是为了减少沟通的障碍,让大家在一个 <strong>平台</strong> 上对话.</p><p>而架构图可以起到如下作用;</p><ol><li>一方面: 让软件的开发人员自己,以及和软件开发相关的用户,PM等人员都能快速了解一个系统的业务模型;</li><li>另一方面: 利于开发人员相互之间协作,定下方案,因为自然语言是有模糊地带的,难以无歧义的传达;</li><li>利于软件系统的维护,一图胜千言.</li></ol><h1 id="What-C4-是什么呢"><a href="#What-C4-是什么呢" class="headerlink" title="What,C4 是什么呢?"></a>What,C4 是什么呢?</h1><p>详细的讲解,可以参考InfoQ的文章,这里做个总结.</p><blockquote><p><em>C4</em> 4个单词的首字母为C的单词的代表, 分别为: 上下文(Context),容器(Container),组件(Component)和代码(Code);</p></blockquote><p>依据不同的受众,分别抽象出了这四个级别.其中容器（应用程序、数据存储、微服务等,组件和代码来描述一个软件系统的静态结构.</p><h2 id="第-1-层：系统上下文"><a href="#第-1-层：系统上下文" class="headerlink" title="第 1 层：系统上下文"></a>第 1 层：系统上下文</h2><p>显示了正在构建的软件系统，以及构建的系统与用户及其他软件系统之间的关系。<br>这个层级的图,关注的是用户层面看到的关系,注重的是和准备开发的系统与外部系统和交互人之间的关系.</p><p><em>将用户,你的代建系统,已有的其他系统用不同的颜色进行区分;</em></p><h2 id="第-2-层：容器"><a href="#第-2-层：容器" class="headerlink" title="第 2 层：容器"></a>第 2 层：容器</h2><p>将软件系统放大，显示组成该软件系统的容器（应用程序、数据存储、微服务等）。</p><p>在这个层级,已经关注系统本身了,开始关注这个系统有哪些部分组成,不过粒度非常粗.</p><h2 id="第-3-层：组件"><a href="#第-3-层：组件" class="headerlink" title="第 3 层：组件"></a>第 3 层：组件</h2><p>将单个容器放大，以显示其中的组件。这些组件映射到代码库中的真实抽象（例如一组代码）。</p><p>在这个层级,关注的已经是系统中的模块具体的功能了,这部分可能对应了具体的功能模块.</p><h2 id="第-4-层：代码"><a href="#第-4-层：代码" class="headerlink" title="第 4 层：代码"></a>第 4 层：代码</h2><p>如若必要,可以放大个别组件，以显示该组件的实现方式。 一般以UML图的形式展示;</p><p>这个层级,是具体的开发人员关注的实现细节了,用于具体的功能逻辑的分析和展示.</p><h1 id="How-怎能画图呢"><a href="#How-怎能画图呢" class="headerlink" title="How,怎能画图呢?"></a>How,怎能画图呢?</h1><p>在C4官网,下有个<strong>Tooling</strong>节点,讲述了目前已有的几个画图工具.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.infoq.cn/article/C4-architecture-model">用于软件架构的C4模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/55185723">可视化架构设计——C4介绍</a></li><li><a href="https://c4model.com/">C4官网</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>C4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP2初探</title>
    <link href="/2019/04/09/H2-First/"/>
    <url>/2019/04/09/H2-First/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP/2 仍是对之前 HTTP 标准的扩展,而非替代.HTTP 的应用语义不变，提供的功能不变,HTTP 方法、状态代码、URI 和标头字段等这些核心概念也不变.</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文是对Google博客上文章的翻译和笔记.以及一些待解决的问题记录. Google 博客上这篇文章的中文版有很多翻译错误.</p><h2 id="HTTP-2-的主要目标是"><a href="#HTTP-2-的主要目标是" class="headerlink" title="HTTP/2 的主要目标是:"></a>HTTP/2 的主要目标是:</h2><ul><li>通过支持完整的请求与响应的多路复用来减少延迟;</li><li>通过有效压缩 HTTP 标头字段将协议开销降至最低;</li><li>增加对请求优先级和服务器推送的支持;</li></ul><h2 id="重要的两点"><a href="#重要的两点" class="headerlink" title="重要的两点"></a>重要的两点</h2><ul><li>HTTP/2 没有改动 HTTP 的应用语义。HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常;</li><li>HTTP/2 修改了<strong>数据格式化(分帧)<strong>以及在客户端与服务器间</strong>传输的方式</strong>;</li></ul><p>这两点统帅全局，通过新的<strong>分帧层</strong>向我们的应用隐藏了所有复杂性。可以实现在同一连接上 进行多个并发交换.</p><h1 id="Binary-framing-layer-二进制分帧层"><a href="#Binary-framing-layer-二进制分帧层" class="headerlink" title="Binary framing layer: 二进制分帧层"></a>Binary framing layer: 二进制分帧层</h1><p>HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/H2_First/H2_first_framinglayer.png?raw=true" alt="二进制分帧层"></p><p>这里所谓的“层”，指的是位于<strong>套接字接口与应用可见的高级HTTP API之间</strong>一个经过优化的新编码机制:HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的<strong>编码方式变了</strong>。</p><p>HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的<strong>消息和帧</strong>，并采用<strong>二进制格式</strong>对它们编码。</p><h1 id="数据流、消息和帧"><a href="#数据流、消息和帧" class="headerlink" title="数据流、消息和帧"></a>数据流、消息和帧</h1><ul><li>数据流：已建立的连接内的<strong>双向</strong>字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的<strong>一系列帧</strong>。</li><li>帧：HTTP/2 通信的<strong>最小单位</strong>，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><h2 id="简单概括一下"><a href="#简单概括一下" class="headerlink" title="简单概括一下:"></a>简单概括一下:</h2><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个<strong>唯一的标识符</strong>和<strong>可选的优先级</strong>信息，用于承载双向消息。</li><li>每条消息<strong>都是</strong>一条逻辑 HTTP 消息(例如请求或响应)，包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等.来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装.</li></ul><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/H2_First/H2_first_stream_connection.png?raw=true" alt="stream和connection之间的关系"></p><p>HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。</p><h1 id="Request-and-response-multiplexing-请求与响应复用"><a href="#Request-and-response-multiplexing-请求与响应复用" class="headerlink" title="Request and response multiplexing: 请求与响应复用"></a>Request and response multiplexing: 请求与响应复用</h1><p>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接.</p><blockquote><p>即: 多个并行请求 == 多个 TCP 连接;</p></blockquote><p>H2 中客户端和服务端将HTTP消息分解为互不依赖的帧,在<strong>一条TCP连接</strong>上交替发送,在最后一端进行重新组装.这样可以实现请求和相应复用.</p><p><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/H2_First/H2_first_%20multiplexing.png" alt="请求响应多路复用"></p><p>图中展示了三个数据流正在并行传输.   <br>客户端正在向服务器传输一个 DATA 帧（数据流 5）.<br>服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。</p><p>优点:显著提高效率;</p><h1 id="Stream-prioritization-数据流优先级"><a href="#Stream-prioritization-数据流优先级" class="headerlink" title="Stream prioritization:数据流优先级"></a>Stream prioritization:数据流优先级</h1><p>将数据分解为帧之后,这些帧就可以实现多路复用,故而,这些帧的顺序就很重要. </p><p>所以H2允许每个数据流都有一个关联的优先级和依赖关系.</p><p>H2 允许:</p><ul><li>每个数据流可以分配一个1到256之间的一个整数,作为权重;</li><li>每个数据流可以和其他的数据流存在明确的依赖关系;</li></ul><p>权重和依赖关系的设定,可以让客户端构造和传达一个优先级树,以表示客户端想要如何接受响应;<br>相对的,服务端可以通过这个优先级树,来控制CPU,内存和其他资源的,以达到设置流优先级的目的;一旦 response 资源可用, 控制带宽的分配可以达到最佳的方式传递高优先级的数据传递到<br>客户端;</p><p>一个流的依赖关系通过引用另外一个流的唯一标识符作为parent,来达到依赖; 如果parent 被省略,则 parent就是root 流;<br>声明流的依赖关系,意味着, parent 流资源分配优先级需要在依赖方之前;</p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/H2_First/H2_first_%20streamprioritization.png?raw=true" alt="权重和依赖关系展示"></p><p>如图:</p><p>图中 D 需要在 C 之前得到处理.</p><p>对于共享一个parent的兄弟节点,则根据他的权重比例进行资源的分配; 图中的A和B,需要按照 12/16 和 4/16 的比例进行资源的分配;</p><p>图中需要解释的有</p><ol><li>D依赖于root stream;</li><li>A 和 B 依赖于 C;</li><li>E 和 C 依赖于 D;</li></ol><p>所以:</p><p>D优先于E和 C得到全部的资源;<br>E和C 优先于AB得到全部的资源; E和C按照等比例拿到资源;<br>C优先于AB 拿到全部资源,此时与权重无关,由依赖关系决定.</p><p>除此之外,优先级和依赖关系还允许客户端在任意的时间点进行修改.这样就允许了浏览器更进一步的优化;换句话中,我们可以在和用户的交互的过程中,修改依赖关系和权重,来达到用户的交互和其他的一些信号.</p><p>PS: 对于权重和依赖关系,只是客户端请求的一个偏好,服务端并不保证一定会按照这个依赖关系和权重进行资源的分配;<br>虽然看上去似乎有违直觉,可是,我们不能因为高优先级的请求block了,而不顾低优先级的任务;</p><h1 id="One-connection-per-origin-每个源-都有个连接"><a href="#One-connection-per-origin-每个源-都有个连接" class="headerlink" title="One connection per origin: 每个源,都有个连接"></a>One connection per origin: 每个源,都有个连接</h1><blockquote><p>即多路复用.</p></blockquote><p>有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；<br>每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。<br>因此，所有 HTTP/2 连接都是<strong>持久化</strong>的，而且每个来源仅需一个连接.</p><p>大多数的HTTP连接都是急促而短暂的,但是TCP对于长连和批量数据进行了优化.  通过复用连接,提高了连接的利用率,也降低了协议的开销.</p><p>可以减少占用的内存和处理空间，也可以缩短完整连接路径;</p><p>连接数量减少,可以减少开销较大的 TLS 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源。</p><h1 id="Flow-control-流控制"><a href="#Flow-control-流控制" class="headerlink" title="Flow control: 流控制"></a>Flow control: 流控制</h1><p>流控制是为了防止出现,接收方繁忙,负载较高,或者仅仅只想为特定的数据流分配固定的资源,然而发送方已经不停的发送;</p><p>这和TCP的控制流类似,然而H2的多个数据流在单一的TCP连接上复用,然而TCP的控制不够精细,也为提供应用级别的API来控制单一流的传输控制.</p><p>H2提供了一组简单的构建块, 来允许客户端和服务端各自的<strong>流级别</strong>和<strong>连接级别</strong>的控制;</p><ul><li>流控制是有方向性的. 每个<strong>接收方</strong>都可以为每个流或者整个连接设置自己期望的窗口大小.</li><li>流控制是基于信用的. 每个<strong>接收方</strong>通告自己的初始连接,初始流的控制窗口的大小(以字节为单位). 任何时候,发送方可以通过发射一个 <em>DATA</em> 帧来减少窗口的大小; 接收方可以发送一个 <em>WINDOW_UPDATE</em> 帧来实现窗口的增大;</li><li>流控制是不能禁用的.  当H2的连接建立之后,客户端和服务端相互交换了 <em>SETTINGS</em> 帧,这个帧交换起到了设置双方在两个方向上窗口的大小. 默认的控制窗口的大小是<em>65535字节</em>,但是接收方是可以在收到任何数据时,通过发送<em>WINDOW_UPDATE</em>帧来设置一个大的 <em>“最大窗口大小”</em>: 2^31-1 个字节来维持这一窗口大小.</li><li>流控制是<em>跳到跳</em>的,而<em>不是</em>端到端的. 也就是说,一个<em>中间人</em>可以基于自身的条件和启发式的算法,使用流控制来控制资源使用和实现资源费分配机制.</li></ul><p>H2未指定任何的流控制算法,替代的,提供了构建块将具体的算法实现交给了客户端和服务端,实现自定义的策略,以实现资源分配和资源的使用; 也可以实现自定义的传输能力以提高真实和感知性能.</p><p>举例: 应用层流控制允许浏览器将流控制窗口设置为0 ,以达到暂停一部分流的加载,先加载优先级更高的流,等到适当的时候再通过调整窗口的大小以重新恢复低优先级的资源加载.</p><h1 id="Server-push-服务器推送"><a href="#Server-push-服务器推送" class="headerlink" title="Server push: 服务器推送"></a>Server push: 服务器推送</h1><p>H2可以实现向客户端发送多个响应. 即可实现无需客户端主动请求的情况,实现对客户端的推送.</p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/H2_First/H2_first_%20serverpush.png?raw=true" alt="服务器推送"></p><p>如图所示,除了stream1 是主动请求,其他的都是服务端主动推送的.</p><p>注意: H2打破了原先的请求响应语义;支持一对多和服务器发起的工作流,</p><p>PUSH_PROMISE 101:<br>所有服务器推送数据流都由<strong>PUSH_PROMISE</strong>帧发起，以表明了服务器向客户端推送所述资源的意图，并且需要先于客户端对于该推送资源的请求。</p><p>故而传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免对这些资源创建重复请求。 满足此要求的最简单策略是,先于父响应（即,<strong>DATA</strong>帧）发送所有<strong>PUSH_PROMISE</strong>帧，其中包含所承诺资源的 HTTP 标头,这样客户端就知道哪些资源是服务端打算推送的。</p><p>在客户端接收到<strong>PUSH_PROMISE</strong>帧 后，它可以根据自身情况选择拒绝数据流（通过<strong>RST_STREAM</strong>帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。）.  这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源。</p><p>使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以</p><ul><li>限制并行推送的数据流数量；</li><li>调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；</li><li>或完全停用服务器推送。<br>这些偏好设置在 HTTP/2 连接开始时通过<strong>SETTINGS</strong>帧传输，也可以随时更新。</li></ul><p>推送的每个资源都是一个数据流，客户端可以对推送的流进行多路复用,设定优先级。<br>浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策：服务器对所提供内容必须具有权威性。</p><h1 id="Header-compression-header-压缩"><a href="#Header-compression-header-压缩" class="headerlink" title="Header compression: header 压缩"></a>Header compression: header 压缩</h1><p>传统H1的 header 使用的是纯文本,这会对传输过程带来500–800 字节的额外开销.<br>H2使用了 <em>HPACK</em> 压缩方式,对请求头和响应头的元数据进行压缩,进而减少开销.<br>采用两种技术:</p><ol><li>对传输的header进行静态哈夫曼编码,可以有效减少独立传输的大小;</li><li>客户端和服务端同时维护和更新一份之前出现过的header字段的索引表;,随后对之前传输过的值进行编码,这份索引表将会作为参考,以提高效率;</li></ol><p>哈夫曼编码允许对单个值在传输的时候进行压缩, 对传输过的值进行索引,这样可以在传递重复的值时,只需索引值,根据索引值,可以快速的查找和重构完整的header 的 key 和 value.</p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/H2_First/H2_first_%20headercompression.png?raw=true" alt="header压缩"></p><p>作为一个深远的优化,哈夫曼编码包含了动态表和静态表.</p><ul><li>静态表包含了一些常用的HTPP header字段,这些字段是所有连接都可能使用的.</li><li>动态表默认是空的,在不同的连接过程中,根据交换的值不同而进行更新.<br>进而带来的结果是,每次请求,因为对未曾出现过的值使用了静态哈夫曼编码,对在两侧静态或者动态表中都出现的使用了索引值而不是直接的原始值,因而这次请求会因此而减小;</li></ul><p>H2中的请求和相应的header字段的定义保持不变,仅有的一个小例外是: 所有的 header 字段的名字必须是小写, 请求行被分割成独立: <em>:method</em>, <em>:scheme</em>, <em>:authority</em>, 和 <em>:path</em> 等伪header字段.</p><h1 id="读完文章后的待解决问题-需要更进一步的研究"><a href="#读完文章后的待解决问题-需要更进一步的研究" class="headerlink" title="读完文章后的待解决问题,需要更进一步的研究"></a>读完文章后的待解决问题,需要更进一步的研究</h1><ol><li>H2中的request line最终变成的格式是什么样的?</li><li>message被切割成frame,这些frame是按照什么规则切割的?文章中的举例是 header 和 data payload .</li><li>head-of-line blocking 是什么?</li><li>One connection per origin这里的origin指的是什么?</li><li>服务器推送的条件是不是建立客户端和服务端曾经建立过连接的基础上.?同时H2是否是保证了每个连接的持久化?,  H2的连接都是持久化的,可以确认;</li><li>压缩部分: 文中提到,H1的所有head等元数据都是纯文本,会增加传输的开销,那么,gzip呢?是如何工作的?</li><li>HPACK 压缩格式 指的是什么?</li><li>静态霍夫曼代码 又指的是什么?</li><li>客户端和服务器同时维护和更新,那么怎么保证双方的表格和index 的一致性呢?</li><li>文中提到对value进行编码,那么key呢?</li><li>文中提到对重复的内容传递 index values ,指的是什么? 同样的问题,那怎么和对应的key对应上?</li><li>静态表和动态表格式是什么样的?</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://developers.google.com/web/fundamentals/performance/http2/#top_of_page">Introduction to HTTP/2</a></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
      <category>H2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity 在横竖屏切换情况下的生命周期变化</title>
    <link href="/2018/04/26/activitylifecycle/"/>
    <url>/2018/04/26/activitylifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Activity 在横竖屏切换的时候,生命周期是不一样的,本地通过打印 log 的方式,看下区别.测试的机器是 Android6.0 .</p><span id="more"></span><h1 id="不做任何配置的情况下"><a href="#不做任何配置的情况下" class="headerlink" title="不做任何配置的情况下"></a>不做任何配置的情况下</h1><h2 id="第一次启动"><a href="#第一次启动" class="headerlink" title="第一次启动"></a>第一次启动</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onCreate() called with: savedInstanceState = [null]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@de950fc<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="第一次切换成横屏"><a href="#第一次切换成横屏" class="headerlink" title="第一次切换成横屏"></a>第一次切换成横屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><br>D/LifeCircleActivity: onPause() called<br>D/LifeCircleActivity: onSaveInstanceState() called with: outState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onStop() called<br>D/LifeCircleActivity: onDestroy() called<br>D/LifeCircleActivity: onCreate() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@266fbfb<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onRestoreInstanceState() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onResume() called<br><br></code></pre></td></tr></table></figure><hr><h2 id="再切换成竖屏"><a href="#再切换成竖屏" class="headerlink" title="再切换成竖屏"></a>再切换成竖屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onPause() called<br>D/LifeCircleActivity: onSaveInstanceState() called with: outState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onStop() called<br>D/LifeCircleActivity: onDestroy() called<br>D/LifeCircleActivity: onCreate() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@7e6e82e<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onRestoreInstanceState() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>默认情况下，每次旋转屏幕都会销毁当前的Activity对象，同时调用 onSaveInstanceState 方法，保存当前的界面状态；之后重新创建 Activity对象， onCreate 参数不为空，回调  onRestoreInstanceState 方法进行恢复。</p><h1 id="配置-configChanges-”orientation”"><a href="#配置-configChanges-”orientation”" class="headerlink" title="配置 configChanges=”orientation”"></a>配置 configChanges=”orientation”</h1><h2 id="第一次启动-1"><a href="#第一次启动-1" class="headerlink" title="第一次启动"></a>第一次启动</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onCreate() called with: savedInstanceState = [null]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@de950fc<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="第一次切换成横屏-1"><a href="#第一次切换成横屏-1" class="headerlink" title="第一次切换成横屏"></a>第一次切换成横屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onPause() called<br>D/LifeCircleActivity: onSaveInstanceState() called with: outState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onStop() called<br>D/LifeCircleActivity: onDestroy() called<br>D/LifeCircleActivity: onCreate() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@266fbfb<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onRestoreInstanceState() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="再切换成竖屏-1"><a href="#再切换成竖屏-1" class="headerlink" title="再切换成竖屏"></a>再切换成竖屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onPause() called<br>D/LifeCircleActivity: onSaveInstanceState() called with: outState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onStop() called<br>D/LifeCircleActivity: onDestroy() called<br>D/LifeCircleActivity: onCreate() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@7e6e82e<br>D/LifeCircleActivity: onStart() called <br>D/LifeCircleActivity: onRestoreInstanceState() called with: savedInstanceState = [Bundle[&#123;android:viewHierarchyState=Bundle[&#123;android:views=&#123;16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5&#125;&#125;], key=x&#125;]]<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>配置 orientation 的情况下，和默认情况一致。</p><hr><h1 id="配置-configChanges-”orientation-screenSize”"><a href="#配置-configChanges-”orientation-screenSize”" class="headerlink" title="配置 configChanges=”orientation|screenSize”"></a>配置 configChanges=”orientation|screenSize”</h1><p>根据官方的介绍，这个两个值，在api大于13 之后，应该一起使用</p><h2 id="第一次启动-2"><a href="#第一次启动-2" class="headerlink" title="第一次启动"></a>第一次启动</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onCreate() called with: savedInstanceState = [null]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@de950fc<br>D/LifeCircleActivity: onStart() called<br>D/LifeCircleActivity: onResume() called<br></code></pre></td></tr></table></figure><hr><h2 id="第一次切换成横屏-2"><a href="#第一次切换成横屏-2" class="headerlink" title="第一次切换成横屏"></a>第一次切换成横屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onConfigurationChanged() called with: newConfig = [&#123;1.0 ?mcc?mnc zh_CN ldltr sw360dp w640dp h336dp 320dpi nrml long land finger -keyb/v/h -nav/h s.11 themeChanged=0 themeChangedFlags=0&#125;]<br></code></pre></td></tr></table></figure><hr><h2 id="再切换成竖屏-2"><a href="#再切换成竖屏-2" class="headerlink" title="再切换成竖屏"></a>再切换成竖屏</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/LifeCircleActivity: onConfigurationChanged() called with: newConfig = [&#123;1.0 ?mcc?mnc zh_CN ldltr sw360dp w360dp h616dp 320dpi nrml long port finger -keyb/v/h -nav/h s.12 themeChanged=0 themeChangedFlags=0&#125;]<br></code></pre></td></tr></table></figure><hr><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>当配置了 screenSize 。则不会再销毁重建了，而是回调 onConfigurationChanged 方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在不做配置默认的情况下,Activity 是被销毁,然后重新启动的.但是在 manifest 中进行相应的配置之后,就表示 Activity 自行处理配置的更改,将阻止 Activity 的销毁重新启动,而是保持运行状态,并且回调 onConfigurationChanged 方法.官方的建议是万不得已的情况下才能使用.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn">AndroidDeveloper</a></li><li><a href="https://developer.android.com/guide/topics/resources/runtime-changes?hl=zh-cn">处理运行时变更</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service 的生命周期</title>
    <link href="/2018/04/26/ServiceLifecycle/"/>
    <url>/2018/04/26/ServiceLifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Service 有两种启动方式,一种是 startService ;一种是 bindService.这两种的启动的 Service 的生命周期有些许差异,并且当二者混用的时候,有一些需要注意的地方.这里用打印 log 日志的方式记录下生命周期的差异.</p><span id="more"></span><h1 id="仅-startService"><a href="#仅-startService" class="headerlink" title="仅 startService"></a>仅 startService</h1><h2 id="触发-startService-方法"><a href="#触发-startService-方法" class="headerlink" title="触发 startService 方法"></a>触发 startService 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onCreate() called<br>D/ServiceLifeService: onStartCommand() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;], flags = [0], startId = [1]<br></code></pre></td></tr></table></figure><h2 id="退出APP"><a href="#退出APP" class="headerlink" title="退出APP"></a>退出APP</h2><p>无回调</p><h2 id="再次进入APP，触发startService-方法"><a href="#再次进入APP，触发startService-方法" class="headerlink" title="再次进入APP，触发startService 方法"></a>再次进入APP，触发startService 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onStartCommand() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;], flags = [0], startId = [2]<br></code></pre></td></tr></table></figure><h2 id="杀死-App-进程"><a href="#杀死-App-进程" class="headerlink" title="杀死 App 进程"></a>杀死 App 进程</h2><p>没有回调，直接被系统杀死。只有一些AMS系统回调</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">W/ActivityManager: Scheduling restart of crashed service cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService in 1000ms<br>I/ActivityManager: Force stopping service ServiceRecord&#123;38ffaacf u0 cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService&#125;<br></code></pre></td></tr></table></figure><h2 id="调用-stop-方法"><a href="#调用-stop-方法" class="headerlink" title="调用 stop 方法"></a>调用 stop 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于 startService 而言</p><ul><li>当要启动的 Service 没有创建时，就会创建，而后回调 onCreate  和 onStartCommand  方法；</li><li>当要启动的 Service 已经存在，则只会回调  onStartCommand 方法；</li><li>退出 App，Service 依旧存活</li><li>调用 stop 方法，回调 onDestroy</li></ul><h1 id="仅-bindService"><a href="#仅-bindService" class="headerlink" title="仅 bindService"></a>仅 bindService</h1><h2 id="触发-bindService-方法"><a href="#触发-bindService-方法" class="headerlink" title="触发 bindService 方法"></a>触发 bindService 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onCreate() called<br>D/ServiceLifeService: onBind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onServiceConnected() called with: name = [ComponentInfo&#123;cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService&#125;], service = [ServiceBinder:cn.steve.servicelifecycle.ServiceLifeService$ServiceBinder@4bb38ec]<br></code></pre></td></tr></table></figure><h2 id="多次触发-bindService-方法"><a href="#多次触发-bindService-方法" class="headerlink" title="多次触发 bindService 方法"></a>多次触发 bindService 方法</h2><p>对于同一个 ServiceConnection 只会进行一次 ServiceConnection 中的方法回调。<br>若不同的 ServiceConnection ，则会进行 ServiceConnection 中的 方法回调</p><h2 id="退出APP-1"><a href="#退出APP-1" class="headerlink" title="退出APP"></a>退出APP</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="退出前，主动调用-unbind-方法"><a href="#退出前，主动调用-unbind-方法" class="headerlink" title="退出前，主动调用 unbind 方法"></a>退出前，主动调用 unbind 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>对于 bindService 而言</p><ul><li>当要启动的 Service 没有创建时，就会创建，而后回调 onCreate  和 onBind  方法；</li><li>当要启动的 Service 已经存在，则只会回调  onBind 方法；</li><li>退出 App，Service 将自动解绑，并回调 onDestroy 方法</li><li>退出 App 和主动 unbind 的回调一致</li></ul><h1 id="先-startService-，再-bindService"><a href="#先-startService-，再-bindService" class="headerlink" title="先 startService ，再 bindService"></a>先 startService ，再 bindService</h1><h2 id="触发-startService-方法，再触发-bindService-方法"><a href="#触发-startService-方法，再触发-bindService-方法" class="headerlink" title="触发 startService 方法，再触发  bindService 方法"></a>触发 startService 方法，再触发  bindService 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onCreate() called<br>D/ServiceLifeService: onStartCommand() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;], flags = [0], startId = [1]<br>D/ServiceLifeService: onBind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onServiceConnected() called with: name = [ComponentInfo&#123;cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService&#125;], service =[ServiceBinder:cn.steve.servicelifecycle.ServiceLifeService$ServiceBinder@598f7d8]<br></code></pre></td></tr></table></figure><h2 id="退出APP-2"><a href="#退出APP-2" class="headerlink" title="退出APP"></a>退出APP</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br></code></pre></td></tr></table></figure><h2 id="调用-unbind-方法"><a href="#调用-unbind-方法" class="headerlink" title="调用  unbind 方法"></a>调用  unbind 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br></code></pre></td></tr></table></figure><h2 id="在-unbind-之前，调用-stop-方法"><a href="#在-unbind-之前，调用-stop-方法" class="headerlink" title="在 unbind 之前，调用 stop 方法"></a>在 unbind 之前，调用 stop 方法</h2><p>无回调</p><h2 id="调用-stop-方法，再调-unbind"><a href="#调用-stop-方法，再调-unbind" class="headerlink" title="调用 stop 方法，再调 unbind"></a>调用 stop 方法，再调 unbind</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="调用-unbind，再调用-stop-方法"><a href="#调用-unbind，再调用-stop-方法" class="headerlink" title="调用 unbind，再调用 stop 方法"></a>调用 unbind，再调用 stop 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>和前面的方式类似，有以下几点需要注意</p><ul><li>bindService 只会导致 Service 回调 onBind 方法，因为 Service本身已经存在，所以，不会再回调 onCreate 方法，也说明 Service 是同一个 Service</li><li>退出 App 后只会让 Service 回调 onUnbind 方法，受 startService 方法的影响， Service 依旧存活，故而不会回调 onDestroy。</li></ul><h1 id="先-bindService-，再-startService"><a href="#先-bindService-，再-startService" class="headerlink" title="先 bindService ，再 startService"></a>先 bindService ，再 startService</h1><h2 id="触发-bindService-方法，再触发-startService-方法"><a href="#触发-bindService-方法，再触发-startService-方法" class="headerlink" title="触发 bindService 方法，再触发  startService 方法"></a>触发 bindService 方法，再触发  startService 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onCreate() called<br>D/ServiceLifeService: onBind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onServiceConnected() called with: name = [ComponentInfo&#123;cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService&#125;], service = [ServiceBinder:cn.steve.servicelifecycle.ServiceLifeService$ServiceBinder@4bb38ec]<br>D/ServiceLifeService: onStartCommand() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;], flags = [0], startId = [1]<br></code></pre></td></tr></table></figure><h2 id="退出APP-3"><a href="#退出APP-3" class="headerlink" title="退出APP"></a>退出APP</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br></code></pre></td></tr></table></figure><h2 id="调用-unbind-方法-1"><a href="#调用-unbind-方法-1" class="headerlink" title="调用  unbind 方法"></a>调用  unbind 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br></code></pre></td></tr></table></figure><h2 id="在-unbind-之前，调用-stop-方法-1"><a href="#在-unbind-之前，调用-stop-方法-1" class="headerlink" title="在 unbind 之前，调用 stop 方法"></a>在 unbind 之前，调用 stop 方法</h2><p>无回调</p><h2 id="调用-stop-方法，再调-unbind-1"><a href="#调用-stop-方法，再调-unbind-1" class="headerlink" title="调用 stop 方法，再调 unbind"></a>调用 stop 方法，再调 unbind</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="调用-unbind，再调用-stop-方法-1"><a href="#调用-unbind，再调用-stop-方法-1" class="headerlink" title="调用 unbind，再调用 stop 方法"></a>调用 unbind，再调用 stop 方法</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">D/ServiceLifeService: onUnbind() called with: intent = [Intent &#123; cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService &#125;]<br>D/ServiceLifeService: onDestroy() called<br></code></pre></td></tr></table></figure><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>和前面的方式类似，有以下几点需要注意</p><ul><li>bindService 调用产生的回调和单独 调用 bindService 一样；</li><li>startService 调用时，因为 Service 对象已经存在，所以只回调 onStartCommand 方法</li><li>退出 App 后只会让 Service 回调 onUnbind 方法，受 startService 方法的影响， Service 依旧存活，故而不会回调 onDestroy。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>已经创建成功的 Service，在运行期间，无论是 start 还是 bind，都不会调用 onCreate；</li><li>Service 在运行期间，每次调用 start 都会触发 onStartCommand 方法；而多次用同一个 ServiceConnection 进行bind 调用时，只会触发一次 onBind ；对于用不同的 ServiceConnection 进行 bind 时，都会触发 ServiceConnection 中的 onServiceConnected 方法，但并不会触发 onBind 方法，所以，相遇于多次触发 onStartCommand 触发，对于 bind 操作来说，onBind 只会触发一次。</li><li>当 start 和 bind 混合调用时，要想停止，必须要调用 unbind 才会回调 onDestory 方法。若先调用 stop，此时没有任何回调，再调用unbind时，会回调onUnbind，同时进行 onDestroy 回调。反之，若先调用 unbind，再调用 stop，回调顺序一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Annotation 使用备忘</title>
    <link href="/2018/01/02/annotation2/"/>
    <url>/2018/01/02/annotation2/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录使用 javapoet 以及 auto-service 进行编译时注解的过程以及注意点. </p><span id="more"></span><p>最近又使用了一次编译时注解,期间产生了不少问题.</p><h1 id="术语的解释"><a href="#术语的解释" class="headerlink" title="术语的解释"></a>术语的解释</h1><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>这个代表被注解的元素.这个类有个很重要的方法,getEnclosingElement:这方法的含义是获取 包裹 element 最外围的元素.比如类的最外围的元素是 package.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PackageElement pkgElement = (PackageElement) element.getEnclosingElement();<br></code></pre></td></tr></table></figure><p>其他方法都很简单.</p><h2 id="javapoet-库中一些重要的接口和方法"><a href="#javapoet-库中一些重要的接口和方法" class="headerlink" title="javapoet 库中一些重要的接口和方法"></a>javapoet 库中一些重要的接口和方法</h2><ol><li><p>TypeName: 对应了 java 代码中的一个类型元素,常用于声明一个方法参数,还有一些 collection 范型使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来定一个 ComponentInfo 类的元素类型</span><br>   TypeName mComponentInfoClassName = ClassName.get(ComponentInfo.class);<br></code></pre></td></tr></table></figure></li><li><p>ParameterizedTypeName 用来声明一个方法的参数.有个 get 方法,这个方法第一个参数是声明原生的类型,后面一个可变参数,声明第一个参数的参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明一个参数的类型是 Map&lt;String,List&lt;ComponentInfo&gt;&gt;</span><br> <br>ParameterizedTypeName paramListComponent = ParameterizedTypeName.get(ClassName.get(List.class), mComponentInfoClassName);<br> ParameterizedTypeName moduleLoaderParameter = ParameterizedTypeName.get(<br>                ClassName.get(Map.class),<br>                ClassName.get(String.class),<br>                paramListComponent<br>        );<br></code></pre></td></tr></table></figure></li><li><p>ParameterSpec</p></li></ol><p>这个类代表方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明一个方法的参数是:final Map&lt;String,List&lt;ComponentInfo&gt;&gt;  targetMap.</span><br> ParameterSpec injectParameterSpec = ParameterSpec.builder(moduleLoaderParameter, <span class="hljs-string">&quot;targetMap&quot;</span>, Modifier.FINAL).build();<br><br></code></pre></td></tr></table></figure><ol start="4"><li>MethodSpec.Builder<br>方法的构造器,用来构造一个方法.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来构造一个私有方法,名字叫 inject ,参数是 Map&lt;String,List&lt;ComponentInfo&gt;&gt;  targetMap,String group,String pkg,String name,int type</span><br>MethodSpec.Builder injectElementBuilder = MethodSpec.methodBuilder(<span class="hljs-string">&quot;inject&quot;</span>)<br>                .addModifiers(Modifier.PRIVATE)<br>                .addParameter(injectParameterSpec)<br>                .addParameter(String.class, <span class="hljs-string">&quot;group&quot;</span>)<br>                .addParameter(String.class, <span class="hljs-string">&quot;pkg&quot;</span>)<br>                .addParameter(String.class, <span class="hljs-string">&quot;name&quot;</span>)<br>                .addParameter(<span class="hljs-keyword">int</span>.class, <span class="hljs-string">&quot;type&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><p>这个构造还可以继续添加语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">injectElementBuilder.addStatement(<span class="hljs-string">&quot;List&lt;$T&gt; list = targetMap.get(name)&quot;</span>, ComponentInfo.class)<br> .beginControlFlow(<span class="hljs-string">&quot;if( list == null )&quot;</span>)<br>                .addStatement(<span class="hljs-string">&quot;list = new $T&lt;&gt;()&quot;</span>, ArrayList.class)<br>                .addStatement(<span class="hljs-string">&quot;targetMap.put(group, list)&quot;</span>)<br>                .endControlFlow()<br>                .addStatement(<span class="hljs-string">&quot;ComponentInfo info = new ComponentInfo(type, group, pkg, name)&quot;</span>)<br>                .beginControlFlow(<span class="hljs-string">&quot;try&quot;</span>)<br>                .addStatement(<span class="hljs-string">&quot; info.setClazz(Class.forName(pkg + name))&quot;</span>)<br>                .nextControlFlow(<span class="hljs-string">&quot;catch(Exception e)&quot;</span>)<br>                .addStatement(<span class="hljs-string">&quot;e.printStackTrace()&quot;</span>)<br>                .endControlFlow()<br>                .addStatement(<span class="hljs-string">&quot;list.add(info)&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意其中的两个 ControlFlow .</p><ol start="5"><li>TypeSpec<br>用来声明一个类的描述<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明一个类,类名是 className,里面有两个方法</span><br>TypeSpec typeSpec = TypeSpec.classBuilder(<span class="hljs-string">&quot;className&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC)<br>                .addMethod(injectElementMethod)<br>                .addMethod(injectMethodSpec)<br>                .build();<br></code></pre></td></tr></table></figure></li></ol><ol start="6"><li>JavaFile</li></ol><p>代表一个输出的 java 文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明一个包名为 : com.steve.pkg 的java 文件.文件描述用的是一个 TypeSpec </span><br>        JavaFile javaFile = JavaFile.builder(<span class="hljs-string">&quot;com.steve.pkg&quot;</span>, typeSpec).build();<br><br></code></pre></td></tr></table></figure><h1 id="使用的注意事项"><a href="#使用的注意事项" class="headerlink" title="使用的注意事项"></a>使用的注意事项</h1><ol><li>新版的 studio 以及不需要 android-apt</li><li>对于注解器的依赖可以通过 annotationProcessor project(‘:processor’) 来对注解器工程进行依赖</li><li>对于注解配置选项可以在 gradle 中进行配置</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">defaultConfig &#123;<br>        minSdkVersion rootProject.ext.android.minSdkVersion<br>        targetSdkVersion rootProject.ext.android.targetSdkVersion<br>        versionCode rootProject.ext.android.versionCode<br>        versionName rootProject.ext.android.versionName<br><br>        javaCompileOptions &#123;<br>            annotationProcessorOptions &#123;<br>                arguments = [<span class="hljs-attr">moduleName:</span> project.getName()]<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>对于注解器的注册,@AutoService(Processor.class),不要写错了,写成 process</li><li>注解器的配置项需要在注解器中声明 @SupportedOptions(“moduleName”)</li><li>注解器中的 log 不要随便打 error,不然就会停止解析,这点和 android 中的 log 有些差异.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Annotation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webview中关于服务端重定向的判断</title>
    <link href="/2017/08/10/webview-judge-302/"/>
    <url>/2017/08/10/webview-judge-302/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于 H5 页面打开都比较慢,为了减少返回时候的刷新,所以有时候需要多开,就是每个 url 都是在一个新的 activity 中打开.一般的处理方式是在 shouldOverrideUrlLoading() 方法中进行处理,这个方法按照 SDK 中的说明是当 url 发生变化时就会回调,当遇到服务端重定向的时候,就会出现一个空白页面的情况,所以我们需要判断是否是重定向,对于重定向进行特殊的处理.</p><span id="more"></span><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span><span class="hljs-params">(WebView view, WebResourceRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> shouldOverrideUrlLoading(view, request.getUrl().toString());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 Android7.0 ,新增了 WebResourceRequest 接口,接口中有个判断是否是重定向的方法,但对于低版本的该如何判断呢?<br>可以做如下判断.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">WebViewClient webViewClient = <span class="hljs-keyword">new</span> WebViewClient() &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mLoaded = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (mLoaded)&#123;<br>                <span class="hljs-comment">//not redirect</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// is redirect</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageFinished</span><span class="hljs-params">(WebView webView, String url)</span> </span>&#123;<br>            mLoaded = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>    &#125;;<br></code></pre></td></tr></table></figure><p>因为能回调 onPageFinished 方法,都是有渲染页面的操作,说明页面是有内容的,对于服务端重定向而言,是没有内容的,所以就不会走 onPageFinished 方法,通过这个间接的判断页面是否是重定向的.目前还未发现有什么不对的地方.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://stackoverflow.com/questions/3852414/in-a-webview-is-there-a-way-for-shouldoverrideurlloading-to-determine-if-it-is-c/45477862#45477862">stackoverflow</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webview</tag>
      
      <tag>redirect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC_Binder_java_2</title>
    <link href="/2017/07/04/IPC-Binder-java-2/"/>
    <url>/2017/07/04/IPC-Binder-java-2/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文作为第一篇的补充,补充一下第一篇遗漏的内容,主要谈一下,缺少的概念,技术背景等内容.</p><span id="more"></span><h1 id="Why为什么需要Binder"><a href="#Why为什么需要Binder" class="headerlink" title="Why为什么需要Binder"></a>Why为什么需要Binder</h1><p>Binder 是 Android 系统进程间通信（IPC）方式之一。Android 是基于 Linux 内核的,Linux 已经有很多 IPC 方式,为何还需要一个新的 IPC 方式.<br>Linux已经拥有</p><ul><li>管道</li><li>system V IPC</li><li>Socket 等IPC手段。</li></ul><p>却还要倚赖Binder来实现进程间通信。</p><ul><li>Binder具有无可比拟的优势。</li><li>或者可以说，Android系统对进程间有什么特殊的需求是传统其他 IPC 无法完成或者无法很好完成。</li></ul><p>基于Client-Server的通信方式广泛应用于从互联网和数据库访问到嵌入式手持设备内部通信等各个领域。</p><p>智能手机平台特别是Android系统中，为了向应用开发者提供丰富多样的功能，这种通信方式更是无处不在，诸如媒体播放，视音频频捕获，到各种让手机更智能的传感器（加速度，方位，温度，光亮度等）都由不同的Server负责管理，应用程序只需做为Client与这些Server建立连接便可以使用这些服务，花很少的时间和精力就能开发出令人眩目的功能。</p><p>Client-Server 方式的广泛采用对进程间通信（IPC）机制是一个挑战。</p><p>只有socket支持Client-Server的通信方式。当然也可以在这些底层机制上架设一套协议来实现Client-Server通信，但这样增加了系统的复杂性，在手机这种条件复杂，资源稀缺的环境下可靠性也难以保证.</p><h2 id="传输性能角度："><a href="#传输性能角度：" class="headerlink" title="传输性能角度："></a>传输性能角度：</h2><ul><li><p>socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。</p></li><li><p>消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</p></li><li><p>共享内存虽然无需拷贝，但控制复杂，难以使用。</p></li></ul><h2 id="安全性角度："><a href="#安全性角度：" class="headerlink" title="安全性角度："></a>安全性角度：</h2><p>Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。</p><ol><li> 传统IPC没有任何安全措施，完全依赖上层协议来确保。</li><li> 传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加才能确保安全性。</li><li> 传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</li></ol><h2 id="效率角度"><a href="#效率角度" class="headerlink" title="效率角度"></a>效率角度</h2><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/IPC%E6%96%B9%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E6%AC%A1%E6%95%B0.png?raw=true" alt="IPC 内存拷贝次数对比"><br>从对比图可以看出,Binder 在效率上是有优势的.</p><h1 id="What-Binder-是什么"><a href="#What-Binder-是什么" class="headerlink" title="What Binder 是什么"></a>What Binder 是什么</h1><p>因为 Binder 也是 CS 架构的一种,而 CS 架构最典型的就是 TCP/IP 请求了.下面做个对比,顺带类比以下 Binder 中的几个关键的概念.<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/TCP%252FIP%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.png?raw=true" alt="TCP/IP访问过程"></p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/Binder%E7%B1%BB%E6%AF%94TCP%E8%BF%87%E7%A8%8B.png?raw=true" alt="Binder类比TCP请求"></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在开发中，经常需要通过 getSystemService 的方式获取一个系统服务,那么这些系统服务的 Binder 引用是如何传递给客户端的呢？要知道，系统服务并不是通过 startService() 启动的。</p><h1 id="ServiceManager-管理的服务"><a href="#ServiceManager-管理的服务" class="headerlink" title="ServiceManager 管理的服务"></a>ServiceManager 管理的服务</h1><p>ServiceManager 是一个独立进程，其作用如名称所示，管理各种系统服务.</p><p>ServiceManager 本身也是一个 Service ，Framework 提供了一个系统函数，可以获取该 Service 对应的 Binder 引用，那就是 BinderInternal.getContextObject().该静态函数返回 ServiceManager 后，就可以通过 ServiceManager 提供的方法获取其他系统 Service 的 Binder 引用。这种涉及模式在日常中是可见的，<br>ServiceManager 就像一个公司的总机，这个号码是公开的，系统中任何进程都可以使用 BinderInternal.getContextObject() 获取该总机的 Binder 对象，而当用户想联系公司中的其他任何人(服务),则要警告总机再获得分机号。这种设计的好处是系统中仅暴露了一个全局 Binder 引用 (ServiceManager),而其他系统服务则可以隐藏起来，从而有助于系统服务的扩展，以及调用系统服务的安全检查。其他系统服务在启动时，首先把自己的 Binder 对象传递给 ServiceManager,即所谓的注册(addService).</p><p>举个具体的例子:</p><ul><li><p>ContextImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSystemService</span><span class="hljs-params">(String name)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (WINDOW_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> WindowManagerImpl.getDefault();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>               LayoutInflater inflater = mLayoutInflater;<br>               <span class="hljs-keyword">if</span> (inflater != <span class="hljs-keyword">null</span>) &#123;<br>                   <span class="hljs-keyword">return</span> inflater;<br>               &#125;<br>               mLayoutInflater = inflater =<br>                   PolicyManager.makeNewLayoutInflater(getOuterContext());<br>               <span class="hljs-keyword">return</span> inflater;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ACTIVITY_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getActivityManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (INPUT_METHOD_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> InputMethodManager.getInstance(<span class="hljs-keyword">this</span>);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ALARM_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getAlarmManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ACCOUNT_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getAccountManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (POWER_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getPowerManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CONNECTIVITY_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getConnectivityManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (THROTTLE_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getThrottleManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFI_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getWifiManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (NOTIFICATION_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getNotificationManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (KEYGUARD_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyguardManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ACCESSIBILITY_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> AccessibilityManager.getInstance(<span class="hljs-keyword">this</span>);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (LOCATION_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getLocationManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SEARCH_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getSearchManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SENSOR_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getSensorManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (STORAGE_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getStorageManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VIBRATOR_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getVibrator();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (STATUS_BAR_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>               <span class="hljs-keyword">if</span> (mStatusBarManager == <span class="hljs-keyword">null</span>) &#123;<br>                   mStatusBarManager = <span class="hljs-keyword">new</span> StatusBarManager(getOuterContext());<br>               &#125;<br>               <span class="hljs-keyword">return</span> mStatusBarManager;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (AUDIO_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getAudioManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TELEPHONY_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getTelephonyManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CLIPBOARD_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getClipboardManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WALLPAPER_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getWallpaperManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DROPBOX_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getDropBoxManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DEVICE_POLICY_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getDevicePolicyManager();<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UI_MODE_SERVICE.equals(name)) &#123;<br>           <span class="hljs-keyword">return</span> getUiModeManager();<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>InputMethodManager.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Retrieve the global InputMethodManager instance, creating it if it</span><br><span class="hljs-comment">  * doesn&#x27;t already exist.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> InputMethodManager <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> getInstance(context.getMainLooper());<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Internally, the input method manager can&#x27;t be context-dependent, so</span><br><span class="hljs-comment">  * we have this here for the places that need it.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> InputMethodManager <span class="hljs-title">getInstance</span><span class="hljs-params">(Looper mainLooper)</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span> (mInstanceSync) &#123;<br>         <span class="hljs-keyword">if</span> (mInstance != <span class="hljs-keyword">null</span>) &#123;<br>             <span class="hljs-keyword">return</span> mInstance;<br>         &#125;<br>         IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);<br>         IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);<br>         mInstance = <span class="hljs-keyword">new</span> InputMethodManager(service, mainLooper);<br>     &#125;<br>     <span class="hljs-keyword">return</span> mInstance;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>ServiceManager.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a reference to a service with the given name.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name the name of the service to get</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&#x27;t exist</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IBinder <span class="hljs-title">getService</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        IBinder service = sCache.get(name);<br>        <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> service;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> getIServiceManager().getService(name);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;error in getService&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过 ServiceManager 获取 InputMethod Service 对应的 Binder 对象 b,然后再将该 Binder 对象作为 IInputMethodManager.Stub.asInterface 的参数，返回一个 IInputMethodManager 的统一接口。</p><p>ServiceManager 的 getService 方法，首先从 sCache 缓存中查看是否有对应的 Binder 对象，有则返回，没有则调用 getIServiceManager().getService().</p><p>getIServiceManager()用于返回系统中唯一的 ServiceManager 对应的 Binder。</p><p>对应的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager <span class="hljs-title">getIServiceManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> sServiceManager;<br>        &#125;<br>        <span class="hljs-comment">// Find the service manager</span><br>        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());<br>        <span class="hljs-keyword">return</span> sServiceManager;<br>    &#125;<br></code></pre></td></tr></table></figure><p>BinderInternal.getContextObject() 方法就是用于获取 ServiceManager 对应的全局 Binder  对象。</p><p>至于关于 注册 服务，等到分析 Framework 启动过程的时候描述。</p><h2 id="理解-Manager"><a href="#理解-Manager" class="headerlink" title="理解 Manager"></a>理解 Manager</h2><p>ServiceManager 所管理的所有 Service 都是以相应的 Manager 返回给客户端，所以简述下 Framework 层对于 Manager 的定义。在Android 中，Manager 的含义类似于现实生活中的经纪人，Manager 所 manage 的对象是服务本身，因为每个具体的服务一般都会提供多个 API 接口，而 manager 所 manage 的正式这些 API。客户端一般不能直接通过  Binder  引用去访问具体的服务，而是要警告一个 Manager，相应的 Manager 类对客户端是可见的，而远程的服务端对客户端来说则是隐藏的。</p><p>而这些 Manager 的类内部都会有一个远程服务 Binder 的变量，而且在一般情况下，这些 Manager 的构造函数参数中都会包含这个 Binder  对象。简单讲，即先通过 ServiceManager 获取远程服务的 Binder 引用，然后使用这个 Binder 引用构造一个客户端本地可以访问的经纪人，然后客户端就可以通过该经纪人访问远程的服务了。</p><p>这种设计的作用是屏蔽了直接访问远程服务，从而给应用程序提供灵活的，可控的 API 接口，比如 AMS ，吸引不希望用户直接访问 AMS，而是经过 ActivityManager 类去访问，而 ActivityManager 内部提供了一些更具可操作性的数据结构化，不如 RecentTaskInfo 数据类封装了最近访问过的 Task 列表；MemoryInfo  数据类封装了和内存相关的信息。</p><h1 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h1><ul><li><a href="https://book.douban.com/subject/6811238/">柯元旦</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IPC</tag>
      
      <tag>Binder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录WebView的file协议的cookie跨域问题</title>
    <link href="/2017/03/19/webviewlocalcookie/"/>
    <url>/2017/03/19/webviewlocalcookie/</url>
    
    <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>在做 hybrid 框架的时候,发现以 file 协议打开的文件,存在 cookie 跨域的问题.以做记录.</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>以 file 协议打开的文件,页面内存在新的跳转,跳转数据通过 cookie 传递,发现cookie 不能正常传递.</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>CookieManager 存在一个静态方法,可以打开 file 协议的 cookie.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allowFileSchemeCookies</span> <span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>这是个静态方法,打开之后,整个 APP 的 webview 就都打开了.</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://developer.android.com/reference/android/webkit/CookieManager.html#allowFileSchemeCookies(">官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webview</tag>
      
      <tag>cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一个进程重启的问题</title>
    <link href="/2017/02/25/activitytaskproblem/"/>
    <url>/2017/02/25/activitytaskproblem/</url>
    
    <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>在项目中，比如推送了一个具体的产品，肯定是打算显示具体的产品详情页，这时候点击返回，也自然打算让用户返回首页,还是让用户留在 APP 内。<br>最近项目在接入华为推送的时候，遇到一个问题,我们的默认启动 Activity 是一个广告页,在从详情页返回到主页的时候,在主页再返回,出现了广告页.</p><p>类似于如图.<br><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/task_desc.png" alt="效果图"></p><span id="more"></span><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>看到这个现象猜测,是不是当栈中有 Activity 实例的时候,进程是会自动重启.为此做了一个实验，A-&gt;B，在 B 中关闭虚拟机，这时候，虚拟机自动重启。打开了 A 页面。</p><p>A-&gt;B-&gt;C，在 C 中关闭虚拟机。</p><p>这时候,栈中的信息如下.<br><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/task_abc.png" alt="正常栈信息"></p><p>此时在 C 中执行关闭虚拟机的操作,然后进程重启.下图是虚拟机重启之后的栈信息。发现,除了之前栈顶的 C 销往了,栈下的 B,C 都还在.并且 B 的状态信息还是重启之前的,除了 pid 不一样了.<br><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/task_ab.png" alt="进程重启栈信息"></p><p>这时候按下返回,栈信息如下.<br><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/task_a.png" alt="重启按下返回键栈信息"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ol><li>为何会出现欢迎页<br>目前发现,华为推送在点击通知的时候,会自动启动 APP 的默认 Activity.</li><li>关于为何进程会重启<br>目前发现的现象是,当栈底还有 Activity 的时候,就会重启. Google 了一些博客,还是未发现有合理的解释.</li><li>为何重启后 task 中原有栈顶的 Activity 的信息和重启之前一模一样?<br>原因是什么?目前不知道怎么下手分析,仅仅是猜测,应该是和 ActivityRecord 有关,系统在重启的时候直接复用了.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Activity</tag>
      
      <tag>Task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BottomNavigationView 的使用</title>
    <link href="/2017/02/18/BottomNavigationView/"/>
    <url>/2017/02/18/BottomNavigationView/</url>
    
    <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>BottomNavigationView 这个概念很早之前就被提出,之后出一个第三方库.但是一直未有官方的支持,今天正好看到有官方支持,记录一下.</p><span id="more"></span><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://material.io/guidelines/components/bottom-navigation.html">BottomNavigationView</a>  是 material design 中的设计的实现，这种设计很早就出现了。</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><ol><li><p>添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">compile <span class="hljs-string">&#x27;com.android.support:design:25.1.1&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>在menu下新建 menu配置文件，顺序就是 bottom bar 显示的顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">menu</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recents&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Recents&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@drawable/ic_recents&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/favorites&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Favorites&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@drawable/ic_favorites&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nearby&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Nearby&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@drawable/ic_nearby&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 drawable 和 drawable-v21下新建item的背景文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!-- in drawable for lower then 21 API--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_pressed</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@android:color/transparent&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--in drawable-v21 folder, for greater or equal then 21 API--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ripple</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ripple</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 layout 下新建布局文件，用来添加 BottomNavigationView</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.BottomNavigationView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bottomNavigationView&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_alignParentBottom</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@android:color/holo_blue_bright&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:itemBackground</span>=<span class="hljs-string">&quot;@drawable/navigationbar_item_bg&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:itemIconTint</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:itemTextColor</span>=<span class="hljs-string">&quot;@android:color/white&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:menu</span>=<span class="hljs-string">&quot;@menu/menu_bottom_navigation_view&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 Activity 或者 fragment 中添加监听即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">bottomNavigationView = (BottomNavigationView) findViewById(R.id.bottomNavigationView);<br><span class="hljs-keyword">this</span>.bottomNavigationView.setOnNavigationItemSelectedListener(<span class="hljs-keyword">new</span> BottomNavigationView.OnNavigationItemSelectedListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onNavigationItemSelected</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MenuItem item)</span> </span>&#123;<br>        Toast.makeText(BottomNavigationViewActivity.<span class="hljs-keyword">this</span>, item.getTitle(), Toast.LENGTH_SHORT).show();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Ｃonclusion"></a>Ｃonclusion</h1><p>官方的这个支持，可扩展性不强，也没什么特别的新意，可参考学习第三方库<a href="https://github.com/roughike/BottomBar/">BottomBar</a>.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BottomNavigationView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加快 AndroidStudio 编译速度之 build cache</title>
    <link href="/2017/02/07/buildCache/"/>
    <url>/2017/02/07/buildCache/</url>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>AndroidStudio 编译速度慢,已经是人神共愤的事情了.本文是一篇译文，讲述如果利用 build cache 技术加快编译速度。分成两部分,一部分是第三方博文,另外一部分是官方文档.援引文章在结尾给出.</p><span id="more"></span><h1 id="Using-build-cache-in-Android-Studio-makes-Gradle-build-faster"><a href="#Using-build-cache-in-Android-Studio-makes-Gradle-build-faster" class="headerlink" title="Using build cache in Android Studio makes Gradle build faster"></a>Using build cache in Android Studio makes Gradle build faster</h1><h2 id="为何关心-build-cache"><a href="#为何关心-build-cache" class="headerlink" title="为何关心 build cache?"></a>为何关心 build cache?</h2><p>因为 build cache 可以加快 clean 和 build 的速度。当你执行 ‘gradle clean build’ 或者类似的命令的时候。</p><h2 id="How-does-it-make-the-build-faster"><a href="#How-does-it-make-the-build-faster" class="headerlink" title="How does it make the build faster?"></a>How does it make the build faster?</h2><p>通过缓存已经分包的 libraries，这个过程是不在 Gradle 的缓存管理范围内的。无论是通过 Android studio 或者 命令行的方式执行 clean 操作，build-cache 内的包都会被保留，等到下次 build apk 的时候，被复用。可以在 build-cache 目录下查看缓存的结构。</p><p><img src="https://zeroturnaround.com/wp-content/uploads/2016/12/android-studio-android-build-cache-dir.png" alt="缓存文件夹"></p><p>这是文件夹下列出的是一系列命名比较奇怪的文件和文件夹。文件大小是 0 字节的文件是用来锁定文件使用的。这个是非常必要的，因为同一个缓存文件可以被不同的项目使用。锁文件，可以防止两个项目同时对一个缓存文件进行读写操作。</p><h2 id="Exploded-aar-caches"><a href="#Exploded-aar-caches" class="headerlink" title="Exploded aar caches"></a>Exploded aar caches</h2><p>aar 缓存以文件夹的形式展现。有两种类型的缓存，一种是 dex 缓存，一种是解压完的 aar 形式的缓存。解压完的 aar 将直接保存在对应的 output 文件夹下。比如 <em>220674f5fc7186b424e032744f0eeb413d469b54</em> 文件夹的  <em>input 文件</em> 包含以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">COMMAND=PREPARE_LIBRARY<br>MAVEN_COORDINATES=com.google.maps.android:android-maps-utils:aar:0.3.4<br></code></pre></td></tr></table></figure><p>文件夹的名字是 <em>input file</em> 的 <em>sha1sum</em> 值。在这个例子里，就是 <em>android-maps-utils</em> 库。解压完的 aar 在依赖的分析过程中（若未被缓存）会被缓存。</p><h2 id="Dexed-caches"><a href="#Dexed-caches" class="headerlink" title="Dexed caches"></a>Dexed caches</h2><p>对于分包缓存，有着和 aar 缓存相似的结构。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">COMMAND=PREDEX_LIBRARY<br>FILE_PATH=/Users/Sten/.android/build-cache/220674f5fc7186b424e032744f0eeb413d469b54/output/jars/classes.jar<br>FILE_HASH=cf251baf39f5c5138224b67b4106eb6331abbd13<br>BUILD_TOOLS_REVISION=25.0.0<br>JUMBO_MODE=false<br>OPTIMIZE=true<br>MULTI_DEX=false<br></code></pre></td></tr></table></figure><p>文件中的 <em>FILE_PATH</em> 指向的就是我们上面所说的文件夹。文件中包含了 <em>android-maps-utils</em> 库的分包版本。<em>input file</em>  中的键值对定义了每个缓存实体。举个例子，<em>build tools revision</em> 是 25.0.0 和 25.0.1 将会有不同的分包缓存，因为 BUILD_TOOLS_REVISION 值不同。但是对于 aar 缓存而言，则会是同一个，因为对于 aar 缓存的 <em>input file</em> 而言，command 未变，maven 地址也没有变，输入文件未变。</p><p>这里的输出是一个文件，而不是一个文件夹。解压之后的文件结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">73  12-06-16 16:07   META-INF/MANIFEST.MF<br>       0  12-06-16 16:07   META-INF/<br>   87000  12-06-16 16:07   classes.dex<br>       0  12-06-16 16:07   com/<br>       0  12-06-16 16:07   com/google/<br>       0  12-06-16 16:07   com/google/maps/<br>       0  12-06-16 16:07   com/google/maps/android/<br>       0  12-06-16 16:07   com/google/maps/android/clustering/<br>       0  12-06-16 16:07   com/google/maps/android/clustering/algo/<br>       0  12-06-16 16:07   com/google/maps/android/clustering/view/<br>       0  12-06-16 16:07   com/google/maps/android/geometry/<br>       0  12-06-16 16:07   com/google/maps/android/heatmaps/<br>       0  12-06-16 16:07   com/google/maps/android/projection/<br>       0  12-06-16 16:07   com/google/maps/android/quadtree/<br>       0  12-06-16 16:07   com/google/maps/android/ui/<br></code></pre></td></tr></table></figure><p>如你所见，这个只是文件夹结构和 classes.dex 文件。</p><h2 id="Multidex-and-API-level-21"><a href="#Multidex-and-API-level-21" class="headerlink" title="Multidex and API level 21"></a>Multidex and API level 21</h2><p>根据 multidex  和 target API 是否高于 21 的不同组合，分包缓存的使用方式也不一样。</p><p>第一种情况是，不使用分包。在这种情况下，API 级别无论是否高于 21 都无关。将会使用分包缓存，也会进行 dex 文件的 merge 操作。在 apk 文件中，我们将会看到只有一个 classes.dex 文件，这个 classes.dex 包含了所有的 application 类和 libraries。</p><p>第二种情况是，minSdkVersion 低于 21 并且 multidex 无法使用 build cache 下的 predex libraries .这是因为兼容包里的 multidex 并不支持 predex.Gradle 插件总是将所有的 application 和 library classes 都放到一个 dex 包里.</p><p>最后一种情况是使用了 multidex 并且 API 级别高于 21.在这种情况下,build-cache文件夹下的分包文件将会被直接打包进 apk 文件中.每个库都将分别拥有一个将被打包进 apk 中的 classes.dex 文件.这也是为什么 API 21 是<a href="https://developer.android.com/studio/build/multidex.html#dev-build">编译时期最佳的选择</a> .</p><h2 id="Performance-measurements"><a href="#Performance-measurements" class="headerlink" title="Performance measurements"></a>Performance measurements</h2><p>针对2015年的 iosched app 在没有 multidex 和 API 最低版本 21 下分别进行测试.打开 Gradle 守护进程,启用和禁用 build cache,分别在命令行下运行 5 次 clean,build 操作.以下是五次运行结果的中位数报告.</p><p><img src="https://zeroturnaround.com/wp-content/uploads/2016/12/android-build-profile-2.png" alt="Clean build without build cache"></p><p><img src="https://zeroturnaround.com/wp-content/uploads/2016/12/android-build-profile-1.png" alt="Clean build with build cache"></p><p>从上图可以看到,编译时间很明显的从 18.7 降到了 6.5秒.从图上也可以很清晰的看到 <em>android:transformClassesWithDexForDebug task</em> 所花的时间,从 12.1 降到了 1.7 秒.节省的时间取决于项目中使用的依赖包数.</p><p>如果还没尝试 Android studio 2.3 ,建议现在尝试.你将会很明显的看到节省的时间.如果你对非正式版的没有兴趣,也可以在 Android studio 2.2 和 Android Gradle plugin 2.2 上实验,通过向项目根目录下的 gradle.properties  文件中添加 <em>android.enableBuildCache=true</em> .</p><!-- more --><hr><p>下面是官方的译文.</p><h1 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在 <em>Android Studio 2.2 Beta3</em> 中介绍了一种可以减少编译时间的新 <em>build cache</em>  缓存特性，这个新特性可以加快包括全量编译，增量编译和 instant run 的编译时间，通过保存和复用前一次由同一个项目或者其他项目 build 产生的文件或者文件夹。<br><em>build cache</em> 目的是为了在所有的 Android 项目中共用。开发者可以通过修改 <em>gradle.properties</em> 文件，实现是否启用 <em>build cache</em> 和指定缓存的位置。当前 <em>build cache</em>  只包含 <em>pre-dexed</em> 库，未来，<em>Android studio</em> 团队会支持其他类型的文件。</p><p><strong>注意</strong>：<em>build cache</em>  的实现是和  <em>gradle cache</em>  管理（例如,reporting up-to-date statuses）是相互独立的。当执行一个 task 的时候，无论是否使用 <em>build cache</em>  对于 Gradle 而言都是未知的（即：即使命中了缓存，Gradle 也不会认为是 up-to-date）。然而，当使用 <em>build cache</em> 的时候，还是希望加快编译速度的。<br>即使目前还未发现有任何问题，我们希望给社区更多的时间以提供更多的反馈。目前这个特性仍旧作为实验性的特性，目前默认还是禁用的。（Android Studio 2.3 Canary 1 开始默认启用）。根据未来的反馈情况，当我们觉得这个特性稳定了，将会在 Android Studio 2.3 或者 2.4 中默认启动。</p><h2 id="How-to-use-the-Build-Cache"><a href="#How-to-use-the-Build-Cache" class="headerlink" title="How to use the Build Cache"></a>How to use the Build Cache</h2><h3 id="Step-0"><a href="#Step-0" class="headerlink" title="Step 0"></a>Step 0</h3><p>确保 <a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.DexOptions.html#com.android.build.gradle.internal.dsl.DexOptions:preDexLibraries">android.dexOptions.preDexLibraries</a>已经设置为 <strong>true</strong>。否则 <em>libraries</em> 不会被 <em>pre-dexed</em>，因而 <em>build cache</em> 并不会被使用。</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>在 Android 项目中打开 <em>gradle.properties</em>，添加以下两个参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android.enableBuildCache=<span class="hljs-literal">true</span> # <span class="hljs-attr">true:</span>启用 build cache，反之禁用。如果这个参数未设置，默认是禁用 build cache.<br><br>android.buildCacheDir=&lt;path-to-build-cache-directory&gt; # 这个是个可选项，用来指定 build cache 目录的绝对路径。如果设置成项目路径，那么是项目于项目的根目录而言的。如果这个参数未被设置，那么默认的目录是 &lt;user-home-directory&gt;<span class="hljs-regexp">/.android/</span>build-cache。如果使用相同的缓存目录，那么多个项目可以共用相同的缓存，所以，推荐使用默认的路径或者使用一个项目外的绝对路径。任何情况下，build cache 的路径都不应该放在 <span class="hljs-string">&quot;build&quot;</span> 文件夹下，除非每次运行 clean 之后，都能删除 build cache 。如果 android.enableBuildCache 被设置成 <span class="hljs-literal">false</span>，则这个参数将会被忽略。<br><br></code></pre></td></tr></table></figure><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>build 项目，或者在命令行下执行 <em>./gradlew assemble</em>,检查以下位置，查看 build cache 是否起作用。</p><ul><li>缓存的文件被存储在了上述  android.buildCacheDir 指定的文件夹下。默认情况下，是在 <em><user-home-directory>/.android/build-cache.</em></li><li>最终的 pre-dexed 文件被存储在了 <em>&lt;project-dir/module-dir&gt;/build/intermediates/pre-dexed/debug</em> 和 *&lt;project-dir/module-dir&gt;/build/intermediates/pre-dexed/release.*。可以在命令行下运行指令查看  “pre-dexed” 文件夹。如果点击的是 Android Studio 面板上的 “Run”  按钮，时无法看到这个文件夹的，因为这个文件夹背会被删除。</li></ul><p><strong>注意</strong>:<br>如果使用 Multi-dex 并且 minSdk &gt;= 21 ，那么 dexed files 将会被直接保存在 <em>&lt;project-dir/module-dir&gt;/build/intermediates/transforms/dex</em> 目录下， 而不是在 <em>&lt;project-dir/module-dir&gt;/build/intermediates/pre-dexed</em>.</p><p>** Cleaning the Build Cache<br>如果想要清除 <em>build cache</em>， 可以直接删除 <em>build cache</em> 文件夹内的内容。<br><em>build cache</em> 文件夹在 <em>android.buildCacheDir</em> 指定的目录下,或者在默认的 <em><user-home-directory>/.android/build-cache</em> 文件夹下.</p><p>从 Android Studio 2.3 Canary 1 开始，Gradle task 中新增了一个叫做 <em>cleanBuildCache</em> 的任务，可以更加便利的删除 <em>build cache</em> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./gradlew cleanBuildCache<br></code></pre></td></tr></table></figure><h1 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h1><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li> <a href="http://tools.android.com/tech-docs/build-cache">Build Cache</a></li><li> <a href="https://zeroturnaround.com/rebellabs/using-build-cache-in-android-studio-makes-gradle-build-faster/">Using build cache in Android Studio makes Gradle build faster</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AndroidStudio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 内存模型_2</title>
    <link href="/2017/01/28/JavaMemoryModel-2/"/>
    <url>/2017/01/28/JavaMemoryModel-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>理解 JMM 就需要理解 JVM 中的运行时内存区域分为哪几部分,以及各个部分的区别.</p><h1 id="内存区域是什么"><a href="#内存区域是什么" class="headerlink" title="内存区域是什么?"></a>内存区域是什么?</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域.这些区域都有各自的用于,以及创建和销毁的时间,有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户县城的启动和结束而建立和销毁.<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/JMM_RunningTimeMemory.png?raw=true" alt="Java 运行时数据区域"></p><p>上图展示了 JVM 虚拟机所管理的几个运行时数据区域.<br>分为两类:</p><ul><li>所有线程都共享的,即 JVM 虚拟机就一份</li><li>线程隔离的数据区,即每个线程所特有的一份,每份线程都会创建一份.它的生命周期与线程相同.</li></ul><span id="more"></span><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>程序计数器是一块儿较小的内存空间,它可以看做是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</p><p>Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都会执行一条线程中的指令.因此,为了线程切换之后,能恢复到正确的执行位置,每条线程都需要一个独立的程序计数器,各条线程之间的计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.</p><p>如果线程正在执行的是一个 Java 方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果执行的是 native 方法,这个计数器的值则为空.</p><p>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域.</p><h2 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h2><p>虚拟机栈描述的是 Java 方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧,栈帧是用于存储 <strong>局部变量表,操作数栈,动态链接,方法出口等</strong> 信息.每个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程.</p><p>局部变量表存放编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double),对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向代表对象的句柄或者其他与次对象相关的位置) 和 returnAddress 类型(指向了一条字节码指令的地址).</p><p>局部变量表所需要的内存空间在编译期完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量的大小.</p><p>这个区域存在两种异常状况:如果线程的栈深度大于虚拟机允许的深度,讲抛出 StackOverflowError 异常;如果虚拟机栈是可以扩展的(当前大部分的 Java 虚拟机都可以动态扩展,只不过 Java 规范也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出 OOM 异常.</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>本地方法栈的作用与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法(字节码) 服务,而本地方法栈则为虚拟机使用到 Native 方法服务.虚拟机规范中并未对本地方法栈中的使用的语言,使用方式与数据结果有强制规定,因此具体的虚拟机可以自由实现,甚至有的虚拟机直接将本地方法栈和虚拟机栈合二为一.</p><p>本地方法栈也会抛出和虚拟机栈一样的异常: StackOverflowError 和 OutOfMemoryError 异常.</p><h2 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h2><p>Java 堆是 JVM 虚拟机管理的内存中最大的一块儿.Java 堆是被<strong>所有的线程共享</strong>的一块儿内存区域,在虚拟机创建的时候就创建.这个区域的唯一目的: 存放对象的实例,几乎所有的对象实例都在这里分配.<br>虚拟机规范的描述: 所有的<strong>对象实例</strong>以及<strong>数组</strong>都要在堆上分配.<br>随着 JIT 编译器的发展与逃逸分析技术逐渐成熟,栈上分配,标量替换优化技术将会导致一些微妙的变化发生,所有的对象都在堆上分配也逐渐变得不是那么的”绝对”.</p><p>Java 堆是垃圾收集器管理的主要区域,因此也会称 Java 堆为 “GC堆”.</p><ul><li>从<strong>内存回收</strong>的角度来看,由于现在的收集器基本都采用分代收集算法,所以 Java 堆还可以细分为: 新生代和老年代;再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。</li><li>从<strong>内存分配</strong>的角度来看,线程共享的 Java 堆中可能换分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB).</li></ul><p>不过无论怎么划分,都与存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分的目的是为了更好的内存回收,或者更快地分配内存.</p><p>根据 Java 虚拟机规范的规定,Java 堆可以处于物理上不连续的内存空间中,只要逻辑上连续即可,就像我们的磁盘空间一样.在实现的时候,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展的来实现的.</p><p>如果堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出 OutOfMemoryError 异常.</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p>方法区与 Java 堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.虽然虚拟机规范把方法区描述成堆的一个逻辑部分,但是它却有一个叫做 Non-Heap(非堆)的名字,目的应该就是为了与堆区分开来.</p><p>习惯了在 HotSpot 虚拟机上开发,部署程序的开发者来说,很多人都更愿意把方法区成为永久代,本质上两者并不等价,仅仅是因为 HotSpot 虚拟机的设计选择将 GC 分代收集扩展至方法区,或者说使用永久代来实现方法区而已,这样 HotSpot 的垃圾收集器可以像管理 Java 堆一样管理这部分内存,能够省去专门为方法区编写内存管理代码的工作了.对于其他虚拟机来说则是不存在永久代这个概念的.永久代现在看来并非是一个好主意,对于 HotSpot 虚拟机,正在放弃永久代,并逐步采用 Native Memory 来实现方法区的规划了,目前在 JDK1.7 中,,已经将原本放在永久代的字符串常量池移出.</p><p>相对而言,垃圾收集行为在方法区是比较少见的,但并非数据进入方法就如永久代的名字一样,真的是永久的存在.这个区域的内存回收目标主要是针对常量池的回收和堆类型的卸载,一般来说,这个区域的内存回收是难以令人满意的,尤其是类型的卸载,条件相当苛刻,但是这个部分的内存回收却又不是非常必要的.</p><p>方法区无法满足内存分配需求时,将抛出 OutOfMemoryError 异常.</p><h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><p>运行时常量池是<strong>方法区的一部分</strong>! class 文件中除了有类的版本,字段,方法,接口等描述信息外,还有一项信息是常量池,用于存在编译期生成的各种字面量和符号引用,这部分内存将在类加载后进入方法区的运行时常量池中存放.</p><p>Java 虚拟机对 class 文件每一部分的格式都有严格规定,每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可,装载和执行,但对于运行时常量池,Java 虚拟机规范没有做任何细节的要求,不同的虚拟机可以按照自己的需要来实现这个内存区域.一般来说,除了保存 class 文件中描述的<strong>符号引用</strong>外,还会把翻译出来的<strong>直接引用</strong>也存储在运行时常量池中.</p><p>运行时常量池对于 class 文件常量池的另外一个重要特征是具备动态性,Java 语言并不要求敞亮一定只有编译期才能产生,也就是并非预置入 class 文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将<strong>新的常量</strong>放入常量池中,这种特性被开发人员利用得比较多的便是 String 类的 intern () 方法.</p><p>既然运行时常量池是方法区的一部分,自然受到方法区内存的限制,当常量池无法再申请到内存的时候,就会抛出 OutOfMemoryError 异常.</p><h2 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h2><p>直接内存并非是运行时数据区的一部分,也不是 Java 虚拟机规范中定义的内存区域.但是这部分内存也被频繁的使用,而且可能导致 OutOfMemoryError 异常出现.</p><p>在 Java1.4 之后新加入了 NIO 类,引入了一种基于通道与缓存区的 I/O 方法,它可以使用 Native 函数库直接分配<strong>堆外内存</strong>,然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块<strong>内存的引用</strong>进行操作.这样能在一些场景中显著的<strong>提高性能</strong>,因为<strong>避免</strong>了在 Java 堆中和 Native 堆中来<strong>回复制数据</strong>.</p><p>显然,本机直接内存分配不会受到 Java 堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存的大小和处理器寻址空间的限制.所以,也是会出现 OutOfMemoryError 异常.</p><h2 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h2><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 内存模型_1</title>
    <link href="/2017/01/15/javaMemoryModel1/"/>
    <url>/2017/01/15/javaMemoryModel1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="http://www.infoq.com/cn/articles/java-memory-model-1">本文记录 Java 中的内存模型的基础部分1。</a><br>本篇作为学习 Java 内存模型基础部分的笔记,加上些许自己的理解和解释.</p><span id="more"></span><h2 id="为什么需要理解-Java-内存模型"><a href="#为什么需要理解-Java-内存模型" class="headerlink" title="为什么需要理解 Java 内存模型"></a>为什么需要理解 Java 内存模型</h2><p>结论:并发产生的内存可见性问题.</p><p>并发编程中的两个关键问题:</p><ul><li>线程之间如何通行(以何种机制来交换信息)</li><li>线程之间如何同步</li></ul><p>已有的通信机制:</p><ul><li>共享内存: 线程之间共享程序的公共状态,线程之间通过读写内存中的公共状态来隐式进行通信.</li><li>消息传递: 在这种模型中,线程之间没有公共状态,线程之间必须通过发送消息显式地通信.</li></ul><p>同步,指的是控制不同线程之间操作发生的相对顺序的机制:</p><ul><li>在共享内存模型中,程序员必须显式的指定某个方法或者某段代码需要在线程之间互斥执行.</li><li>在消息传递的模型里,由于消息的发送必须在消息的接收之前,因此,同步是隐式进行的.</li></ul><p>java 采用的是共享内存模型,而 java 线程之间的通信总是隐式进行,整个通信过程对程序员完全是透明的.<br>对于 java 程序员而言,如果不了解 java 内存模型,在编写多线程程序的时候,就会遇到各种各样的内存可见性的问题.所以,对 java 的内存模型需要有一定的了解.</p><h2 id="Java-采用的共享内存模型是什么样的"><a href="#Java-采用的共享内存模型是什么样的" class="headerlink" title="Java 采用的共享内存模型是什么样的"></a>Java 采用的共享内存模型是什么样的</h2><blockquote><p>Java 采用的是共享内存模型作为线程间的通信机制.</p></blockquote><p>共享内存: 堆内存,在 java 中,所有的 <strong>实例域,静态域和数组元素</strong> 存储在堆内存中,堆内存在线程之间共享.<br>局部变量,方法定义的参数和异常处理参数,不会在线程之间共享,它们不会有内存可见性问题,也不受内存模型的影响.</p><p>Java 线程之间的通信由 Java内存模型(JMM)控制,JMM 决定了一个线程对共享变量的写入何时对另个线程可见.从抽象的角度来看,JMM 定义了线程和主内存之间的抽象关系:线程之间的<strong>共享变量存储在主内存中</strong>,每个线程都有一个私有的本地内存,本地内存中存储了该线程以读写共享变量的副本.<strong>本地内存是 JMM 的一个抽象概念,并不真实存在</strong>.它涵盖了缓存,写缓冲区,寄存器以及其他的硬件和编译器优化.</p><p><img src="https://static001.infoq.cn/resource/image/b0/9b/b098a84eb7598d70913444a991d1759b.png" alt="Java 内存模型抽象示意图"></p><p>分析: 线程 A 和线程 B 通信过程</p><ol><li>线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去.</li><li>线程 B 去主内存中读取线程 A 更新过的共享变量.</li></ol><p><img src="https://static001.infoq.cn/resource/image/2c/cb/2c452d147bf0d09b14b770d3990740cb.png" alt="内存模型案例"></p><p>本地内存 A 和本地内存 B 都有主内存中共享的变量 x 的副本.假设初始时,这个三个内存中的 x 的值都是 0.线程 A 在执行时,把已经更新的 x 值(假设为1) 临时存放在自己的本地内存 A 中. 当线程 A 和线程 B 需要通信的时,线程 A 首先会把本地内存中修改后的 x 值刷新到主内存中,此时主内存中的 x 值变为 1.随后,线程 B 到主内存中读取线程 A 更新之后的 x 值,此时线程 B 的本地内存的 x 值也变为 1.</p><p>从整体上看,这两个步骤实质上是线程 A 在向线程 B 发送消息,而且这个通信过程必须经过主内存.JMM 通过控制主内存与每个线程的本地内存之间的交互,来为 java 程序员提供内存可见性保证.</p><h2 id="重排序-即-java-如何实现同步"><a href="#重排序-即-java-如何实现同步" class="headerlink" title="重排序(即 java 如何实现同步)"></a>重排序(即 java 如何实现同步)</h2><h4 id="为什么需要重排序"><a href="#为什么需要重排序" class="headerlink" title="为什么需要重排序"></a>为什么需要重排序</h4><p>在执行程序的时候,为了提高性能,<strong>编译器 和 处理器</strong> 常常会对指令做重排序.有三种重排序.</p><h4 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h4><ol><li>编译器优化重排序(编译器重排序).编译器在不改变单线程<strong>程序语义</strong>的前提下,重新安排语句的<strong>执行顺序</strong>.</li><li>指令级并行重排序(处理器重排序).现代处理器采用<strong>指令级并行</strong>技术来执行多条指令<strong>重叠执行</strong>.在不存在<strong>数据依赖</strong>的前提下,处理器可以改变语句对应的指令的执行顺序.</li><li>内存系统的重排序(处理器重排序).由于处理器使用缓存和读写缓冲区,这使得加载和存储操作看上去可能是在错乱执行.<br>所以,从 java 源代码到执行阶段,会一次经过三个重排序.以上所述的三个重排序,一个属于编译器重排序,两个属于处理器重排序.</li></ol><h4 id="如何避免重排序带来的问题"><a href="#如何避免重排序带来的问题" class="headerlink" title="如何避免重排序带来的问题"></a>如何避免重排序带来的问题</h4><p>三个重排序,都可能导致多线程出现内存可见性的问题.</p><h5 id="一个例子-说明重排序产生的问题"><a href="#一个例子-说明重排序产生的问题" class="headerlink" title="一个例子,说明重排序产生的问题"></a>一个例子,说明重排序产生的问题</h5><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/JMMprocessor_1.png?raw=true" alt="处理器指令"></p><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：</p><p><img src="https://static001.infoq.cn/resource/image/90/df/9026b8f4b6c1fae4270615e0aadc7cdf.png" alt="程序的顺序"></p><ol><li>这里处理器 A 和处理器 B 可以同时执行赋值操作 A1,B1,将共享变量写入各自的写缓冲区（缓冲区 A ，缓冲区 B）,此时处理器 A 中的写缓冲区中的变量 a 值为1,处理器 B 写缓冲区中的变量 b 值为2,但是还未刷新到内存中;</li><li>然后执行 A2,B2 操作,从内存中读取变量 b 和变量 a 的值(此时的变量 a 和变量 b 的值还是初始状态,都为0),并赋值给 x 和 y,所以,此时的 x 和 y 的值都为 0.</li><li>最后执行 A3 和 B3 操作，把处理器 A  和 处理器 B 写缓存区中保存的脏数据刷新到内存中,此时内存中的变量 a 和变量 b 就是 1 和 2 了。</li><li>执行完所有操作之后, x = y = 0 .</li></ol><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的<strong>内存操作顺序</strong>被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。<br>对于编译器, JMM 的编译器重排序规则会禁止特定类型的<strong>编译器重排序</strong>(并不是所有的编译器重排序都需要被禁止的).<br>对于处理器, JMM 的处理器重排序规则会要求 java 编译器在生成指令序列的时候,插入指定类型的<strong>内存屏障指令</strong>,通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止的).</p><h5 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h5><blockquote><p>现代处理器使用写缓冲区来临时保存向内存写入的数据.写缓冲区可以保障指令流水线持续运行,它可以避免由于处理器停顿下来等待向内存写入数据而产生延迟.同时通过以批处理的方式刷新写缓冲区,以及合并写缓冲区中对同一个内存地址的多次写,可以减少对内存总线的占用.</p></blockquote><p>缓冲区的这一特性是可以加速程序的运行,然而每个处理器的写缓冲区,仅仅对它所在的处理器可见.这个特性会对内存操作的执行顺序产生重要的影响:处理器对内存的读写操作的执行顺序,不一定与内存实际发生的读写顺序一致.</p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/JMM_ReOrder.png?raw=true" alt="重排序类型"></p><p>上表单元格中的 “N” 表示处理器不允许两个操作重排序，“Y” 表示允许重排序。<br>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p><ol><li>注1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。</li><li>注2：上表中的 x86 包括 x64 及 AMD64。</li><li>注3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。</li><li>注4：数据依赖性后文会专门说明。</li></ol><h5 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h5><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/JMM_Barriers.png?raw=true" alt="内存屏障"></p><p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h6 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h6><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型,JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的<strong>结果</strong>需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。（注解：如果只有一个线程的操作，那么前一个操作的结果肯定会对后续的操作可见。)</li><li>监视器锁规则：对一个监视器锁的<strong>解锁</strong>，happens-before 于随后对这个监视器锁的<strong>加锁</strong>。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li></ul><p><strong>注意</strong>，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（<strong>执行的结果</strong>）对后一个操作可见，且前一个操作按顺序排在第二个操作之前(the first is visible to and ordered before the second).</p><p><img src="http://ifeve.com/wp-content/uploads/2013/01/552.png" alt="happens-before与JMM的关系"><br>happens-before 与 JMM 的关系.</p><p>如上图所示，一个 happens-before 规则通常对应于多个编译器和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免 java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h2 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h2><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="http://www.infoq.com/cn/articles/java-memory-model-1">深入理解Java内存模型（一）——基础</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC_Binder_java_1</title>
    <link href="/2017/01/03/IPC-Binder-java-1/"/>
    <url>/2017/01/03/IPC-Binder-java-1/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于 Binder 很复杂,这个分多篇展开,目前先将零碎的知识整合,在后面几篇进行总结.</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p>Binder 用于进程间通信，而 Handler 消息机制用于同进程的线程间通信。<br>Binder 的英文涵义是别针，回形针的意思。<br>在 Android 中 Binder 的存在是为了完成进程间的通信，将进程”别” 在一起。比如说：普通应用可以调用播放器提供的服务：播放、暂停、停止等功能。<br>Binder 是工作在 Linux 层面，属于一个驱动，只是这个驱动是不需要硬件的，或者说是基于操作系统的一小块内存。从线程的角度来讲，Binder 驱动的代码是运行在内核态的，客户端程序调用 Binder 是通过系统调用完完成。</p><span id="more"></span><h2 id="Binder-框架：一种架构"><a href="#Binder-框架：一种架构" class="headerlink" title="Binder 框架：一种架构"></a>Binder 框架：一种架构</h2><p>Binder 框架提供 服务端接口、Binder 驱动、客户端接口 三个模块。<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/Binder%E6%A1%86%E6%9E%B6%E5%9B%BE.png?raw=true" alt="Binder架构"></p><ol><li><p>从服务端的角度来说，一个 Binder 服务端实际上就是一个 Binder 类的对象，该类一旦创建，内部就会启动一个隐藏线程。该线程接下来就用于接收 Binder 驱动发送来的消息，收到消息之后，会执行到 Binder 对象中的 onTransact 方法，在这个方法中，根据不同的参数，执行不同的服务代码。因此，要实现一个 Binder 服务，就必须重载 onTransact 方法。<br>在 onTransact 方法中，会获取传递进来的参数，将其转换成服务函数的参数。onTransact  参数的来源于 客户端的调用  transact 方法。所以，如果  transact 方法的参数有固定的格式输入，那么 onTransact 就会有相应的固定格式输出。</p></li><li><p>从 Binder 驱动的角度来说。任何一个服务端的 Binder 对象被创建的时候，都同时会在 Binder 驱动中创建一个 mRemote 对象，这个对象也是 Binder 类。客户端想要访问远程服务的时候，都是通过这个 mRemote 对象。</p></li><li><p>从客户端的角度来说。要想访问远程服务，必须先获取远程服务在 Binder 驱动中对应的 mRemote 引用，在获取该对象之后，就可以调用 transact 方法，而在 Binder 驱动中，mRemote  对象也重载了 transact 方法。</p></li></ol><ul><li>以线程间消息通信的模式，向服务端发送客户端传递过来的参数。</li><li>挂起当前的线程，当前线程正是客户端线程，并等待服务端线程执行完指定服务函数之后通知。</li><li>接收服务端线程的通知，然后继续执行客户端线程，并返回客户端代码区。</li></ul><p>从以上的叙述中，可以看出，对应用开发者来说，客户端似乎是在直接调用了远程服务对应的 Binder ，而事实上，则是通过 Binder 驱动中的 Binder 对象，不同的是， Binder 驱动中的对象不会额外产生一个线程。</p><ul><li>简言之:<br>客户端将消息发至 -&gt; Binder 驱动 ，向服务端发送调用信息，驱动挂起当前线程 ，等待返回-&gt; 服务端 ，处理完消息，返回给驱动-&gt; 驱动接到完成的通知，继续客户端的线程 - &gt;返回结果给客户端。<br>连接他们的是一个叫 mRemote 的引用，这个引用存在于 Binder 驱动当中，每个服务端的都需要向 Binder 驱动注册，生成这个 mRemote 引用。<br>客户端利用这个引用去发送消息给驱动，驱动利用这个引用去发送消息给服务端， 整个过程像客户端直接调用了服务端，事实上是通过 Binder 驱动中转了，存在两个 Binder 对象，一个是服务端的 Binder 对象， 一个是 驱动中的 Binder  对象，区别中，Binder 驱动中不会产生额外的线程，而服务端的 Binder 在创建之初就有一个隐含的线程。</li></ul><h2 id="设计-Server-端"><a href="#设计-Server-端" class="headerlink" title="设计 Server 端"></a>设计 Server 端</h2><p>设计 server 端只需要新建一个继承 Binder 的 service 即可，当启动这个 service 的时候，在 ddms 中的 thread 会发现多了一个 Binder thread 。<br>定义完  service ，接下来需要重载 onTrasact 方法，并从 data 变量中读取客户端传递进来的参数。 假如，这里有很多参数，那么怎么知道参数的顺序呢？所以，这个需要一个双方的约定。<br>方法的第一个参数 code 是用来标记不同的服务端函数的。<br>如果想要返回结果，则在 reply 中调用相关的函数写入即可。</p><h2 id="设计-Binder-客户端"><a href="#设计-Binder-客户端" class="headerlink" title="设计 Binder  客户端"></a>设计 Binder  客户端</h2><p>对于客户端要想使用服务端的服务函数，则必须先获取服务端在 Binder 驱动中对应的 mRemote 对象。在获取到该对象之后，就可以调用该变量的 transact 方法。<br>public final boolean transact(int code, Parcel data, Parcel reply,  int flags)<br>data 是传递给服务端的数据，远程服务函数的参数，都是从这个 data  中取的。<br>data  中能放的类型都是常用的原子类型，String，int ，long 等，当然也包括实现了 Parcelable接口的类。<br>这里向 data 写入的数据的顺序，必须和 onTransact  取参数的顺序保持一致，需要实现约定好。<br>当调用客户端调用远程方法，经由 mRemote 调用 transact 的时候，客户端线程进入 Binder 驱动， Binder 驱动就会挂起当前线程，并向远程服务发送一个消息，消息中包含了客户端传进来的包裹数据。<br>当服务端 service 执行 onTrasact  的时候，就可以对包裹 data 进行拆解，然后根据参数执行相应的 服务函数，执行完之后，会将执行的结果放入 reply 中。<br>当这一切都执行完之后，服务端会向 Binder 驱动发送一个 notify 的消息（客户端线程在调用 transact 的时候，客户端线程会被挂起），从使得客户端线程从 Binder 驱动代码区返回到客户端代码区。<br>对于最后一个参数 flags ，表示的是 IPC 调用的模式，分为：双向，用0 表示，含义是服务端执行完之后会返回一定的数据；还有一种是单向，用1 表示，含义是不返回任何数据。<br>同样的，返回到结果都是在 reply 中，客户端从这个 reply 中取的数据，这部分顺序也必须实现约定好。</p><h2 id="使用-service"><a href="#使用-service" class="headerlink" title="使用 service"></a>使用 service</h2><p>在编写 Binder 服务端和客户端的过程中，会伴随着两个问题。</p><ul><li>客户端如何获得服务端的 Binder 对象引用</li><li>客户端和服务端约定关于顺序的顺序和服务函数的 int 标志。</li></ul><p>使用 Binder 的原因是想提供一个全局的服务，所谓的全局，意思是系统中的任何程序都可以访问 。很明显，这个应该属于操作系统需要提供的基本功能之一，所以有个方法就是 service。</p><p>无论是否使用 service类，都需要解决上面的两个问题。</p><p>当然完全可以不使用 service 类，而是仅仅基于 Binder 类编写服务程序，然而这个只是一部分。具体来说，可以仅仅使用 Binder 类扩展系统服务，对于客户端服务则必须是基于 service 类来编写的。系统服务是指那些通过 getSystemService 方法获取的服务，而客户端服务是指应用程序提供的自定义服务。<br>也就是说，扩展系统服务的时候，可以完全只使用 Binder 类；而对于客户端的服务则必须基于 service。</p><h3 id="获取-Binder-对象"><a href="#获取-Binder-对象" class="headerlink" title="获取 Binder 对象"></a>获取 Binder 对象</h3><p>看下几个启动 service 相关的方法，这些方法在 android.app.ContextWrapper 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(Intent service)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mBase.startService(service);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法很熟悉，就是一个 启动服务的方法，然后启动之后，客户端并不能拿到服务端的 Binder 引用，因此并不能调用服务端的任何服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bindService</span><span class="hljs-params">(Intent service, ServiceConnection conn,   <span class="hljs-keyword">int</span> flags)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBase.bindService(service, conn, flags);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceConnection</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bindService 方法第一个参数是启动 service 的intent ，第二个参数是一个接口，接口中有个方法叫 onServiceConnected 这个方法含有两个参数，第二个参数就是 Binder 。<br>具体的运行过程中，当客户端请求启动 service 的时候，请求就会通过 Ams 发出，若 service 正常去懂了，那么 Ams 就会远程调用 ActivityThread 类中的 ApplicationThread 对象，调用的参数就包含了 service 的 Binder  对象的引用，然后在 ApplicationThread  中回调 bindService 的第二个参数 ServiceConnection  的方法 onServiceConnected ，将 Binder 引用传递回客户端，这样客户端就拿到了远程服务的 Binder  对象引用，在实际操作中，常常可以这个 Binder 对象引用设置成一个全局变量，可以在客户端的任何地方都可以访问到。</p><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/Binder%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png?raw=true" alt="Binder客户端和服务端的调用过程"></p><h2 id="保证参数顺序的工具-AIDL"><a href="#保证参数顺序的工具-AIDL" class="headerlink" title="保证参数顺序的工具-AIDL"></a>保证参数顺序的工具-AIDL</h2><p>在数据传递的过程中，需要实现约定好服务函数所对应的 code 的 int 值，需要约定好参数的写入顺序。在 Android 中的 AIDL 就是这么个工具。<br>AIDL 可以将一个 AIDL 文件转换成一个 Java  类文件，同时重载 transact 和 onTransact 方法。关于服务函数对应的 int 值和参数的读写书序，都统一做了处理。这样，开发者只需要专注于服务代码本身了。<br>可以看得出来，AIDL 并非是必须的，只是一个工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICompute</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> anInt, <span class="hljs-keyword">long</span> aLong, <span class="hljs-keyword">boolean</span> aBoolean, <span class="hljs-keyword">float</span> aFloat,<span class="hljs-keyword">double</span> aDouble, String aString)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，第一个字母是 I，这样是为了程序风格的统一，后面的 Compute 是服务的类名，AIDL 工具会以这个服务的名字生成 Java 类。( 当然这个是默认的，相应的也是可以修改的，具体的另行参照说明。 )<br>aidl 文件中可以引用其他的 Java 类，但是需要遵循以下要求：</p><ul><li> Java 原子类型，int，long，String 等。</li><li> Binder 引用。</li><li> 实现了 parcelable 接口的对象。</li></ul><p>运行 AIDL 工具之后，生成的文件中，包含了 Java interface，proxy，stub类。</p><ul><li> Java interface 是以 aidl 文件命名的。比如 ICompute 。产生的 interface就是 ICompute 。并且该类继承了 IInterface 接口，即，需要实现 asBinder 方法。</li><li> 在 Stub 内部还有一个内部静态类 proxy ， 该类具体实现了 AIDL 生成的接口，按照约定的顺序写入参数，可以注意到这里的顺序和 Stub 中重载的 onTransact  中读取的顺序是一致的。proxy 类中持有了一个 IBinder mRemote 对象，这个对象就是远程服务端的引用，Proxy 该类作为客户端访问服务端的代理，该类的代理产生的原因：主要是为了解决约定写入参数的顺序。</li><li> 内部有一个静态内部抽象类 Stub，这个类主要是由服务端使用 ，之所以是抽象类，因为具体的服务函数必须由程序员自己去实现。该类继承 Binder 类，并且实现 AIDL 生成的接口，但是没有具体的实现这个接口。该类也重载了 onTransact 方法，这个方法是去按照约定的顺序取参数中的值，因为是 ADIL 自己生成的，所以顺序，它自己很清楚；并且定义了服务函数对应的 int 值。asBinder 方法返回的就是 Stub 自身。它内部还有个非常重要的方法  asInterface ，这个方法根据参数 IBinder 对象是否是自身进程中的对象，返回不同的对象。因为我们知道，服务端的服务函数，不仅仅是别的进程可以使用，与 服务端在一个进程内部也可以调用，这种场景下，显然是不需要 IPC 的，而是直接调用。反之，则返回一个 proxy，交由跨进程的客户端引用。在 Binder 内部提供了 queryLocalInterface 方法根据描述符判断当前的 Binder 对象时不是本地的 Binder 引用。因为每当新创建一个 Binder 对象的时候，服务端进程内部会创建一个 Binder 对象，同时在 Binder 驱动中也会创建一个 Binder 对象。如若是跨进程调用，远程访问的时候，返回的 Binder 就会是 Binder 驱动中的 Binder 对象，如若是进程内部获取 Binder 对象，则会是服务端本身的 Binder 对象。所以，asInterface  是对外提供了一个 统一的接口，保证无论进程内还是进程外都能访问，返回的对象就两种，一个是 Proxy 类对象，一个就直接使用 Stub 本身，强制类型转换成 接口类型。</li></ul><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/Binder_3.png?raw=true" alt="Binder架构"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇最后,放一张图进行总结.<br><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/Binder%E7%BB%91%E5%AE%9A%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true" alt="Binder绑定的流程"></p><h1 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h1><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="https://book.douban.com/subject/6811238/">柯元旦</a></li><li><a href="http://gityuan.com/2015/12/26/handler-message-framework/">gityuan</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IPC</tag>
      
      <tag>Binder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android消息机制_Java层</title>
    <link href="/2016/12/17/MessgaeMechanism/"/>
    <url>/2016/12/17/MessgaeMechanism/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 Android 的消息机制在 java 层的原理分析.</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在学习 Binder,IPC 的时候,涉及到消息机制,顺带整理一下.</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>进程:系统进行资源分配和调度的基本单位.<br>在 Andrid 中,对于每个 App 运行时前,系统都会为其创建一个进程，App 就运行在一个进程中.</p><p>线程: 作为程序执行的最小单元。<br>该线程与 App 所在进程之间资源共享，从 Linux 角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个 task_struct 结构体，在 CPU 看来进程或线程无非就是一段可执行的代码.</p><p>Android 主线程: 一个进程中就一个主线程,这个主线程负责更新 UI.</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>目前对为什么需要消息机制,还没认真的研究,个人觉得系统的运转和程序的运行说到底都是消息的传递,如何让这些程序的消息传递高效地的运转,于是产生了消息机制一说.</p><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>什么是消息机制?消息机制的三大要素:</p><ul><li>消息队列 </li><li>消息循环</li><li>消息类型</li></ul><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>在 Android 中是如何使用消息机制的? Android 中典型的消息机制就是 Handler.<br>以下是我们平时使用 Handler 经常使用的方式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Callback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;截断消息&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;再处理消息&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>mHandler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;second&quot;</span> + Thread.currentThread());<br>    textView.setText(<span class="hljs-string">&quot;upate&quot;</span>);<br>     &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>前面的概述中说到,对于系统而言,无论是线程还是进程,对其而言,都是一段可执行的代码而已,没有那么既然是可执行的代码,执行完,线程生命周期也就结束了.<br>在 Android 中,对于主线程，我们是绝不希望会被运行一段时间就结束了，我们希望它能一直的运行下去,直到用户主动的退出 APP 或者出现其他意外.<br>那如何才能实现这样的效果呢?不就是为了能一直运行吗?死循环便能保证不会被退出.</p><p>但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。<br>我们看下在 ActivityThread 中的 main 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>....<br>Looper.prepareMainLooper();<br><br>ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();<br><br>thread.attach(<span class="hljs-keyword">false</span>);<br><br>Looper.loop();<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityThread 并不是线程，并没有真正继承 Thread 类，只是运行在主线程，其实承载 ActivityThread 的主线程就是由 Zygote fork 而创建的进程。</p><p>从这里的代码可以看到,主线程是一个死循环,主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll 机制.下面分析 loop 函数的时候遇到再说.<br>下面分别看下消息机制的三个要素.</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>对于 looper 的典型例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Looper.prepare();<br>mHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>          <span class="hljs-comment">// handle message</span><br>     &#125;<br>&#125;;<br>Looper.loop();<br><br>上面就是一个典型的 Looper 的使用步骤<br>- 调用 prepare 方法<br>- 创建 Handler 对象<br>- 调用 loop 方法<br><br></code></pre></td></tr></table></figure><p>对于 prepare 方法，每个线程只能执行一次，当检测到当前的线程已经执行过这个方法，则会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Looper&gt;();<br><span class="hljs-comment">// ..............</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 ThreadLocal 类，这个称为线程本地存储，以线程为单位，实现资源的共享。每个线程有自己的私有区域，线程间是不能互相访问的。有的地方也能看到用 ThreadLocal 实现线程内的单例。</p><p>其中对应的 set 和 get 方法，这样就能实现一个线程只有一个 looper ，检查的时候只要判断当前的线程本地存储是否有 looper 就能确定当前的线程是否执行过 prepare 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> (T)e.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper 的构造方法中需要传递一个 boolean 值的参数，表示创建的这个 looper 是否可以被取消，直观上说就是是否可以调用 quit 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Looper</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>    mQueue = <span class="hljs-keyword">new</span> MessageQueue(quitAllowed);<br>    mThread = Thread.currentThread();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于默认的 looper 构造传的是 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Initialize the current thread as a looper.</span><br><span class="hljs-comment">  * This gives you a chance to create handlers that then reference</span><br><span class="hljs-comment">  * this looper, before actually starting the loop. Be sure to call</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> #quit()&#125;.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>    prepare(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有个 looper 之后，就可以创建熟知的 handler 对象了。handler 在创建的时候，都是会检查当前的线程是否有 looper ，如果没有，则会抛出异常，不能正常的创建，毕竟这是一个消息机制必不可少的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<br>        <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();<br>        <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;<br>                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +<br>                klass.getCanonicalName());<br>        &#125;<br>    &#125;<br><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    mQueue = mLooper.mQueue;<br>    mCallback = callback;<br>    mAsynchronous = async;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以调用 loop 方法进入循环模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Looper me = myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<br><br>    <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>    <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ident = Binder.clearCallingIdentity();<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Message msg = queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>        <span class="hljs-keyword">final</span> Printer logging = me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> traceTag = me.mTraceTag;<br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            msg.target.dispatchMessage(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>                Trace.traceEnd(traceTag);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>        &#125;<br><br>        <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>        <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> newIdent = Binder.clearCallingIdentity();<br>        <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>            Log.wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                    + Long.toHexString(ident) + <span class="hljs-string">&quot; to 0x&quot;</span><br>                    + Long.toHexString(newIdent) + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                    + msg.target.getClass().getName() + <span class="hljs-string">&quot; &quot;</span><br>                    + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>        &#125;<br><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直观上我们就可以看到这是一个死循环，不断的通过 queue.next() 取出消息，而后通过 msg.target.dispatchMessage(msg); 去分发，处理消息。最后会通过 msg.recycleUnchecked(); 回收消息以备循环使用。<br>上面的消息处理是一个死循环，我们知道在主线程也有个 looper 这样不停的死循环执行，怎么就不会卡死呢？CPU 怎么不会爆表呢。<br>注意 Message msg = queue.next(); // might block 这里的注释，说可能产生 block （阻塞）。这个涉及到 MessageQueue，native 层 和 epoll 机制，当队列中没有消息的时候，这个时候，就会被阻塞挂起，直到下个消息到达,或者被唤醒,这个下面分析队列的时候再看,这时候 CPU 就会被释放，去做其他任务，这样就不会浪费 CPU 资源。</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue:"></a>MessageQueue:</h2><p>对于期初构造 looper 的时候传递了一个参数，表示了是否可以退出，在构造 looper 的时候 ，这个参数，也会传递到 MessageQueue  的构造方法中。<br>looper 中的 quit 方法最终调用的是 MessageQueue 中的 quit 方法，在 quit 方法中，假如当初传递的参数是 false，则会抛出异常，即表示不能退出的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">MessageQueue(<span class="hljs-keyword">boolean</span> quitAllowed) &#123;<br>    mQuitAllowed = quitAllowed;<br>    mPtr = nativeInit();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> safe)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Main thread not allowed to quit.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mQuitting = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">if</span> (safe) &#123;<br>            removeAllFutureMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeAllMessagesLocked();<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting was previously false.</span><br>        nativeWake(mPtr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在quit 方法中也区分了 safe 和 unsafe。安全的方式只移除那些还未开始的消息，非安全的方式是移除所有的消息。</p><p>再细看 MessageQueue 的构造方法中有个 nativeInit();说明这里有涉及 native 方法。这里注下,在整个消息机制中 只有 MessageQueue 是涉及 Java 层和 Native 层的。<br>当 MessageQueue 没有消息的时候,便阻塞在 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作,看 native 代码的话,是一个 “w” 字符.上面说过,这叫做 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 I/O，即读写是阻塞的。所以,当消息队列中没有消息的时候,主线程就会释放 CPU ,不会继续占用 CPU ,这里就解释了为什么主线程是个死循环,还能继续处理其他事情.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>    <span class="hljs-comment">// which is not supported.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ptr = mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>            Message prevMsg = <span class="hljs-keyword">null</span>;<br>            Message msg = mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>            <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>            <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                mBlocked = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-keyword">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// Run the idle handlers.</span><br>        <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-keyword">boolean</span> keep = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>        <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里稍微记录下这个方法，怎么看这个方法可能都是消息机制在 Java 层相对难以理解的一个。</p><ol><li>MessageQueue 通过 next 方法从消息队列中取出 消息执行，nativePollOnce 可以看出这里又牵扯到 native 方法 ，nativePollOnce  是一个阻塞操作，为什么会这样呢？因为在 native 层也有消息机制，从这里能看出 Android 系统中，native 层的消息优先级比 Java 层的高。注意: native 层的消息机制和 Java 层的<strong>没有任何关系</strong>。顺带说下参数 mPtr 是在构造参数里调用 native 方法初始化的，这个参数是 NativeMessageQueue 的指针。nextPollTimeoutMillis 代表了超时的时间，这个是用来描述当消息队列中没有新的消息需要处理的时候，当前线程需要进入睡眠等待状态的时间。</li></ol><ul><li>这个可以取值 -1 ，代表了队列中没有消息需要处理，需要一直休眠阻塞下去，直到被其他线程唤醒为止。</li><li>取值为0，表示当前的线程不需要进入等待状态，即使当前的消息队列中没有新的消息需要处理。</li><li>取值为大于0，表示当消息队列中没有新的消息的时候，等待大于0的时间就返回。</li></ul><ol start="2"><li>mMessages 表示当前处理的消息， 通过循环取出有 Handler 并且是异步的消息然后返回。如果没有找到就将  nextPollTimeoutMillis 置为 -1 表示队列中没有消息，需要一直休眠了。</li><li>mIdleHandlers 表示的是空闲处理器，当消息队列中没有需要处理的消息的时候，做的一些工作，例如垃圾回收等，完成这部分操作之后就会重置 pendingIdleHandlerCount 的值为0，保证整个循环中只执行一次，这个值为 0 还对 nextPollTimeoutMillis 有影响，在上半部分有个 nextPollTimeoutMillis  的判断。同时 nextPollTimeoutMillis 也被置为 0 ，表示不需要进入等待状态，立即检查消息队列。</li></ol><p>在这里，nextPollTimeoutMillis 置为 0 可能会造成一定的干扰，理解立即检查不难，似乎每次都会被置为 0 ，那么 -1 是不是就没有意义了呢？注意另外一个值  pendingIdleHandlerCount 也被置为了0 ，注意取消息的时候关于这个 pendingIdleHandlerCount 的检查，当为 0 的时候，是直接 continue 了。</p><p>看下往队列中添加消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        msg.markInUse();<br>        msg.when = when;<br>        Message p = mMessages;<br>        <span class="hljs-keyword">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>            <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>            <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的目的是找到当前加入的这个消息在消息队列中合适的位置，是立即执行，亦或者插入到消息队列中。<br>其中会根据当前的消息循环 next 是否被阻塞，决定是否执行唤醒操作。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler:"></a>Handler:</h2><p>看下 Handler 的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<br>        <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();<br>        <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;<br>                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +<br>                klass.getCanonicalName());<br>        &#125;<br>    &#125;<br><br>    mLooper = Looper.myLooper();<br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);<br>    &#125;<br>    mQueue = mLooper.mQueue;<br>    mCallback = callback;<br>    mAsynchronous = async;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Looper looper, Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    mLooper = looper;<br>    mQueue = looper.mQueue;<br>    mCallback = callback;<br>    mAsynchronous = async;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是这两种构造函数，第一种可以可以指定回调函数和消息的处理方式(是否是异步处理)。第二种可以指定 Looper ，回调函数 和消息的处理方式。</p><p>上面说到 Looper 的 loop 方法在循环取出消息和处理的时候提到一个  msg.target.dispatchMessage(msg); 分发处理。平时的使用经验让我们知道这个 target 其实是个 Handler 。<br>所以接下来看下这个 dispatchMessage 分发消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以，假如 Message 有回调的情况下， 优先执行的是 Message 的回调方法。其次，如果没有回调的情况下，检查 Handler 构造的时候是否有设置回调，如果有优先调用这个回调。再次，才会去调用子类覆写的 handleMessage 方法。我们平时使用的时候，常常就是使用的这个再次的方式。</p><p>上面有说过消息队列是负责消息的排队的，接下来看下到底是怎么产生消息，怎么进入队列的。<br>首先看下几个常用的产生消息的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Message <span class="hljs-title">obtainMessage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> Message.obtain(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(Message msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendEmptyMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> sendEmptyMessageDelayed(what, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">post</span><span class="hljs-params">(Runnable r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>平时常用的就这四种种方式产生消息并且发送消息，对于 Message 的 sendToTarget 方法，本质上还是调用的 sendMessage 这个后面再说，这个几个方法最后都会走 sendMessageAtTime 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>    MessageQueue queue = mQueue;<br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;<br>        RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>        Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>    msg.target = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>在  sendMessageAtTime 方法中进行了一些检查，检查是否已经有  MessageQueue ，如果没有则抛出异常， 毕竟 MessageQueue 也是消息机制不可或缺的元素。<br>检查通过之后就会进入  enqueueMessage  方法， 这个方法中会调用 MessageQueue  的 enqueueMessage  方法将消息添加入队列中(这个方法后面详细再说)，同时会根据构造 Handler 的时候设置的消息处理方式来为 message 设置相应的属性。</p><p>从分析中可以看出，Handler 本身没有太多实质性的操作，都是借助于 Meesage ，MessageQueue ，Looper 这个几个类。说明 Handler 只是一个很强的辅助类而已，方便开发者 产生消息-&gt;发送消息-&gt;处理消息。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h2><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler:"></a>IdleHandler:</h3><p>空闲时处理器，这个只有在 looper 执行消息循环的第一次会执行。</p><h3 id="Message："><a href="#Message：" class="headerlink" title="Message："></a>Message：</h3><p>作为消息的封装类，是消息的载体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> what;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> arg1;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> arg2;<br><span class="hljs-keyword">public</span> Object obj;<br><span class="hljs-keyword">public</span> Messenger replyTo;<br><span class="hljs-keyword">long</span> when;<br>Handler target;<br>Runnable callback;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>以上是 Message 的构造方法和比较重要的属性。<br>静态变量 sPool 的数据类型为 Message，通过 next 成员变量，维护一个消息池；静态变量 MAX_POOL_SIZE 代表消息池的可用大小；消息池的默认大小为50。</p><p>看下几个比较重要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-keyword">null</span>) &#123;<br>            Message m = sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-keyword">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Message();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有其他几个带参 的 obtain 方法，但是都需要调用这个无参的，可以看到 从静态变量 sPool  中取出一个 Message 即返回，若是 sPool 为空，则新建一个 Message 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isInUse()) &#123;<br>        <span class="hljs-keyword">if</span> (gCheckRecycle) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;This message cannot be recycled because it &quot;</span><br>                    + <span class="hljs-string">&quot;is still in use.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    recycleUnchecked();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleUnchecked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Mark the message as in use while it remains in the recycled object pool.</span><br>    <span class="hljs-comment">// Clear out all other details.</span><br>    flags = FLAG_IN_USE;<br>    what = <span class="hljs-number">0</span>;<br>    arg1 = <span class="hljs-number">0</span>;<br>    arg2 = <span class="hljs-number">0</span>;<br>    obj = <span class="hljs-keyword">null</span>;<br>    replyTo = <span class="hljs-keyword">null</span>;<br>    sendingUid = -<span class="hljs-number">1</span>;<br>    when = <span class="hljs-number">0</span>;<br>    target = <span class="hljs-keyword">null</span>;<br>    callback = <span class="hljs-keyword">null</span>;<br>    data = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>            next = sPool;<br>            sPool = <span class="hljs-keyword">this</span>;<br>            sPoolSize++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用回收方法的时候，就会将当前的消息插入到静态变量 sPool 的头部，实现循环利用。</p><h2 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h2><p>下次总结 Binder 在 Java 层的知识.</p><h1 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h1><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="https://book.douban.com/subject/6811238/">柯元旦</a></li><li><a href="http://gityuan.com/2015/12/26/handler-message-framework/">gityuan</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Message</tag>
      
      <tag>Handler</tag>
      
      <tag>消息机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Annotation 使用备忘</title>
    <link href="/2016/11/16/annotation/"/>
    <url>/2016/11/16/annotation/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录注解 Annotation 的概念和使用. </p><span id="more"></span><h1 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation 注解"></a>Annotation 注解</h1><h2 id="Why-需要注解"><a href="#Why-需要注解" class="headerlink" title="Why 需要注解"></a>Why 需要注解</h2><p>在代码中常有些重复的代码，这些代码纯手工太耗时。可以通过一定的标记，然后处理即可。</p><h2 id="What-是注解-Annotation-分类"><a href="#What-是注解-Annotation-分类" class="headerlink" title="What 是注解? Annotation 分类"></a>What 是注解? Annotation 分类</h2><ol><li>标准 Annotation<br>包括 Override, Deprecated, SuppressWarnings，是 java 自带的几个注解，他们由编译器来识别，不会进行编译，不影响代码运行。</li><li>元 Annotation<br>@Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。</li><li>自定义 Annotation<br>自定义的 Annotation。</li></ol><h3 id="自定义的注解也分为三类，通过元Annotation-Retention-定义："><a href="#自定义的注解也分为三类，通过元Annotation-Retention-定义：" class="headerlink" title="自定义的注解也分为三类，通过元Annotation - @Retention 定义："></a>自定义的注解也分为三类，通过元Annotation - @Retention 定义：</h3><blockquote><ul><li>@Retention(RetentionPolicy.SOURCE)</li></ul></blockquote><pre><code class="hljs">源码时注解，一般用来作为编译器标记。如 Override, Deprecated, SuppressWarnings。</code></pre><blockquote><ul><li>@Retention(RetentionPolicy.RUNTIME)</li></ul></blockquote><pre><code class="hljs">运行时注解，在运行时通过反射去识别的注解，这种注解最大的缺点就是反射消耗性能。</code></pre><blockquote><ul><li>@Retention(RetentionPolicy.CLASS)</li></ul></blockquote><pre><code class="hljs">编译时注解，在编译时被识别并处理的注解，相当于自动生成代码，没有反射，和正常的手写代码无二。</code></pre><h2 id="Annotation-的工作原理"><a href="#Annotation-的工作原理" class="headerlink" title="Annotation 的工作原理"></a>Annotation 的工作原理</h2><p>APT(Annotation Processing Tool)<br>根据不同类型的注解，采取不同的处理方式，对于 SOURCE 类型的注解，它只会存在代码中，当进行编译成 class 的时候，就会被抛弃了。<br>RUNTIME 类型的则一直存到 class 文件中，一直存在虚拟机的运行期。CLASS 类型的注解只存到编译期，会根据 处理器的要求进行处理，生成代码或者其他处理方式，处理完只会，就不会存在了，而如果生成了文件，则会一直存在，被打包。</p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><ul><li>Element:<br>表示一个程序元素，比如包、类或者方法。每个元素都表示一个静态的语言级构造（不表示虚拟机的运行时构造）。 元素应该使用 equals(Object)方法进行比较。不保证总是使用相同的对象表示某个特定的元素。要实现基于 Element 对象类的操作，可以使用 visitor 或者使用 getKind() 方法的结果。使用 instanceof 确定此建模层次结构中某一对象的有效类未必可靠，因为一个实现可以选择让单个对象实现多个 Element 子接口。</li></ul><p>在 JDK 1.6 新增的 javax.lang.model 包中定义了16类 Element，包括了 Java 代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。</p><ul><li>TypeElement ：<br>TypeElement 表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注释类型是一种接口.<br>TypeElement 代表了一个 class 或者 interface 的 element 。 DeclaredType 表示一个类或接口类型，后者(DeclaredType)将成为前者(TypeElement)的一种使用（或调用）。这种区别对于一般的类型是最明显的，对于这些类型，单个元素可以定义一系列完整的类型。 例如，元素 java.util.Set 对应于参数化类型 java.util.Set<String> 和 java.util.Set<Number>（以及其他许多类型），还对应于原始类型 java.util.Set。</li></ul><h4 id="TypeElement-DeclaredType"><a href="#TypeElement-DeclaredType" class="headerlink" title="TypeElement,DeclaredType"></a>TypeElement,DeclaredType</h4><ul><li><p>为什么需要 <a href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/TypeElement.html">TypeElement</a> 呢？<br>TypeElement 表示一个类或接口程序元素,重点它是一个 element ，是类或者接口的 element。<br>我们知道 element 有多达16种类型，这些 element 形式各异。各有各的特点，TypeElement 表示的是类或者接口，对于类或者接口，他有很多独有的信息，比如全路径名，超类等等，而对于 method 就没有这个，方法也有个特有的 element ExecutableElement，出现的原因就同理可得了。</p></li><li><p>为什么需要 <a href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/DeclaredType.html">DeclaredType</a> 呢？<br>DeclaredType 表示一个类或接口类型，重点它是一个具体的类型。<br>DeclaredType 有个方法，asElement()方法，这个方法返回的是一个 element，通过这个方法我们就可以获取一些作为 element 才能获取的信息。比如 MirroredTypeException  异常会携带回 TypeMirror，可以强制转换成 DeclaredType，就可以获取一些信息。</p></li></ul><p>根据目前已有的数据和自身的理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">TypeMirror typeMirror = element.asType();<br><br>DeclaredType declaredType = (DeclaredType) typeMirror;<br><br>messager.printMessage(Diagnostic.Kind.NOTE, <span class="hljs-string">&quot;Annotation class : typeMirror instanceof DeclaredType = &quot;</span> + (typeMirror <span class="hljs-keyword">instanceof</span> DeclaredType));<br><span class="hljs-comment">// 这里的输出为 true</span><br><br></code></pre></td></tr></table></figure><p>这也就解释了为什么 oracle 文档上说的前者调用后者的意思。</p><h2 id="How-使用，自定义注解"><a href="#How-使用，自定义注解" class="headerlink" title="How 使用，自定义注解"></a>How 使用，自定义注解</h2><p>前提：自定义注解一定要是 Java library，不能用 Android library。<br>IDE： AS 新建一个 Android Project<br>插件：此外我们还需要另外一个库，这个库是为了在 Android 上只用注解而使用的: android-apt。 这个插件可以自动的帮你为生成的代码创建目录, 让生成的代码编译到APK 里面去, 而且它还可以让最终编译出来的APK里面不包含注解处理器本身的代码。</p><ul><li>允许配置只在编译时作为注解处理器的依赖，而不添加到最后的 APK 或 library</li><li>设置源路径，使注解处理器生成的代码能被 Android Studio 正确的引用</li></ul><h3 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h3><p>对于编译时注解，在编译项目之前执行的代码，可以生成代码或者生成其他文件，生成的文件将会被打包进项目，但是之前的注解将会被删除，不会进入 class 文件。</p><h4 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h4><ol><li><p> 新建一个 Java module，设置该 module 的 gradle 文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java&#x27;</span><br>dependencies &#123;<br>    compile fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>&#125;<br>sourceCompatibility = <span class="hljs-string">&quot;1.7&quot;</span><br>targetCompatibility = <span class="hljs-string">&quot;1.7&quot;</span><br></code></pre></td></tr></table></figure><p>同时设置 project 的 gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:2.2.2&#x27;</span><br>        classpath <span class="hljs-string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 新建一个注解 NameGenerate</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NameGenerate &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>接下来就是重点了，需要编写注解的处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameGenerateProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CLASSNAME = <span class="hljs-string">&quot;NameGeneateList&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PACKAGENAME = <span class="hljs-string">&quot;com.lvmama.router&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;<br>        Messager messager = processingEnv.getMessager();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 以新建文件的文件名为参数新建一个 JavaFileObject 对象</span><br>            JavaFileObject f = processingEnv.getFiler().createSourceFile(CLASSNAME);<br>            Writer w = f.openWriter();<br>            PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(w);<br><span class="hljs-comment">// 将新建文件的内容就以拼接的方式输入即可。</span><br>            pw.println(<span class="hljs-string">&quot;package &quot;</span> + PACKAGENAME + <span class="hljs-string">&quot;;&quot;</span>);<br>            pw.println(<span class="hljs-string">&quot;\npublic class &quot;</span> + CLASSNAME + <span class="hljs-string">&quot; &#123; &quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (Element element : env.getElementsAnnotatedWith(NameGenerate.class)) &#123;<br>                PackageElement packageElement = (PackageElement) element.getEnclosingElement();<br>                String packageName = packageElement.getQualifiedName().toString();<br>                TypeElement classElement = (TypeElement) element;<br>                String className = classElement.getSimpleName().toString();<br>                String fullClassName = classElement.getQualifiedName().toString();<br>                pw.print(<span class="hljs-string">&quot;public String &quot;</span> + className + <span class="hljs-string">&quot;=\&quot;&quot;</span> + fullClassName + <span class="hljs-string">&quot;\&quot;;&quot;</span>);<br>            &#125;<br><br>            pw.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>            pw.flush();<br>            pw.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        Set&lt;String&gt; types = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>        types.add(NameGenerate.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> types;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/annotation_tradition_step1.png" alt="传统的结构第一步"><br><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/annotation_tradition_step2.png" alt="传统的结构第二步"></p><h3 id="关键方法-process-解释"><a href="#关键方法-process-解释" class="headerlink" title="关键方法 process 解释"></a>关键方法 process 解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-comment">// annotations 当前注解器需要处理的注解的集合</span><br>    <span class="hljs-comment">// roundEnv 可以用来访问当前的 Round 中的语法树的节点，每个语法树中的节点都表示为一个 element。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>“processingEnv”<br>它是 AbstractProcessor 中的一个 protected 变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了 AbstractProcessor 的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。</p></li><li><p>@SupportedAnnotationTypes 和 @SupportedSourceVersion</p></li></ul><p>前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的 Java 代码。</p><ul><li>方法返回值的含义<br>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为 false 的布尔值，通知编译器这个 Round 中的代码未发生变化，无须构造新的 JavaCompiler 实例。</li></ul><h3 id="对于注解循环引起的错误的解释"><a href="#对于注解循环引起的错误的解释" class="headerlink" title="对于注解循环引起的错误的解释"></a>对于注解循环引起的错误的解释</h3><p>不做任何处理，直接运行上面的程序的话，就会在控制台输出一个错误。</p><ul><li>Attempt to recreate a file for type com.steve.RouterList *<br>此处解释引用自《深入Java虚拟机_JVM高级特性与最佳实践》P307。<br>将插入式注解处理器看做一个插件，如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次的循环称为一个 round。</li></ul><ol start="4"><li><p>注册处理器<br>在 src/main 目录下，新建一个和 Java  文件夹平级的文件夹 “resources”, 在 resources 文件夹下新建 META-INF 文件夹，在 META-INF 文件夹下新建 services 文件夹， 在 services 文件夹下新建 javax.annotation.processing.Processor 文件，文件夹的内容就是刚刚编写的处理的全路径名，例如 com.steve.NameGenerateProcessor</p></li><li><p>使用<br>有两种方式，一是直接在 gradle 中依赖 注解项目。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    compile fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>    compile project(<span class="hljs-string">&#x27;:lib_processor&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>另外一种方式就是直接将注解的项目打出 jar 文件，让 app 依赖这个 jar  文件。</p></li></ol><p>build app 项目，就会生成对应的文件。文件的路径:\app\build\generated\source\apt\debug</p><p>想在代码中使用生成的 java 文件很简单，像正常自己写的文件一样，直接引用即可。</p><h4 id="借助-Google-和-square-的库"><a href="#借助-Google-和-square-的库" class="headerlink" title="借助 Google 和 square 的库"></a>借助 Google 和 square 的库</h4><p>传统的方式，过程比较繁琐，借助 Google  的 auto-service 和 square 的 javapoet 可以省一些事。</p><ul><li>Auto<br>用来注解 Processor 类，生成对应的 META-INF 的配置信息，省去注册处理器这一步，只要在自定义的 Processor 上面加上 @AutoService(Processor.class)</li><li>javapoet<br>只是一个方便生成代码的一个库，比起简单的字符串拼接，这个看上去更加友好。</li></ul><p>总体来说，和传统的方式区别不大，只是修改编写注解的 module 的依赖即可。</p><ol><li>修改 Processor 所在 Java module 的 gradle 依赖。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">apply plugin: <span class="hljs-string">&#x27;java&#x27;</span><br><br>dependencies &#123;<br>    <span class="hljs-function">compile <span class="hljs-title">fileTree</span><span class="hljs-params">(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, include: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])</span></span><br><span class="hljs-function">    compile &#x27;com.google.auto.service:auto-service:1.0-rc2&#x27;</span><br><span class="hljs-function">    compile &#x27;com.squareup:javapoet:1.7.0&#x27;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">sourceCompatibility </span>= <span class="hljs-string">&quot;1.7&quot;</span><br>targetCompatibility = <span class="hljs-string">&quot;1.7&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>借助 javapoet 生成 Java 代码<br>有一点需要说清楚，在 AndroidStudio 中用 javapoet 有问题，并不能完全的支持。<a href="https://github.com/square/javapoet/issues/139">这个 jake 在 github 上有解释</a>。如果想要完整的使用，最好能使用 intellij idea。<br>所以这里我们切换到 intellij idea 去开发。</li></ol><p><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/annotation_error.png" alt="AdnroidStudio上的报错"></p><ol start="3"><li>重点还是在注解处理器的处理<br>需要注意一点的时，即使在注解处理这个看似特别的程序上，依旧是个 Java 程序，也就必然符合面向对象的原则。我将每个注解我需要的信息封装成一个对象，交给一个工具类，由工具类统一完成代码的生成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameGenerateAnnotatedClass</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TypeElement annotatedClassElement;<br>    <span class="hljs-keyword">private</span> String packageName;<br>    <span class="hljs-keyword">private</span> String className;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NameGenerateAnnotatedClass</span><span class="hljs-params">(TypeElement annotatedClassElement)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.annotatedClassElement = annotatedClassElement;<br>        className = annotatedClassElement.getSimpleName().toString();<br>        packageName = annotatedClassElement.getQualifiedName().toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPackageName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> packageName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> className;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>这个类很简单，就单纯的记录了每个被注解元素的类名和包名，因为待会儿我自动生成的代码，我只需要这个两样。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessorUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CLASSNAME = <span class="hljs-string">&quot;RouterList&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PACKAGENAME = <span class="hljs-string">&quot;com.lvmama.router&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProcessorUtil</span><span class="hljs-params">(Messager messager)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.messager = messager;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Messager messager;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;NameGenerateAnnotatedClass&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(Element e, String msg, Object... args)</span> </span>&#123;<br>        messager.printMessage(Diagnostic.Kind.ERROR, String.format(msg, args), e);<br>    &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateCode</span><span class="hljs-params">()</span> </span>&#123;<br>        TypeSpec.Builder builder = TypeSpec.classBuilder(CLASSNAME).addModifiers(Modifier.PUBLIC);<br>        <span class="hljs-keyword">for</span> (NameGenerateAnnotatedClass annotatedClass : list) &#123;<br>            FieldSpec fieldSpec = FieldSpec.builder(String.class, annotatedClass.getClassName())<br>                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)<br>                    .initializer(<span class="hljs-string">&quot;$S&quot;</span>, annotatedClass.getPackageName())<br>                    .build();<br>            builder.addField(fieldSpec);<br>        &#125;<br>        TypeSpec typeSpec = builder.build();<br>        JavaFile.Builder javaFileBuilder = JavaFile.builder(PACKAGENAME, typeSpec);<br>        JavaFile javaFile = javaFileBuilder.build();<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//            javaFile.writeTo(System.out); //输出到控制台</span><br>            javaFile.writeTo(filer); <span class="hljs-comment">//输出到默认的目录</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNameGenerateAnnotatedClass</span><span class="hljs-params">(NameGenerateAnnotatedClass item)</span> </span>&#123;<br>        list.add(item);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        list.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类是负责生成代码的，在获取到每个被注解的元素的时候，都会添加到这个类的 list 中，在 generateCode() 方法中生成的代码。<br>这里用的就是 javapoet 来生成的代码。</p><ul><li>TypeSpec 代表的是一个类。</li><li>FieldSpec 代表了一个类中的字段。</li><li>JavaFile 代表了一个 Java 文件。<br>javaFile.writeTo 就是将我们自身组装的这些元素输出，javaFile.writeTo(System.out); 是输出到控制台。<br>javaFile.writeTo(filer); 输出到默认的目录下。</li></ul><p>和传统方式一样，运行 build 命令，在生成的目录下就可以看到生成的文件。</p><p><img src="https://raw.githubusercontent.com/tinggengyan/tinggengyan.github.io/source/imgur/annotation_withautoservice.png" alt="采用 auto-service和javapoet的结构图"></p><h3 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h3><p>对于运行时注解都是通过反射来实现的。</p><h3 id="源码注解"><a href="#源码注解" class="headerlink" title="源码注解"></a>源码注解</h3>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Annotation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 常用语法</title>
    <link href="/2016/10/17/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2016/10/17/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 Markdown 写作时常用的一些语法.</p><span id="more"></span><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>平时人们都会进行一些简单的笔记记录，这些文字如果用 Word 就会感觉太复杂，用 txt 又显得单薄，一点格式都没有，不利于书写。自然人们希望有一种方法，能消除这两个缺点的方法，既能有常用的格式，又能方便记忆，简单快捷.<br>Markdown 是满足这种需要的，所以记录总结一些常用的 Markdown 符号，方便记忆.</p><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>Markdown 是一种轻量级的「标记语言」，Markdown 简单快捷，导出格式也随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，方便阅读。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="1-标题级别的"><a href="#1-标题级别的" class="headerlink" title="1. 标题级别的"></a>1. 标题级别的</h2><p><strong>语法：</strong></p><blockquote><p># 一级标题<br>  ## 二级标题<br>  ### 三级标题<br>  #### 四级标题<br>  ##### 五级标题<br>  ###### 六级标题</p></blockquote><p>标题的级别根据#的个数来区分。正常的文本内容不需要取管，直接输入即可。</p><p><strong>效果:</strong></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-序列效果"><a href="#2-序列效果" class="headerlink" title="2. 序列效果"></a>2. 序列效果</h2><p><strong>无序序列语法：</strong></p><blockquote></blockquote><p>* 包含的要点<br>* 包含的要点<br>- 包含的要点<br>- 包含的要点</p><p><strong>无序序列效果:</strong></p><ul><li>包含的要点</li><li>包含的要点</li></ul><ul><li>包含的要点</li><li>包含的要点</li></ul><p><strong>有序序列语法：</strong></p><blockquote></blockquote><p>\1. 第一点<br>\2. 第二点<br>\1. 第三点</p><p><strong>无序序列效果:</strong></p><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><p>对于想输入一些知识点的结构的情况，需要以列表的形式展示的时候，可以采用这种标记。可以根据具体的情况才有无序的列表和有序的列表。<br>对于无序的情况，可以输入“-”也可以输入“*”，都可以。对于有序的情况，输入对于的数字加上英文符号的点，加上空格，紧跟文本内容。其中的数字可以随意,解析的时候自动累加哪怕都写的1，根据具体的解析平台可能存在差异，故而最好能按照顺序写这个数字。</p><h2 id="3-强调文字"><a href="#3-强调文字" class="headerlink" title="3. 强调文字"></a>3. 强调文字</h2><p><strong>斜体语法:</strong></p><blockquote></blockquote><p> *斜体文字,加载这两个星花之间都将以斜体的形式展现*</p><p><strong>斜体效果:</strong></p><p><em>斜体文字,加载这两个星花之间都将以斜体的形式展现</em></p><p><strong>加粗语法:</strong></p><blockquote></blockquote><p>*<em>需要加粗的文字写在这里</em>*</p><p><strong>加粗效果:</strong></p><p><strong>需要加粗的文字写在这里</strong></p><p>文本中需要加粗来强调的内容和需要以斜体展示的内容，用星号包裹，区别就是星号的个数。</p><h2 id="4-引用内容"><a href="#4-引用内容" class="headerlink" title="4. 引用内容"></a>4. 引用内容</h2><p><strong>引用语法:</strong></p><blockquote></blockquote><p>&gt; 引用的内容，对于一些需要标注了引用了别人的信息的情况下需要以这种形式展示，可以写在这个大于号的后面即可。</p><p><strong>引用效果:</strong></p><blockquote><p>引用的内容，对于一些需要标注了引用了别人的信息的情况下需要以这种形式展示，可以写在这个大于号的后面即可。</p></blockquote><h2 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5. 超链接"></a>5. 超链接</h2><p><strong>超链接语法:</strong></p><blockquote></blockquote><p>[展示的文本]( <a href="http://www.baidu.com/">www.baidu.com</a> )</p><p><strong>超链接效果:</strong></p><p><a href="www.baidu.com">展示的文本</a></p><p>对于文本需要有超链接的情况下，可以采用这种方式。</p><h2 id="6-引用外部图片"><a href="#6-引用外部图片" class="headerlink" title="6. 引用外部图片"></a>6. 引用外部图片</h2><p><strong>引用外部图片语法:</strong></p><blockquote></blockquote><p>![图片说明展示的文本](<a href="http://pic.lvmama.com/img/v6/lv_jbr.png">http://pic.lvmama.com/img/v6/lv_jbr.png</a>)</p><p><strong>引用外部图片效果:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/706636-d83548cdf2353f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片说明展示的文本"></p><p><strong>引用外部图片外加超链接语法:</strong></p><blockquote></blockquote><p>[![图片说明展示的文本](<a href="http://pic.lvmama.com/img/v6/lv_jbr.png)]/(http://www.lvmama.com)">http://pic.lvmama.com/img/v6/lv_jbr.png)]\(http://www.lvmama.com)</a></p><p><strong>引用外部图片外加超链接效果:</strong><br><a href="http://www.lvmama.com/"><img src="http://upload-images.jianshu.io/upload_images/706636-d83548cdf2353f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片说明展示的文本"></a></p><h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h2><p><strong>分割线语法:</strong></p><blockquote></blockquote><p>\ —-<br>\ ****</p><p>三个横线和三个星号都表示分割线</p><p><strong>分割线效果：</strong></p><p>横线分割线</p><hr><p>星号分割线</p><hr><p>分割线可以用来分割段落和大的模块内容。</p><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h2><p><strong>表格语法：</strong></p><blockquote></blockquote><p>| tab1 | tab2 | tab3 |<br>|-|-|-|<br>|内容1|内容2|内容3|</p><p><strong>表格效果：</strong><br>| tab1 | tab2 | tab3 |<br>|-|-|-|<br>|内容1|内容2|内容3|</p><p>用竖直的线和减号进行标示，就可以插入一个简单的表格。</p><h2 id="9-引入代码块"><a href="#9-引入代码块" class="headerlink" title="9. 引入代码块"></a>9. 引入代码块</h2><p><strong>引入代码的语法：</strong></p><blockquote></blockquote><p>```java<br>public class MainActivity extends Activity{<br>protected void onCreate(Bundle save){<br>}<br>}<br>```</p><p><strong>引入代码的效果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle save)</span></span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对于想输入代码的时候，直接替换上面的java-即可实现代码的高亮。"><a href="#对于想输入代码的时候，直接替换上面的java-即可实现代码的高亮。" class="headerlink" title="对于想输入代码的时候，直接替换上面的java 即可实现代码的高亮。"></a>对于想输入代码的时候，直接替换上面的java 即可实现代码的高亮。</h2>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
      <category>Editor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git实践笔记</title>
    <link href="/2016/10/15/git%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    <url>/2016/10/15/git%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录常用 git 的功能和命令.</p><span id="more"></span><h1 id="Git实践笔记"><a href="#Git实践笔记" class="headerlink" title="Git实践笔记"></a>Git实践笔记</h1><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>一年多前一边工作一边学,做的笔记,后来换了工作,改用SVN,git也就生疏了,最近公司打算换git了,正好重新整理一下笔记.</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>git是目前最好的版本控制工具,是一种动态异步的版本控制工具,对于版本控制的发展历程,可以参考别的文章.目前各个开源管理平台基本上都是用的git,git是必备的技能.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git!大写的牛逼!一个月之内，Linux系统的源码已经由Git管理了!<br>起初的git只能在linux和Unix上运行。</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><ul><li> 在Linux上安装Git</li></ul><p>命令行下输入,<em>sudo apt-get install git</em>,直接安装.</p><ul><li>在Windows上安装<br>从<a href="http://msysgit.github.io/%E4%B8%8B%E8%BD%BD%E3%80%82">http://msysgit.github.io/下载。</a></li></ul><p>在bash下输入以下命令，设置账号和邮箱。是全局的，在之后的所有git操作，都是以这个账号.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span></span><br></code></pre></td></tr></table></figure><p>** 注意：**<br>git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global --list查看当前的所有设置清单列表。</span><br></code></pre></td></tr></table></figure><h2 id="创建版本库（repository）"><a href="#创建版本库（repository）" class="headerlink" title="创建版本库（repository）"></a>创建版本库（repository）</h2><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。<br>一共三步：初始化，添加文件，提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git add readme.txt</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;提交的信息&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="查看仓库的修改状态"><a href="#查看仓库的修改状态" class="headerlink" title="查看仓库的修改状态"></a>查看仓库的修改状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>这个命令会告诉我们修改了哪些文件，在知道了修改的文件之后，通过<br><span class="hljs-meta">$</span><span class="bash"> git diff readme.txt</span><br>这个命令可以查看修改的具体内容。<br></code></pre></td></tr></table></figure><h2 id="版本回退："><a href="#版本回退：" class="headerlink" title="版本回退："></a>版本回退：</h2><p>每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为 <em>commit</em>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git reset --hard HEAD^（表示head指向回退到上一个版本）</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> cat readme.txt</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> git reset --hard 3628164</span><br></code></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向改变了。然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><p>找不到新版本的commit id怎么办？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reflog</span><br></code></pre></td></tr></table></figure><p><strong>总之：</strong><br>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset     –hard commit_id。<br>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><h2 id="工作区和暂存区："><a href="#工作区和暂存区：" class="headerlink" title="工作区和暂存区："></a>工作区和暂存区：</h2><ul><li>工作区：就是在电脑上能看到的目录；一般就是项目文件的根目录；</li><li>版本库：工作区有一个隐藏目录.git文件夹，属于仓库文件，不属于工作区，是Git的版本库；</li></ul><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>把文件往Git版本库里添加的时候，是分两步执行的：</p><ol><li>第一步是用git add把文件从工作区添加到暂存区，实际上就是把文件修改添加到暂存区；</li><li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ol><h3 id="管理修改："><a href="#管理修改：" class="headerlink" title="管理修改："></a>管理修改：</h3><p>工作区的内容，必须add到暂存区以后才会在提交的时候被提交到库里。每次修改，如果不add到暂存区，那就不会加入到commit中</p><h3 id="撤销修改："><a href="#撤销修改：" class="headerlink" title="撤销修改："></a>撤销修改：</h3><p>git checkout – file可以丢弃工作区的修改.把file文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li><li>总之，就是让这个文件回到最近一次<em>git commit</em>或<em>git add</em>时的状态。</li></ul><p>git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区<br>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <em>git checkout – file</em>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <em>git reset HEAD file</em>，就回到了场景1，第二步按场景1操作。</li></ul><h3 id="删除文件："><a href="#删除文件：" class="headerlink" title="删除文件："></a>删除文件：</h3><p>在Git中，删除也是一个修改操作</p><p>直接在文件管理器中把没用的文件删了，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了。</p><ol><li> 用命令git rm删掉，并且git commit，用来从版本库中删除该文件.</li><li> 用命令git checkout – file ，这样实现用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ol><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>生成公私密钥：$ ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#117;&#114;&#101;&#109;&#97;&#105;&#108;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#x79;&#111;&#117;&#114;&#101;&#109;&#97;&#105;&#108;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a>“<br>在用户目录下有.ssh目录，id_rsa和id_rsa.pub这两个文件。<br>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul><li>在github上新建一个仓库。</li><li>GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add origin git@github.com:tinggengyan/study.git</span><br></code></pre></td></tr></table></figure><ul><li>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</li><li>下一步，就可以把本地库的所有内容推送到远程库上： <em>$ git push -u origin master</em>,把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</li><li>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li></ul><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span><br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>要关联一个远程库，使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin git@server-name:path/repo-name.git<br></code></pre></td></tr></table></figure><p>关联后，使用命令<em>git push -u origin master</em>第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令<em>git push origin master</em>推送最新修改；</p><h2 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h2><p>git clone <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:michaelliao/gitskills.git</p><h2 id="分支创建与合并"><a href="#分支创建与合并" class="headerlink" title="分支创建与合并"></a>分支创建与合并</h2><p>Git里，有个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。<br>Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。<br>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。<br>当创建一个新的分支的时候，新分支的指针和旧的指针指向是同一个，同时将head的指向修改到当前的新分支的指针上，之后提交就可以提交到新的分支了。<br>当在新的分支上将工作完成之后，只要合并这两个分支就可以了，简单的就是讲master指向新的分支的指向。然后删除旧的分支的指针即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b dev===&#123;$ git branch dev；$ git checkout dev&#125;创建一个Dev分支并切换到Dev分支。</span><br><span class="hljs-meta">$</span><span class="bash"> git branch查看当前的分支。git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="hljs-meta">$</span><span class="bash"> git merge dev 命令用于将当前的分支和dev分支合并。</span><br></code></pre></td></tr></table></figure><h2 id="变基操作"><a href="#变基操作" class="headerlink" title="变基操作"></a>变基操作</h2><p>对于merge操作，会合并两个分支，并且产生一个新的提交，这对于整体的 log 查看并不美观。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout experiment</span><br><span class="hljs-meta">$</span><span class="bash"> git rebase master</span><br><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge experiment</span><br></code></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近<em>共同祖先</em>，然后对比当前分支相对于该<em>祖先</em>的<em>历次提交</em>，<br>提取相应的修改并存为<em>临时文件</em>，然后将当前分支指向目标基底, 最后以此将之前另存为临时文件的修改依序应用。<br>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁才需要这么做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase --onto master server client</span><br></code></pre></td></tr></table></figure><p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge client</span><br></code></pre></td></tr></table></figure><p>切换到master分支进行合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rebase master server</span><br></code></pre></td></tr></table></figure><p>这样就可以省的切换到sever分支，直接指定rebase。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge server</span><br></code></pre></td></tr></table></figure><p>快速合并。</p><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch <name></li><li>切换分支：git checkout <name></li><li>创建+切换分支：git checkout -b <name></li><li>合并某分支到当前分支：git merge <name></li><li>删除分支：git branch -d <name></li></ul><h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>Git用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>标记出不同分支的内容，通过status命令，找到冲突的内容，手动修改，处理之后，再重新提交.<br>用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --graph --pretty=oneline --abbrev-commit<br></code></pre></td></tr></table></figure><p>命令，查看一下分支合并.</p><p><a href="https://app.yinxiang.com/Home.action#n=f311ba79-a871-47a5-bea1-0fbcb2277ea8&amp;b=403e83c5-7d1d-4991-bc1b-9a6d80235d0b&amp;ses=4&amp;sh=1&amp;sds=5&amp;">https://app.yinxiang.com/Home.action#n=f311ba79-a871-47a5-bea1-0fbcb2277ea8&amp;b=403e83c5-7d1d-4991-bc1b-9a6d80235d0b&amp;ses=4&amp;sh=1&amp;sds=5&amp;</a></p><h2 id="分支管理策略："><a href="#分支管理策略：" class="headerlink" title="分支管理策略："></a>分支管理策略：</h2><p>合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge --no-ff 方式就能实现禁用fast forward模式。<br></code></pre></td></tr></table></figure><p><strong>策略：</strong><br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h3 id="Bug分支："><a href="#Bug分支：" class="headerlink" title="Bug分支："></a>Bug分支：</h3><p>当出现bug的时候需要修复BUG，但是此时的工作区还有文件没有提交，此时的文件又不能提交，此时可以使用git的暂存功能。Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 执行完stash之后的工作区就是一个干净的工作区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash list<br></code></pre></td></tr></table></figure><p>可以查看储藏的内容列表。接着就是恢复储藏的现场。<br>有两个办法：</p><ul><li>一是用<em>git stash apply</em>恢复，但是恢复后，stash内容并不删除，你需要用 <em>git stash drop</em>来删除；</li><li>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</li></ul><p>可以多次stash，恢复的时候，先用 <em>git stash list</em> 查看，然后恢复指定的stash，用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">git stash apply stash@&#123;0&#125;</span><br></code></pre></td></tr></table></figure><h3 id="feature分支："><a href="#feature分支：" class="headerlink" title="feature分支："></a>feature分支：</h3><p>新增一个功能的生活，最好新建一个分支，之后再合并。没有和和分支在删除的时候，git会给出友情提醒，所以删除的时候，需要使用git branch -D <name>强行删除。</p><h3 id="多人协作开发："><a href="#多人协作开发：" class="headerlink" title="多人协作开发："></a>多人协作开发：</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用 <em>git remote</em>；<br>用git remote -v显示更详细的信息；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>origin  git@github.com:michaelliao/learngit.git (fetch)<br>origin  git@github.com:michaelliao/learngit.git (push)<br></code></pre></td></tr></table></figure><p>显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。<br>推送分支</p><ul><li> 推送分支，就是把该分支上的所有本地提交推送到远程库。</li><li> 推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin master 把master分支推送。</span><br><span class="hljs-meta">$</span><span class="bash"> git push origin dev    把dev分支进行推送。</span><br></code></pre></td></tr></table></figure><p>在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>git pull把最新的提交从origin下相应的分支抓下来。<br>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 <em>git branch –set-upstream branch-name origin/branch-name</em>。</li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>查看远程库信息，使用git remote -v；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li><li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li></ul><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>git tag <name>就可以打一个新标签；<br>git tag 查看所有标签；<br>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline --abbrev-commit 找到历史提交的commit id。</span><br><span class="hljs-meta">$</span><span class="bash"> git tag   tagname    commit id来为历史提交打上tag。</span><br>git show &lt;tagname&gt;查看标签信息.<br></code></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v0.1 -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> 3628164</span><br></code></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li><li>git tag -a <tagname> -m “blablabla…”可以指定标签信息；</li><li>git tag -s <tagname> -m “blablabla…”可以用PGP签名标签；</li><li>命令git tag可以查看所有标签。</li></ul><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul><li>命令git push origin <tagname>可以推送一个本地标签；</li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</li><li>先在本地删除一个标签，再命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</li></ul><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</p><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.st status</span><br></code></pre></td></tr></table></figure><p>是在全局，整个电脑上的所有仓库都使用st来表示status。执行 <em>git st</em>=<em>git status</em>.<br>加上*–global*是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br>单个仓库的Git配置文件都放在.git/config文件中。<br>当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。<br>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p><h2 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h2><p>后加.</p><h2 id="感激-非常感激，万分的感激！"><a href="#感激-非常感激，万分的感激！" class="headerlink" title="感激,非常感激，万分的感激！"></a>感激,非常感激，万分的感激！</h2><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="https://git-scm.com/book/zh/v1/">Pro Git</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JsBridge分析</title>
    <link href="/2016/10/13/JsBridge%E5%88%86%E6%9E%90/"/>
    <url>/2016/10/13/JsBridge%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本篇分析大头鬼的 <a href="https://github.com/lzyzsd/JsBridge">JsBridge</a> 库.</p><span id="more"></span><h2 id="js-bridge-分析大头鬼的-JS-库"><a href="#js-bridge-分析大头鬼的-JS-库" class="headerlink" title="js bridge 分析大头鬼的 JS 库"></a>js bridge 分析大头鬼的 JS 库</h2><p>主要的任务都交给了 JS 库去执行，整个框架的主要过程分为三个过程，native 通过发送消息调用 JS 方法，在 JS 层的消息处理,将消息处理完成之后返回。</p><h3 id="Java调用JS-方法"><a href="#Java调用JS-方法" class="headerlink" title="Java调用JS 方法"></a>Java调用JS 方法</h3><p>对于 native 想要调用 JS 代码的时候，会调用自定义的 BridgeWebView 的 send 方法进行发送消息，对于消息，我们可以自定义处理器和回调处理方法，发出去的消息不是立即处理的，而是将其进行封装，成 Message 对象，如果该消息后续有回调，需要记录回调等待后续的处理，而后添加到队列中。进行排队，等待处理。</p><h3 id="Java-消息的分发"><a href="#Java-消息的分发" class="headerlink" title="Java 消息的分发"></a>Java 消息的分发</h3><p>这个消息的分发是指的 native 层面的消息分发，当页面加载 finish 之后，会调用 dispatch 方法对刚刚进入队列中的 Message 对象进行分发。解析出 Message 携带的内容，按照约定，生成对应的 JS 脚本，交由 JS 库处理。</p><h3 id="加载-JS-库"><a href="#加载-JS-库" class="headerlink" title="加载 JS 库"></a>加载 JS 库</h3><p>按照流程的事件顺序上讲，这个过程应该是第一个被执行的，在加载完 HTML 页面的同时需要加载 JS 库，但是 JS 库的加载和页面的加载谁先成功，这个可能出现先后差异，所以需要在 HTML 中判断 JS 库是否加载成功，如果加载成功则进行消息处理；如果加载还未成功，则监听加载 JS 库的事件，等到加载成功之后，再进行消息的处理。这些事件的处理需要在 HTML 中处理.</p><h3 id="JS-库对消息的处理"><a href="#JS-库对消息的处理" class="headerlink" title="JS 库对消息的处理"></a>JS 库对消息的处理</h3><p>这里处理的其实是一个 URL ，在 JS 库层面会调用相应的 JS 方法。当 Java 层调用了消息的分发命令，会通过执行 JS 脚本的方式将消息交给 JS 层，JS 层面会将需要处理的消息，添加到队列中，等待处理，这个过程又有点像 Java 层的处理方式，_handleMessageFromNative ，会将消息存入 receiveMessageQueue 中，等待处理。</p><p>当 JS 库加载成功，需要 HTML 层面可以主动的调用JS层的消息处理的方法 _dispatchMessageFromNative，遍历 receiveMessageQueue，对消息进行处理。</p><p>对于消息的业务处理，都在 JS 层面完成，JS 处理完成之后，如果有需要进行为 Java 层提供返回值的，则进行重定向，通知 Java 层返回值队列中有数据，Java 层拦截 URL 进行主动拉去数据的 JS 脚本执行，JS 层方法将返回值放入 URL 中，进行重定向，Java 层会拦截 url，根据一定的规则，从 url 中截取出数据，数据中携带了唯一的请求 ID，根据这个 ID 查找出对应的回调方法。</p><h3 id="JS-向-native-发送消息"><a href="#JS-向-native-发送消息" class="headerlink" title="JS 向 native 发送消息"></a>JS 向 native 发送消息</h3><p>当 JS 想主动向 native 发送消息的时候，会主动调用 JS 库中的 send 方法，将消息放入 JS 中的 sendMessageQueue 队列中。然后像给 native 层提供返回值一样，进行 url 的重定向,然后依旧是 Java 层拦截 URL,然后主动去拉取数据。</p><h3 id="native-处理-JS-发来的消息"><a href="#native-处理-JS-发来的消息" class="headerlink" title="native 处理 JS 发来的消息"></a>native 处理 JS 发来的消息</h3><p>当 JS 向 native 发出消息,native 收到消息后，解析成 Message 对象，根据 callid 去判断是否有特定的 handler，是否有回调,这些 handler 和 回调都是刚刚封装 Message 对象时保存的。</p><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>对于一般的具体应用，都是 JS 层调用 Java 层提供的方法。这时候，对于平时普通的常规调用，都是需要提前约定的，可以定义在 DefaultHandler 中。也可以根据不同的业务需要定义不同的 BridgeHandler。匿名实现 BridgeHandler 的方式只适合 java 层调用 JS 方法，这种方式不方便维护。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>native 层提供一些基础的方法，类似于分享操作，登录等功能。具体的业务类执行还是交由 JS 层执行，需要 native 协助的功能，以重定向 URL 的方式进行。JS 不直接调用 Java 方法，也就是没有 @JavascriptInterface 注解的方法，所有的约定,包括返回的数据,都在 URL 中。<br>这里会有一个缺点，虽然 http1.1 中声明 url 是没有长度的限制的，但是一般而言，服务端或者浏览器都有有长度的限制，所以，将所有的数据都通过 URL 来传递还是有不妥之处。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JsBridge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习备忘</title>
    <link href="/2016/10/07/Linux%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/"/>
    <url>/2016/10/07/Linux%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录学习 Linux 的记录.</p><span id="more"></span><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="deb-文件安装"><a href="#deb-文件安装" class="headerlink" title="deb 文件安装"></a>deb 文件安装</h3><p>直接双击,安装,ubuntu 上会自动调用软件管理器安装.</p><h3 id="zip文件安装"><a href="#zip文件安装" class="headerlink" title="zip文件安装"></a>zip文件安装</h3><p>这种是包含了源码的,通过命令解压,设置环境变量.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip zipFileName.zip<br></code></pre></td></tr></table></figure><h3 id="tar-gz-源代码安装"><a href="#tar-gz-源代码安装" class="headerlink" title="tar.gz 源代码安装"></a>tar.gz 源代码安装</h3><p>在终端中进行解压操作;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf ****.tar.gz<br>tar -jxvf ****.tar.bz(或bz2) <br></code></pre></td></tr></table></figure><p>看是否需要设置环境变量,亦或是有.sh启动文件.</p><ul><li>设置环境变量的方法</li></ul><p>有三种环境变量的设置方法,一种是临时性的,只在本次的命令行中有效,一种是针对当前用户的,还有一种就是全局性的,针对所有用的.</p><h3 id="rpm-文件安装"><a href="#rpm-文件安装" class="headerlink" title="rpm 文件安装"></a>rpm 文件安装</h3><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li><p>apt-get autoclean:<br>如果你的硬盘空间不大的话，可以定期运行这个程序，将已经删除了的软件包的.deb安装文件从硬盘中删除掉。如果你仍然需要硬盘空间的话，可以试试apt-get clean，这会把你已安装的软件包的安装包也删除掉，当然多数情况下这些包没什么用了，因此这是个为硬盘腾地方的好办法。</p></li><li><p>apt-get clean:<br>类似上面的命令，但它删除包缓存中的所有包。这是个很好的做法，因为多数情况下这些包没有用了。但如果你是拨号上网的话，就得重新考虑了。</p></li><li><p>apt-get autoremove:<br>删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包。</p></li></ul><p>其它：</p><ul><li>apt-get remove 软件包名称：<br>删除已安装的软件包（保留配置文件）。</li><li>apt-get –purge remove 软件包名称：<br>删除已安装包（不保留配置文件)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ComputerFoundation</category>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下SublimeText3中文输入法修复</title>
    <link href="/2016/10/07/Ubuntu%E4%B8%8BSublimeText3%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%BF%AE%E5%A4%8D/"/>
    <url>/2016/10/07/Ubuntu%E4%B8%8BSublimeText3%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录在 ubuntu 如何修复 Sublime Text 不能输入中文的问题.</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在 ubuntu 下安装完 Sublime Text之后,发现不能输入中文,也不能正常的切换成中文输入法.google 了一圈之后,看到网上的解决方案,记录下来,方便日后使用.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-编译一段C代码-保存以下的代码-并将文件命名为-sublime-imfix-c"><a href="#1-编译一段C代码-保存以下的代码-并将文件命名为-sublime-imfix-c" class="headerlink" title="1. 编译一段C代码.保存以下的代码,并将文件命名为 sublime-imfix.c"></a>1. 编译一段C代码.保存以下的代码,并将文件命名为 <code>sublime-imfix.c</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">sublime-imfix.c</span><br><span class="hljs-comment">Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.</span><br><span class="hljs-comment">By Cjacker Huang</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">gcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC</span><br><span class="hljs-comment">LD_PRELOAD=./libsublime-imfix.so subl</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-keyword">typedef</span> GdkSegment GdkRegionBox;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">GdkRegion</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">long</span> size;<br>  <span class="hljs-keyword">long</span> numRects;<br>  GdkRegionBox *rects;<br>  GdkRegionBox extents;<br>&#125;;<br><br>GtkIMContext *local_context;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">gdk_region_get_clipbox</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> GdkRegion *region,</span></span><br><span class="hljs-params"><span class="hljs-function">            GdkRectangle    *rectangle)</span></span><br><span class="hljs-function"></span>&#123;<br>  g_return_if_fail (region != <span class="hljs-literal">NULL</span>);<br>  g_return_if_fail (rectangle != <span class="hljs-literal">NULL</span>);<br><br>  rectangle-&gt;x = region-&gt;extents.x1;<br>  rectangle-&gt;y = region-&gt;extents.y1;<br>  rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1;<br>  rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1;<br>  GdkRectangle rect;<br>  rect.x = rectangle-&gt;x;<br>  rect.y = rectangle-&gt;y;<br>  rect.width = <span class="hljs-number">0</span>;<br>  rect.height = rectangle-&gt;height;<br>  <span class="hljs-comment">//The caret width is 2;</span><br>  <span class="hljs-comment">//Maybe sometimes we will make a mistake, but for most of the time, it should be the caret.</span><br>  <span class="hljs-keyword">if</span>(rectangle-&gt;width == <span class="hljs-number">2</span> &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123;<br>        gtk_im_context_set_cursor_location(local_context, rectangle);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//this is needed, for example, if you input something in file dialog and return back the edit area</span><br><span class="hljs-comment">//context will lost, so here we set it again.</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> GdkFilterReturn <span class="hljs-title">event_filter</span> <span class="hljs-params">(GdkXEvent *xevent, GdkEvent *event, gpointer im_context)</span></span><br><span class="hljs-function"></span>&#123;<br>    XEvent *xev = (XEvent *)xevent;<br>    <span class="hljs-keyword">if</span>(xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123;<br>       GdkWindow * win = g_object_get_data(G_OBJECT(im_context),<span class="hljs-string">&quot;window&quot;</span>);<br>       <span class="hljs-keyword">if</span>(GDK_IS_WINDOW(win))<br>         gtk_im_context_set_client_window(im_context, win);<br>    &#125;<br>    <span class="hljs-keyword">return</span> GDK_FILTER_CONTINUE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gtk_im_context_set_client_window</span> <span class="hljs-params">(GtkIMContext *context,</span></span><br><span class="hljs-params"><span class="hljs-function">          GdkWindow    *window)</span></span><br><span class="hljs-function"></span>&#123;<br>  GtkIMContextClass *klass;<br>  g_return_if_fail (GTK_IS_IM_CONTEXT (context));<br>  klass = GTK_IM_CONTEXT_GET_CLASS (context);<br>  <span class="hljs-keyword">if</span> (klass-&gt;set_client_window)<br>    klass-&gt;set_client_window (context, window);<br><br>  <span class="hljs-keyword">if</span>(!GDK_IS_WINDOW (window))<br>    <span class="hljs-keyword">return</span>;<br>  g_object_set_data(G_OBJECT(context),<span class="hljs-string">&quot;window&quot;</span>,window);<br>  <span class="hljs-keyword">int</span> width = gdk_window_get_width(window);<br>  <span class="hljs-keyword">int</span> height = gdk_window_get_height(window);<br>  <span class="hljs-keyword">if</span>(width != <span class="hljs-number">0</span> &amp;&amp; height !=<span class="hljs-number">0</span>) &#123;<br>    gtk_im_context_focus_in(context);<br>    local_context = context;<br>  &#125;<br>  gdk_window_add_filter (window, event_filter, context);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-因为要编译C代码-所以需要安装C的编译环境"><a href="#2-因为要编译C代码-所以需要安装C的编译环境" class="headerlink" title="2. 因为要编译C代码,所以需要安装C的编译环境"></a>2. 因为要编译C代码,所以需要安装C的编译环境</h2><p>打开命令行,安装编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install build-essential<br>sudo apt-get install libgtk2.0-dev<br></code></pre></td></tr></table></figure><h2 id="3-编译如上说的C代码-会在当前目录下生成libsublime-imfix-so文件-并将libsublime-imfix-so复制到-opt-sublime-text-目录下"><a href="#3-编译如上说的C代码-会在当前目录下生成libsublime-imfix-so文件-并将libsublime-imfix-so复制到-opt-sublime-text-目录下" class="headerlink" title="3. 编译如上说的C代码,会在当前目录下生成libsublime-imfix.so文件,并将libsublime-imfix.so复制到/opt/sublime_text/目录下."></a>3. 编译如上说的C代码,会在当前目录下生成<code>libsublime-imfix.so</code>文件,并将<code>libsublime-imfix.so</code>复制到<code>/opt/sublime_text/</code>目录下.</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC<br></code></pre></td></tr></table></figure><h2 id="4-修改-usr-share-applications-sublime-text-desktop"><a href="#4-修改-usr-share-applications-sublime-text-desktop" class="headerlink" title="4. 修改/usr/share/applications/sublime_text.desktop"></a>4. 修改<code>/usr/share/applications/sublime_text.desktop</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim sublime_text.desktop<br></code></pre></td></tr></table></figure><p>然后修改对应的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>[...]<br>Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F<br>[...]<br><br>[Desktop Action Window]<br>[...]<br>Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n<br>[...]<br><br>[Desktop Action Document]<br>[...]<br>Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file<br>[...]<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.sinosky.org/linux-sublime-text-fcitx.html"> 完美解决 Linux 下 Sublime Text 中文输入 </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>ComputerFoundation</category>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>SublimeText3</tag>
      
      <tag>输入法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidStudio引入AAR依赖</title>
    <link href="/2016/08/10/AndroidStudio%E5%BC%95%E5%85%A5AAR%E4%BE%9D%E8%B5%96/"/>
    <url>/2016/08/10/AndroidStudio%E5%BC%95%E5%85%A5AAR%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文介绍 AndroidStudio 项目如何如何进行 aar 包依赖.</p><span id="more"></span><h1 id="AndroidStudio如何引用aar依赖"><a href="#AndroidStudio如何引用aar依赖" class="headerlink" title="AndroidStudio如何引用aar依赖"></a>AndroidStudio如何引用aar依赖</h1><h2 id="未成功方案"><a href="#未成功方案" class="headerlink" title="未成功方案"></a>未成功方案</h2><p>google 了一圈，网上的方法基本都是以下这种，在 <em>module/build.gradle</em> 文件中添加如下代码.同时将 aar 文件 copy 到 libs 文件夹下.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><br>repositories &#123;<br>    flatDir &#123; dirs <span class="hljs-string">&#x27;libs&#x27;</span> &#125;<br>&#125;<br>compile(<span class="hljs-attr">name:</span><span class="hljs-string">&#x27;aarName&#x27;</span>, <span class="hljs-attr">ext:</span><span class="hljs-string">&#x27;aar&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>我尝试了很多次,没有成功.</p><h2 id="亲测有效方案"><a href="#亲测有效方案" class="headerlink" title="亲测有效方案"></a>亲测有效方案</h2><p>采用了以下方法成功了,和上面的内容一致,只是位置不一样.</p><ol><li><p><strong>project</strong> 目录下新建一个目录 aars(名字应该随意),新建的 aars 文件夹是用来存放需要 aar 包的.</p></li><li><p>在 <strong>project</strong> 下的 build.gradle 中添加代码.</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>    repositories &#123;<br>        jcenter()<br>        <span class="hljs-comment">//为了添加aar依赖</span><br>        flatDir &#123;<br>            dirs <span class="hljs-string">&#x27;../aars&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意: 是在根目录下的 build.gradle 文件中修改,添加的节点是在 <strong>allprojects</strong> 的 <strong>repositories</strong> 下.</p><ol start="3"><li>在需要引用的地方添加引用,格式如下.</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><br>compile(<span class="hljs-attr">name:</span><span class="hljs-string">&#x27;aarNameWithoutExtention&#x27;</span>, <span class="hljs-attr">ext:</span><span class="hljs-string">&#x27;aar&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>添加依赖,依赖的格式是 aar 包文件的名字(不带后缀),ext 注明后缀即可.</p><p>采取如上步骤之后,即可成功添加依赖.</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
      <category>Gradle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDMS_Threads的简单使用</title>
    <link href="/2016/07/20/DDMS-Threads/"/>
    <url>/2016/07/20/DDMS-Threads/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录在 DDMS 如何查看线程的状态,以及状态表达的含义.</p><span id="more"></span><h1 id="使用-DDMS-查看进程中的线程状态"><a href="#使用-DDMS-查看进程中的线程状态" class="headerlink" title="使用 DDMS 查看进程中的线程状态"></a>使用 DDMS 查看进程中的线程状态</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DDMS(Dalvik Debug Monitor Service),是 Android 开发的调试工具。</p><h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><p>在 Android 系统中每个应用都是在单独的一个进程中运行，DDMS 可以将一个进程通过 adb 和 IDE 连接，进行调试。</p><h2 id="面板讲解"><a href="#面板讲解" class="headerlink" title="面板讲解"></a>面板讲解</h2><p><img src="https://github.com/tinggengyan/tinggengyan.github.io/blob/source/imgur/ddms_panel.png?raw=true" alt="DDMS面板"></p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>在左侧选中想要监控的进程，点击上方左起第五个图标(Update Threads) ,在对应的右侧打开 Threads 面板，就可以看到当前进程中的 线程状态。</p><h4 id="字段讲解"><a href="#字段讲解" class="headerlink" title="字段讲解"></a>字段讲解</h4><blockquote><ul><li>ID: 线程ID，是当前进程分配的唯一的线程ID.在 Dalvik 虚拟机中，这些值是从奇数3开始计数。</li><li>Tid: Linux 线程 ID， 对于一个进程的主线程而言，这个 ID 对应了进程 ID 。</li><li>Status: 该线程在进程中的状态，守护进程(Daemon thread)前面被标记了一个星号 ( * ) 。状态可取的值:</li></ul></blockquote><ul><li>running: 正在运行的线程。</li><li>sleeping: 休眠的，等待被唤醒的线程。</li><li>monitor: 监视，正在等待获取一个监控锁。</li><li>wait: 执行了wait方法，释放了对象锁。</li><li>native: 正在执行 native 代码。</li><li>vmwait: 正在等待虚拟机的资源。</li><li>zombie: 僵尸线程，即将销往的进程的线程。</li><li>init : 初始化中的线程(理论上不应该看得到)</li><li>starting : 即将启动的线程(理论上不应该看得到)</li></ul><blockquote><ul><li>utime: 花费在用户代码所花的累计时间，一小会儿(通常是10ms)。只有在linux环境下，才能看到。PS:windows 下。 DDMS 看得到，不知道他这里有啥特别的含义。</li><li>stime : 花费在系统代码上的累计时间，一小会儿(通常是10ms)。</li><li>Name: 线程名。</li></ul></blockquote><p>“ID” 和 “Name”  是在线程启动的时候被设置的。其他的字段是每过一段时间就更新一下(默认是4秒)</p><hr><h3 id="VM-Heap"><a href="#VM-Heap" class="headerlink" title="VM Heap"></a>VM Heap</h3><p>展示一些堆的统计数据，在 gc 的过程中会进程更新。如果选中一个 进程的时候，堆信息视图提示堆更新不可用，点击工具栏左上角的 “Show heap updates” 按钮，再回到 VM 堆视图，点击 “Cause GC” 进行垃圾回收，更新堆统计信息。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.linuxtopia.org/online_books/android/devguide/guide/developing/tools/ddms.html">Using Dalvik Debug Monitor Service (DDMS)</a></p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
      <category>IDE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notification_之利用TaskStackBuilder返回App主页</title>
    <link href="/2016/07/13/Notification-1/"/>
    <url>/2016/07/13/Notification-1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录点击 Notification ,然后停留在 APP 内,而不是返回主页.</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h1><p>一个App会通过通知(Notification)的形式推广自己产品的内容，点击通知，想要看到推送的详情页，点击返回的时候，我们想让用户返回的是App的主页，而不是桌面。这样可以提高转化率等。以前的实现方式是通过重写了每个activity的返回键的响应，现在可以通过TaskStackBuilder 来实现。在网上查看了很多资料，真正正确的倒是没找到。</p><h2 id="TaskStackBuilder-简介"><a href="#TaskStackBuilder-简介" class="headerlink" title="TaskStackBuilder 简介"></a>TaskStackBuilder 简介</h2><p>Utility class for constructing synthetic back stacks for cross-task navigation on Android 3.0 and newer.是一个能够构造返回栈，来实现跨task导航的一个工具类。因为可以构造任务栈，所以，我们可以轻松的实现一个activity返回的上一个任务是什么。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.首先创建一个点击了notification之后跳转到的详情页的intent对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent resultIntent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, ResultActivity.class);<br></code></pre></td></tr></table></figure><p>2.在manifest中声明详情页ResultActivity的栈中前一个activity，声明的这个activity就是详情页点击返回键所要跳转的activity。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> </span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;cn.steve.notification.ResultActivity&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:parentActivityName</span>=<span class="hljs-string">&quot;cn.steve.notification.NotificationHandlerActivity&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.PARENT_ACTIVITY&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;cn.steve.notification.NotificationHandlerActivity&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建一个PendingIntent对象，这个是创建notification的必备。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PendingIntent pendingIntent = TaskStackBuilder.create(<span class="hljs-keyword">this</span>)<br>           .addNextIntentWithParentStack(resultIntent)<br>           .getPendingIntent(<span class="hljs-number">0</span>, PendingIntent.FLAG_UPDATE_CURRENT);<br></code></pre></td></tr></table></figure><ol start="4"><li>剩下的就是正常的启动一个notification了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// new notification</span><br>NotificationCompat.Builder mBuilder = <span class="hljs-keyword">new</span> NotificationCompat.Builder(<span class="hljs-keyword">this</span>);<br>mBuilder.setSmallIcon(android.R.drawable.ic_dialog_email);<br>mBuilder.setContentTitle(<span class="hljs-string">&quot;My Notification!&quot;</span>);<br>mBuilder.setContentText(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>mBuilder.setContentIntent(pendingIntent);<br><br>NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);<br>mNotificationManager.notify(<span class="hljs-number">0</span>, mBuilder.build());<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>实现的要点在于notification的设置。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service之IntentService</title>
    <link href="/2016/07/02/Service%E4%B9%8BIntentService/"/>
    <url>/2016/07/02/Service%E4%B9%8BIntentService/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 IntentService 的使用方式,以及可能产生的问题.</p><span id="more"></span><h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><p>关于IntentService本身的使用很简单，官方的解释也说的很清楚。IntentService是Service类的子类，用来处理异步请求。和正常启动一个Service一样，可以通过startService(Intent)方法启动一个IntentService，同时通过Intent传递数据。IntentService在onCreate()函数中通过HandlerThread开启一个线程来处理Intent请求对象，这样就可以在非主线程执行任务。这里处理消息的时候，也是通过为新创建的线程新建了Handler和Looper对象从消息队列中取出消息进行执行。处理每个Intent所对应的事务都需要调用 onHandleIntent 这个抽象方法。所以，将对不同任务的不同操作通过实现 onHandleIntent 方法就可完成。<br>执行完这个任务(Intent)就会自动停止 Service 。这里有一点需要注意，如果这个任务的执行本身就是异步的，所以，假如添加的任务也是异步的，很难保证能正常执行结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(looper);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            onHandleIntent((Intent)msg.obj);<br>            stopSelf(msg.arg1);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出，每执行一次onHandleIntent 都会调用执行 stopSelf 来停止当前的service。也就是假如子类实现的 onHandleIntent 中执行的是异步任务，异步任务可能得不到预期的结果。</p><p>举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActionBaz</span><span class="hljs-params">(Context context, String param1, String param2)</span> </span>&#123;<br>    Intent intent = <span class="hljs-keyword">new</span> Intent(context, MyIntentService.class);<br>    intent.setAction(ACTION_BAZ);<br>    intent.putExtra(EXTRA_PARAM1, param1);<br>    intent.putExtra(EXTRA_PARAM2, param2);<br>    context.startService(intent);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    Log.d(TAG, <span class="hljs-string">&quot;onDestroy() dead&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">final</span> String action = intent.getAction();<br>      <span class="hljs-keyword">if</span> (ACTION_BAZ.equals(action)) &#123;<br>        <span class="hljs-keyword">final</span> String param1 = intent.getStringExtra(EXTRA_PARAM1);<br>        <span class="hljs-keyword">final</span> String param2 = intent.getStringExtra(EXTRA_PARAM2);<br>        handleActionBaz(param1, param2);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleActionBaz</span><span class="hljs-params">(String param1, String param2)</span> </span>&#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;handleActionBaz() called with: &quot;</span> + <span class="hljs-string">&quot;param1 = [&quot;</span> + param1 + <span class="hljs-string">&quot;], param2 = [&quot;</span> + param2 + <span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//这里的代码是无法执行的。</span><br>          Thread.sleep(<span class="hljs-number">3000</span>);<br>          Log.d(TAG, <span class="hljs-string">&quot;handleActionBaz() called at Thread&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>以上代码中的 Runnable 中的代码是不会执行的。</p><p>看下启动两次 IntentService 的log输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">03.799</span> <span class="hljs-number">4785</span>-<span class="hljs-number">4785</span>/cn.steve.study D/MyIntentService: MyIntentService() called with: cn.steve.service.MyIntentService<span class="hljs-meta">@f26cde3</span><br><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">03.811</span> <span class="hljs-number">4785</span>-<span class="hljs-number">5288</span>/cn.steve.study D/MyIntentService: handleActionBaz() called with: param1 = [], param2 = []<br><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">03.840</span> <span class="hljs-number">4785</span>-<span class="hljs-number">4785</span>/cn.steve.study D/MyIntentService: onDestroy() dead<br><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">04.079</span> <span class="hljs-number">4785</span>-<span class="hljs-number">4785</span>/cn.steve.study D/MyIntentService: MyIntentService() called with: cn.steve.service.MyIntentService@47d6d5e<br><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">04.089</span> <span class="hljs-number">4785</span>-<span class="hljs-number">5293</span>/cn.steve.study D/MyIntentService: handleActionBaz() called with: param1 = [], param2 = []<br><span class="hljs-number">07</span>-<span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">04.114</span> <span class="hljs-number">4785</span>-<span class="hljs-number">4785</span>/cn.steve.study D/MyIntentService: onDestroy() dead<br></code></pre></td></tr></table></figure><p>发现每次都是新建 IntentService 对象，执行完后就会销往。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>系统为我们提供这个 IntentService 能在完成任务后自动停止销往，不需要我们手动停止，但是这个特性只能对一些简单的同步任务而已，对于异步任务，还是需要我们手动去 stop 。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Service</tag>
      
      <tag>IntentService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个例子说明如何使用  RxJava 进行线程切换</title>
    <link href="/2016/06/14/RxJavaThreadDemo/"/>
    <url>/2016/06/14/RxJavaThreadDemo/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文仅作记录如何在上层使用代码进行 RxJava 的线程切换.</p><span id="more"></span><h1 id="RxJava-线程管理"><a href="#RxJava-线程管理" class="headerlink" title="RxJava 线程管理"></a>RxJava 线程管理</h1><p>RxJava 中通过两个关键的方法 subscribeOn 和 observeOn 实现线程的切换，都说 RxJava 是可以任性的随意切换线程，到底可以多任性呢，在哪任性呢，代码上怎么体现呢？下面通过一个非常简单的例子<br>演示一下如何使用，源码讨论请移步另一篇文章。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//验证多线程切换的情况</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multiThreadSwitch</span><span class="hljs-params">()</span> </span>&#123;<br>        Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> String&gt; subscriber)</span> </span>&#123;<br>                <span class="hljs-comment">//受subscribeOn的影响，另起一个线程</span><br>                Log.e(TAG, <span class="hljs-string">&quot;create &quot;</span> + Thread.currentThread().toString());<br>                subscriber.onNext(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;)<br>            .subscribeOn(Schedulers.newThread())<br><br>            .doOnSubscribe(<span class="hljs-keyword">new</span> Action0() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//和上一个doOnSubscribe运行在同一个线程中,因为中间并未切换线程</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;doOnSubscribe4 &quot;</span> + Thread.currentThread().toString());<br>                &#125;<br>            &#125;)<br>            .doOnSubscribe(<span class="hljs-keyword">new</span> Action0() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//受subscribeOn的影响，另起一个线程</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;doOnSubscribe3 &quot;</span> + Thread.currentThread().toString());<br>                &#125;<br>            &#125;)<br>            .subscribeOn(Schedulers.newThread())<br><br>            .map(<span class="hljs-keyword">new</span> Func1&lt;String, String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                    <span class="hljs-comment">//和create在同一个线程执行</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;map1 &quot;</span> + Thread.currentThread().toString());<br>                    <span class="hljs-keyword">return</span> s;<br>                &#125;<br>            &#125;)<br>            .observeOn(Schedulers.newThread())<br><br>            .doOnSubscribe(<span class="hljs-keyword">new</span> Action0() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//受subscribeOn的影响，另起一个线程</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;doOnSubscribe2 &quot;</span> + Thread.currentThread().toString());<br>                &#125;<br>            &#125;)<br>            .map(<span class="hljs-keyword">new</span> Func1&lt;String, String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                    <span class="hljs-comment">//受observeOn的影响，另起一个线程</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;map2 &quot;</span> + Thread.currentThread().toString());<br>                    <span class="hljs-keyword">return</span> s;<br>                &#125;<br>            &#125;)<br>            .subscribeOn(Schedulers.newThread())<br><br>            .doOnSubscribe(<span class="hljs-keyword">new</span> Action0() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//作为消息发送发送的第一站，没有通过subscribeOn指定发送消息的线程，故而这个会在调用subscribe方法的线程上执行,这里是主线程</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;doOnSubscribe1 &quot;</span> + Thread.currentThread().toString());<br>                &#125;<br>            &#125;)<br><br>            .observeOn(Schedulers.newThread())<br>            .subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                    <span class="hljs-comment">// 受observeOn的影响，另起一个线程</span><br>                    <span class="hljs-comment">// 假如没有observeOn，则运行在离这 最近 的observeOn，或者 最远(物理位置最远，按照消息自下往上的顺序，其实也是最近) 的subscribeOn线程上</span><br>                    Log.e(TAG, <span class="hljs-string">&quot;subscribe &quot;</span> + Thread.currentThread().toString());<br>                &#125;<br>            &#125;);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><p>对于直接运行测试代码，产生的log日志是如下的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.315</span> <span class="hljs-number">5471</span>-<span class="hljs-number">5471</span>/ cn.steve.study E/RXJavaActivity: doOnSubscribe1 Thread[main,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.319</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12993</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe2 Thread[RxNewThreadScheduler-<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.323</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12995</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe3 Thread[RxNewThreadScheduler-<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.323</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12995</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe4 Thread[RxNewThreadScheduler-<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.327</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12996</span>/cn.steve.study E/RXJavaActivity: create Thread[RxNewThreadScheduler-<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.327</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12996</span>/cn.steve.study E/RXJavaActivity: map1 Thread[RxNewThreadScheduler-<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.329</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12994</span>/cn.steve.study E/RXJavaActivity: map2 Thread[RxNewThreadScheduler-<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">09.331</span> <span class="hljs-number">5471</span>-<span class="hljs-number">12992</span>/cn.steve.study E/RXJavaActivity: subscribe Thread[RxNewThreadScheduler-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,main]<br><br></code></pre></td></tr></table></figure><p>对于去掉两个observeOn，产生的log日志是如下的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.001</span> <span class="hljs-number">18160</span>-<span class="hljs-number">18160</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe1 Thread[main,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.002</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19180</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe2 Thread[RxNewThreadScheduler-<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.006</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19181</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe3 Thread[RxNewThreadScheduler-<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.006</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19181</span>/cn.steve.study E/RXJavaActivity: doOnSubscribe4 Thread[RxNewThreadScheduler-<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.023</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19182</span>/cn.steve.study E/RXJavaActivity: create Thread[RxNewThreadScheduler-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.024</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19182</span>/cn.steve.study E/RXJavaActivity: map1 Thread[RxNewThreadScheduler-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.024</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19182</span>/cn.steve.study E/RXJavaActivity: map2 Thread[RxNewThreadScheduler-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,main]<br><span class="hljs-number">06</span>-<span class="hljs-number">14</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42.024</span> <span class="hljs-number">18160</span>-<span class="hljs-number">19182</span>/cn.steve.study E/RXJavaActivity: subscribe Thread[RxNewThreadScheduler-<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,main]<br><br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这里约定一下描述的规则，我们接下来讲的远近，上下指的是代码物理位置上。<br>响应式编程有个消息的概念，这里消息的产生是从下往上的，当调用了subscribe 的时候，就会产生，接着往上，我们可以通过代码和log可以看出，依次执行了 doOnSubscribe1 -  doOnSubscribe4，最后到达create处。<br>对于数据流，则是从上往下的，经过每个继承 lift 产生的操作符，例如map, reduce,filter等。</p><h3 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h3><ul><li><p>要想指定create所在的线程，需要在create的下方调用 subscribeOn 方法，他受他下方遇到的第一个 subscribeOn 的影响，反正也可以说subscribeOn影响的是在他上方的消息传递的线程，直到遇到下一个subscribeOn为止。假如全程没有一处调用subscribeOn，则消息的传递是在调用subscribe所在的线程。</p></li><li><p>要想指定 map 等lift操作符和Subscriber中的执行线程，则需要在它上方调用observeOn方法；反之observeOn影响的是他下方的lift操作符直到遇到下一个observeOn位置。假如整个代码中未指明observeOn方法，则运行在整个代码中第一个subscribeOn指定的线程，也可以理解成运行在create所在的线程。</p></li><li><p>至于二者均未指定，则可以推导出运行在调用subscribe所在的线程。</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>至于源码解释参见另外一篇。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Source</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>androidarchitecture</title>
    <link href="/2016/04/08/androidarchitecture/"/>
    <url>/2016/04/08/androidarchitecture/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 Android 官方关于项目架构的文章.</p><span id="more"></span><h1 id="Android-Architecture-Blueprints-beta"><a href="#Android-Architecture-Blueprints-beta" class="headerlink" title="Android Architecture Blueprints [beta]"></a><a href="https://github.com/googlesamples/android-architecture">Android Architecture Blueprints [beta]</a></h1><p>当我们开始明确如何组织和架构一个AndroidApp的时候，Android Framework层提供了很强大的可伸缩性。<br>这份自由虽然很有价值，但是同时也导致一个APP内存在如过重的类，命名体系不一样，架构导致难以测试，维护和扩展苦难等问题。</p><p>Android架构蓝图打算演示解决这类通用问题可能的方法。<br>在这个项目中，我们会提供一个机遇不同架构概念和不同工具的同一个项目实现。</p><p>你可以使用这些例子作为你创建自己的APP的一个参考，或者直接作为一个基础。本篇集中于代码结构，架构，测试和维护性。<br>然而，铭记于心的是，利用这些架构和工具，创建一个APP有很多方式，取决于你的侧重点。所以，这些架构不应该被当做是经典案例。<br>本篇例子中UI刻意保持了简单。</p><h1 id="beat版的意义"><a href="#beat版的意义" class="headerlink" title="beat版的意义"></a>beat版的意义</h1><p>我们一直在做一些可能会影响我们所有例子的决定。所以我们会在发布正式版之前，一直保持初始化的版本号。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>所有的例子都发布在他们对应的分支上。查看对应项目上看的README 以获取详细信息。</p><p>-todo-mvp/- 基本的MVP架构<br>-todo-mvp-loaders/- 基于todo-mvp，使用loaders来获取数据<br>-todo-mvp-databinding/-基于odo-mvp，使用databinding库</p><h2 id="还在进行中的"><a href="#还在进行中的" class="headerlink" title="还在进行中的"></a>还在进行中的</h2><ul><li>todo-mvp-contentproviders - 基于todo-mvp-loaders, 使用Content Providers</li><li>todo-mvp-clean - 基于todo-mvp, 使用Clean Architecture的概念</li><li>todo-mvp-dagger - 基于todo-mvp, 使用Dagger2来进行依赖注入</li></ul><p>此外，还有很多计划中的例子。</p><h1 id="为何是一个待做的项目"><a href="#为何是一个待做的项目" class="headerlink" title="为何是一个待做的项目"></a>为何是一个待做的项目</h1><p>这个APP的目的是能够简单快速的理解，而不是增加演示这个复杂的设计和测试方案的复杂性。<br>可以查看这个APP的规格。</p><p>此外，还有一个类似的JavaScript的项目框架，叫TodoMVC。</p><h1 id="我应该为我的APP选择哪个例子"><a href="#我应该为我的APP选择哪个例子" class="headerlink" title="我应该为我的APP选择哪个例子"></a>我应该为我的APP选择哪个例子</h1><p>每个例子，都有一个选择的尺度，和比较客观的评估，你可以根据你的实际情况选择。</p><p>你可能要考虑到你APP的大小，你整个团队的经验，你预估的维护成本，考虑你是否需要为平板，多平台适配，以及自己的框架偏好。</p><h1 id="TODO-MVP"><a href="#TODO-MVP" class="headerlink" title="TODO-MVP"></a><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/">TODO-MVP</a></h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><p>这个例子是其他变种版本的基础。这个例子展示MVP模式的一个简单的实现，没有参杂其他的架构框架。<br>这个例子，使用手动注入依赖的方式来提供本地和远端的数据。异步的任务是通过callback实现的。</p><p><img src="https://github.com/googlesamples/android-architecture/wiki/images/mvp.png" alt="示例图"></p><p>注意：在MVP的上下文中，属于view是被重新重载了。<br>android.view.View被称作”Android View”,在MVP中接受presenter发送命令的view被简单的称为”view”.</p><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><p>使用fragment有两个理由：<br>activity和fragment进行隔离，非常适合用来实现MVP。</p><ul><li>activity作为一个控制器，用来创建和控制view和presenter。</li><li>可以充分利用fragment框架进行平板和多屏幕适配。</li></ul><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>在这个APP中有四个特点：<br>任务<br>任务详细<br>添加编辑任务<br>数据统计</p><p>每个特点有:</p><ul><li>约定view和presenter的定义</li><li>activity负责产生fragment和presenter</li><li>fragment实现view中的接口</li><li>presenter实现presenter定义的接口</li></ul><p>总之，业务逻辑在presenter中，并且依赖于实现UI工作的view。<br>view层几乎是不包含业务逻辑的，只负责将presenter中的UI指令转换成UI表现，并且监听用户的UI操作，然后传递给presenter层。<br>通过接口来约定view和presenter之间的连接。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>常用的Android官方support包(com.android.support.*)</li><li>Android测试包(Espresso, AndroidJUnitRunner…)</li><li>Mockito</li><li>Guava (null checking)</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="复杂性-这个比较容易理解"><a href="#复杂性-这个比较容易理解" class="headerlink" title="复杂性 - 这个比较容易理解"></a>复杂性 - 这个比较容易理解</h3><h4 id="frameworks-libraries-tools的框架使用"><a href="#frameworks-libraries-tools的框架使用" class="headerlink" title="frameworks/libraries/tools的框架使用"></a>frameworks/libraries/tools的框架使用</h4><p>还没有</p><h4 id="概念复杂性"><a href="#概念复杂性" class="headerlink" title="概念复杂性"></a>概念复杂性</h4><p>这个比较低，作为一个纯MVP实现。</p><h3 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h3><h4 id="Unit-testing"><a href="#Unit-testing" class="headerlink" title="Unit testing"></a>Unit testing</h4><p>高，presenter可以作为仓库和数据源进行单元测试。</p><h4 id="UI-testing"><a href="#UI-testing" class="headerlink" title="UI testing"></a>UI testing</h4><p>高, 注入一个假的的module，允许进行假数据进行测试。</p><h3 id="Code-metrics"><a href="#Code-metrics" class="headerlink" title="Code metrics"></a>Code metrics</h3><p>和传统没有架构的项目相比，<br>这个例子简绍了额外的类和接口:presenter，仓库，接口等等，所以在MVP中无论是代码的行数还是类的数量都比较高。</p><h3 id="维护性"><a href="#维护性" class="headerlink" title="维护性"></a>维护性</h3><h4 id="易于修改和添加新特性"><a href="#易于修改和添加新特性" class="headerlink" title="易于修改和添加新特性"></a>易于修改和添加新特性</h4><p>高。</p><h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h4><p>低。项目特点明确，责任清晰明确。开发人员不需要了解项目中的外部依赖。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava源码解析(一)</title>
    <link href="/2016/03/04/RxJavaEssential1/"/>
    <url>/2016/03/04/RxJavaEssential1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文目的是从源码的角度讲解 Rxjava 的重要概念 Observable.</p><span id="more"></span><h1 id="RxJava要点解析"><a href="#RxJava要点解析" class="headerlink" title="RxJava要点解析"></a>RxJava要点解析</h1><p>对于 Rxjava 还是有很多不理解的地方，加上又有点好奇心，就看看源码，记录在此，水平有限，肯定存在错误的地方，望路过的同行不吝赐教。</p><h2 id="lift变换操作的原理"><a href="#lift变换操作的原理" class="headerlink" title="lift变换操作的原理"></a>lift变换操作的原理</h2><p>看下lift源码,直接拷贝的源码，未做删减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; <span class="hljs-function">Observable&lt;R&gt; <span class="hljs-title">lift</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Operator&lt;? extends R, ? <span class="hljs-keyword">super</span> T&gt; operator)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable&lt;R&gt;(<span class="hljs-keyword">new</span> OnSubscribe&lt;R&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> R&gt; o)</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; st = hook.onLift(operator).call(o);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// new Subscriber created and being subscribed with so &#x27;onStart&#x27; it</span><br>                        st.onStart();<br>                        onSubscribe.call(st);<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                        <span class="hljs-comment">// localized capture of errors rather than it skipping all operators</span><br>                        <span class="hljs-comment">// and ending up in the try/catch of the subscribe method which then</span><br>                        <span class="hljs-comment">// prevents onErrorResumeNext and other similar approaches to error handling</span><br>                        Exceptions.throwIfFatal(e);<br>                        st.onError(e);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                    Exceptions.throwIfFatal(e);<br>                    <span class="hljs-comment">// if the lift function failed all we can do is pass the error to the final Subscriber</span><br>                    <span class="hljs-comment">// as we don&#x27;t have the operator available to us</span><br>                    o.onError(e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p> 为了弄懂，而且变量不多，我们一个变量一个变量的看。</p><ul><li><p>lift内部返回的是一个新建的observable，此时产生了一个新的OnSubscribe，此时的OnSubscribe的call方法内传入的Subscriber<br>变量o就是我们写在代码中的订阅者。</p></li><li><p>hook.onLift(operator).call(o);新建了一个Subscriber变量st，这个变量用的是我们传入的Subscriber变量o。<br>而且还是用的operator创建的，我们先不管如何实现的，待会儿我们看看这个是怎么实现的。</p></li><li><p>onSubscribe.call(st);这个onSubscribe是个final类型，因为目前我们还是处于方法内，所以这个onSubscribe还是源observable<br>的onSubscribe对象(比如我们自己写的发射时机等那段代码),这个时候onSubscribe会调用它的call方法，传入的是我们新建的Subscriber变量st。<br>接下来，新的Subscriber变量st会接收到源observable发送来的数据。我们可以自然得想到，这个新的st肯定会经过operator对象中的一些定义的方法对数据操作后，又发送到了我们传入的Subscriber变量o，实现整体的连接。</p><p>其实说白了，我们其实是在中间创建了一个代理。hook的意思不就是钩子嘛。</p><p>接下来来看刚刚未能解决的疑问，hook是怎么工作的。</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T, R&gt; Operator&lt;? extends R, ? <span class="hljs-keyword">super</span> T&gt; onLift(<span class="hljs-keyword">final</span> Operator&lt;? extends R, ? <span class="hljs-keyword">super</span> T&gt; lift) &#123;<br>       <span class="hljs-keyword">return</span> lift;<br>   &#125;<br></code></pre></td></tr></table></figure><p>  我们看到，并未做任何变化，直接将operator变换直接返回了。</p><p>  接着我们继续看，以filter为例。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Func1&lt;? <span class="hljs-keyword">super</span> T, Boolean&gt; predicate)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lift(<span class="hljs-keyword">new</span> OperatorFilter&lt;T&gt;(predicate));<br>    &#125;<br></code></pre></td></tr></table></figure></p><p> 传入的是一个 OperatorFilter 对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatorFilter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Operator</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Func1&lt;? <span class="hljs-keyword">super</span> T, Boolean&gt; predicate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperatorFilter</span><span class="hljs-params">(Func1&lt;? <span class="hljs-keyword">super</span> T, Boolean&gt; predicate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.predicate = predicate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; call(<span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; child) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Subscriber&lt;T&gt;(child) &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                child.onCompleted();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                child.onError(e);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (predicate.call(t)) &#123;<br>                        child.onNext(t);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// TODO consider a more complicated version that batches these</span><br>                        request(<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                    Exceptions.throwOrReport(e, child, t);<br>                &#125;<br>            &#125;<br><br>        &#125;;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 变量predicate就是我们自己定义的过滤规则，在上面的代码中我们已经看到了，call传入的child就是我们上面分析，我们自己定义的变量o。</p><p> 这下基本清晰了，每次源observable发射的数据都被OperatorFilter内新的subscriber给接收了，然后根据传入到OperatorFilter我们自己定义的过滤规则进行判断，通过的，就给child发射过去，这样实现了过滤的作用，实现了新的subscriber将数据传送到了我们自定义的subscriber。</p><h2 id="Scheduler-线程切换的原理"><a href="#Scheduler-线程切换的原理" class="headerlink" title="Scheduler 线程切换的原理"></a>Scheduler 线程切换的原理</h2><p>注意：以下的版本是rxjava1.1.1(上下两部分的总结时间不一样，也不去考证是哪个版本了)<br>上面说到了变换的时候，用到的线程的切换的问题，那到底是怎么切换的线程呢？<br>说到线程切换，必须说到两个操作。</p><ul><li>subscribeOn：指定observable调用obsubsriber发射数据所在的线程。</li><li>observeOn： 指定订阅者进行订阅处理所在的线程。</li></ul><h3 id="subscribeOn分析"><a href="#subscribeOn分析" class="headerlink" title="subscribeOn分析"></a>subscribeOn分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ScalarSynchronousObservable) &#123;<br>            <span class="hljs-keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="hljs-keyword">this</span>).scalarScheduleOn(scheduler);<br>        &#125;<br>        <span class="hljs-keyword">return</span> create(<span class="hljs-keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是subscribeOn的源码，传入了指定的发送数据所在的线程Scheduler对象。判断当前的observable是否是一个ScalarSynchronousObservable，这个ScalarSynchronousObservable对象就是直接发射传入数据的对象，就是我们平时使用just所产生的对象。</p><ul><li> 如果是，则调用将scheduler传入scalarScheduleOn方法，创建一个新的Observable作为返回值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;T&gt; <span class="hljs-title">scalarScheduleOn</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Func1&lt;Action0, Subscription&gt; onSchedule;<br>        <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> EventLoopsScheduler) &#123;<br>            onSchedule = COMPUTATION_ONSCHEDULE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            onSchedule = <span class="hljs-keyword">new</span> Func1&lt;Action0, Subscription&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Subscription <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Action0 a)</span> </span>&#123;<br>                    <span class="hljs-keyword">final</span> Scheduler.Worker w = scheduler.createWorker();<br>                    w.schedule(<span class="hljs-keyword">new</span> Action0() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                a.call();<br>                            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                w.unsubscribe();<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                    <span class="hljs-keyword">return</span> w;<br>                &#125;<br>            &#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> create(<span class="hljs-keyword">new</span> ScalarAsyncOnSubscribe&lt;T&gt;(t, onSchedule));<br>    &#125;<br></code></pre></td></tr></table></figure>以上是scalarScheduleOn的源码，可以看到内部是通过Func1函数进行转换的，通过传入的scheduler创建指定的线程，在指定的线程上调用Func1中传入进来的Action0。<br>那么Action0代表的又是什么呢？我们看到onSchedule又作为参数去构造ScalarAsyncOnSubscribe了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The OnSubscribe implementation that creates the ScalarAsyncProducer for each</span><br><span class="hljs-comment">     * incoming subscriber.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; the value type</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScalarAsyncOnSubscribe</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">OnSubscribe</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> T value;<br>        <span class="hljs-keyword">final</span> Func1&lt;Action0, Subscription&gt; onSchedule;<br><br>        ScalarAsyncOnSubscribe(T value, Func1&lt;Action0, Subscription&gt; onSchedule) &#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.onSchedule = onSchedule;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; s)</span> </span>&#123;<br>            s.setProducer(<span class="hljs-keyword">new</span> ScalarAsyncProducer&lt;T&gt;(s, value, onSchedule));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据代码注释，知道是为每个传入进来的subscriber创建一个ScalarAsyncProducer。看到这里的call方法，我们可以知道，这个call方法就是被Observable在create中被调用的call方法。在call方法里调用了Subscriber的setProducer方法，给它设置了一个ScalarAsyncProducer对象，这里的Subscriber对象s就是我们自定义的订阅者对象，接下来就看看ScalarAsyncProducer的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Represents a producer which schedules the emission of a scalar value on</span><br><span class="hljs-comment">     * the first positive request via the given scheduler callback.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; the value type</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScalarAsyncProducer</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicBoolean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Producer</span>, <span class="hljs-title">Action0</span> </span>&#123;<br>        <span class="hljs-comment">/** */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2466317989629281651L</span>;<br>        <span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; actual;<br>        <span class="hljs-keyword">final</span> T value;<br>        <span class="hljs-keyword">final</span> Func1&lt;Action0, Subscription&gt; onSchedule;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScalarAsyncProducer</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; actual, T value, Func1&lt;Action0, Subscription&gt; onSchedule)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.actual = actual;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.onSchedule = onSchedule;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0L</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;n &gt;= 0 required but it was &quot;</span> + n);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span> &amp;&amp; compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                actual.add(onSchedule.call(<span class="hljs-keyword">this</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>            Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; a = actual;<br>            <span class="hljs-keyword">if</span> (a.isUnsubscribed()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            T v = value;<br>            <span class="hljs-keyword">try</span> &#123;<br>                a.onNext(v);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                Exceptions.throwOrReport(e, a, v);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (a.isUnsubscribed()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            a.onCompleted();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ScalarAsyncProducer[&quot;</span> + value + <span class="hljs-string">&quot;, &quot;</span> + get() + <span class="hljs-string">&quot;]&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注释上说，这个类是用来代表一个生产者，这个生产者通过给定的线程回调，在第一个激活的请求上发射数据。在具体看代码之前，我们可以根据注释大致猜到这个是充当了发射数据的生产者，并且要是能实现线程切换，应该是在作为构造参数传递进来的onSchedule上进行调用和回调的。看下里面的源码，在request方法中，这里的actual就是刚刚传入的自定义订阅者对象s,我们看到call方法中就是直接调用了actual的onNext方法，将数据传递到订阅者。<br>再看重点，request方法，有个参数n代表一次性请求的数据的数量，actual.add(onSchedule.call(this))；这个命令我们看到有调用onSchedule的call方法，那么经过这么长时间下来，这个call方法又是啥玩意？这个onSchedule就是我们在scalarScheduleOn中定义的Func1，这个也就是说在这里调用了Func1的call方法，传递进去的按理说是Action0对象，我们注意到ScalarAsyncProducer已经实现了Action0接口。也就是说这里调用了ScalarAsyncProducer(生产者)的call方法。当前ScalarAsyncProducer的call方法就是直接调用自定义订阅者的onNext发射数据。我们在上面说了Func1的call方法会在一个新建的线程中调用call方法传递进来的action0对象(就是此处实现Action0接口的ScalarAsyncProducer)的call方法。到目前为止，关于ScalarSynchronousObservable对象的线程切换的原理就分析结束了。</p><ul><li> 接下来看下，如果不是ScalarSynchronousObservable对象调用subscribeOn方法又会是什么逻辑呢？</li></ul><p>再贴下subscribeOn的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ScalarSynchronousObservable) &#123;<br>            <span class="hljs-keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="hljs-keyword">this</span>).scalarScheduleOn(scheduler);<br>        &#125;<br>        <span class="hljs-keyword">return</span> create(<span class="hljs-keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据当前的observable对象和传递进来的scheduler创建了一个OperatorSubscribeOn对象，然后用这个OperatorSubscribeOn对象创建了一个新的Observable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Subscribes Observers on the specified &#123;<span class="hljs-doctag">@code</span> Scheduler&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * &lt;img width=&quot;640&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/subscribeOn.png&quot; alt=&quot;&quot;&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the value type of the actual source</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatorSubscribeOn</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">OnSubscribe</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">final</span> Scheduler scheduler;<br>    <span class="hljs-keyword">final</span> Observable&lt;T&gt; source;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperatorSubscribeOn</span><span class="hljs-params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.scheduler = scheduler;<br>        <span class="hljs-keyword">this</span>.source = source;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; subscriber)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Worker inner = scheduler.createWorker();<br>        subscriber.add(inner);<br><br>        inner.schedule(<span class="hljs-keyword">new</span> Action0() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">final</span> Thread t = Thread.currentThread();<br><br>                Subscriber&lt;T&gt; s = <span class="hljs-keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>                        subscriber.onNext(t);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            subscriber.onError(e);<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            inner.unsubscribe();<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            subscriber.onCompleted();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            inner.unsubscribe();<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProducer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Producer p)</span> </span>&#123;<br>                        subscriber.setProducer(<span class="hljs-keyword">new</span> Producer() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>                                <span class="hljs-keyword">if</span> (t == Thread.currentThread()) &#123;<br>                                    p.request(n);<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    inner.schedule(<span class="hljs-keyword">new</span> Action0() &#123;<br>                                        <span class="hljs-meta">@Override</span><br>                                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                                            p.request(n);<br>                                        &#125;<br>                                    &#125;);<br>                                &#125;<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;;<br><br>                source.unsafeSubscribe(s);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注释直接表明，这个类是用来在指定的线程上订阅subscriber。最主要的方法是call方法，在这个方法里，创建了一个Worker对象，Worker对象调用schedule方法传入一个Action0,在这里Action0的call方法被调用的时候，首先记录当前调用Action0的call方法的线程。在内部用传入的原始subscriber创建一个新的Subscriber对象s(两个subscriber了),在这个s的内部又进行原始subscriber的onNext方法调用发射数据，又覆写了新的subscriber对象的setProducer方法，在覆写的时候对原始的subscriber对象设置一个新的Producer(两个Producer)，在这个新的生产者的request方法中，会判断当前的线程会否就是scheduler指定的线程(刚刚在Action0的call方法中记录了)，如果是，则立即执行；否则将交给scheduler对象指定的Worker对象重新安排这个任务，直到线程一致为止才执行。最后让执行subscribeOn产生的新的observable去订阅这个新产生的subscriber即可。</p><h4 id="subscribeOn总结："><a href="#subscribeOn总结：" class="headerlink" title="subscribeOn总结："></a>subscribeOn总结：</h4><p>线程的切换是由Scheduler对象中的Worker对象负责安排这些任务，不同类型的Scheduler创建出对应的Worker对象，在Worker对象内部会在相应的线程上创建新的Subscriber，通过给新的subscriber设置Producer，通过新的Producer在指定的线程上请求数据，代理了实现发射线程的切换。</p><h3 id="observeOn分析"><a href="#observeOn分析" class="headerlink" title="observeOn分析"></a>observeOn分析</h3><p>接下来分析observeOn,了解在异步线程上分发事件就可以知道线程切换的大致原理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ScalarSynchronousObservable) &#123;<br>            <span class="hljs-keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="hljs-keyword">this</span>).scalarScheduleOn(scheduler);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lift(<span class="hljs-keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, <span class="hljs-keyword">false</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到假如是 ScalarSynchronousObservable 实例的话，操作和 subscribeOn 是一样的。直接看看第二种不是 ScalarSynchronousObservable 的情况。<br>我们看到使用的是 lift 操作符，Operator 的构造方式和上面的 filter 有点不一样，传入了 scheduler 和一个 false 。看下这个 OperatorObserveOn 的代码。按照刚刚 lift 操作的原理，操作符中的 call 方法是关键，是会被代理调用的。这边的代码太长，贴关键部分的代码，上面的都是全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; call(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; child) &#123;<br>        <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> ImmediateScheduler) &#123;<br>            <span class="hljs-comment">// avoid overhead, execute directly</span><br>            <span class="hljs-keyword">return</span> child;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> TrampolineScheduler) &#123;<br>            <span class="hljs-comment">// avoid overhead, execute directly</span><br>            <span class="hljs-keyword">return</span> child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ObserveOnSubscriber&lt;T&gt; parent = <span class="hljs-keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError);<br>            parent.init();<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据上面的经验，这里的返回的 Subscriber 的将会在 lift 新创建的 observable 中的 OnSubscribe 对象的 call 方法中被原始自定义的 OnSubscribe 当做参数传递给它自身的 call 方法中，这里有点乱，但是是和上面的 lift 是一样的，可以回到上面看看 lift 的分析。所以数据会先通过这里创建的 ObserveOnSubscriber ，也就是这里返回的 child 或者 parent。child 的应该比较简单，是直接返回自定义的  Subscriber，这样在 lift 中的情况也一样，其实是直接发给了原始的 observable，相当于没做任何的线程变换。<br>那么重点就是在 ObserveOnSubscriber 上了，这个应该是在做线程的切换了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// don&#x27;t want this code in the constructor because `this` can escape through the </span><br>    <span class="hljs-comment">// setProducer call</span><br>    Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; localChild = child;<br>    <br>    localChild.setProducer(<span class="hljs-keyword">new</span> Producer() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0L</span>) &#123;<br>                BackpressureUtils.getAndAddRequest(requested, n);<br>                schedule();<br>            &#125;<br>        &#125;<br><br>    &#125;);<br>    localChild.add(recursiveScheduler);<br>    localChild.add(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isUnsubscribed() || finished) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!queue.offer(on.next(t))) &#123;<br>        onError(<span class="hljs-keyword">new</span> MissingBackpressureException());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    schedule();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面看到，在创建 parent的时候，会调用 init 方法，在 init 方法中为 child (自定义的 subscriber )设置了 Producer，在 request 里调用了 schedule 方法，<br>schedule 方法就是执行在指定的异步线程上的。我们看到在 onNext 方法中，又调用了 schedule 方法，这样就实现了循环分发的效果，直到把所有的数据分发完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (counter.getAndIncrement() == <span class="hljs-number">0</span>) &#123;<br>                recursiveScheduler.schedule(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>schedule方法里是将当前的对象加入到任务安排中，我们知道schedule方法的参数是一个Action0对象，所以需要看下当前对象实现Action0接口中的call方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">long</span> emitted = <span class="hljs-number">0L</span>;<br><br>            <span class="hljs-keyword">long</span> missed = <span class="hljs-number">1L</span>;<br><br>            <span class="hljs-comment">// these are accessed in a tight loop around atomics so</span><br>            <span class="hljs-comment">// loading them into local variables avoids the mandatory re-reading</span><br>            <span class="hljs-comment">// of the constant fields</span><br>            <span class="hljs-keyword">final</span> Queue&lt;Object&gt; q = <span class="hljs-keyword">this</span>.queue;<br>            <span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; localChild = <span class="hljs-keyword">this</span>.child;<br>            <span class="hljs-keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="hljs-keyword">this</span>.on;<br>            <br>            <span class="hljs-comment">// requested and counter are not included to avoid JIT issues with register spilling</span><br>            <span class="hljs-comment">// and their access is is amortized because they are part of the outer loop which runs</span><br>            <span class="hljs-comment">// less frequently (usually after each RxRingBuffer.SIZE elements)</span><br>            <br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">long</span> requestAmount = requested.get();<br>                <span class="hljs-keyword">boolean</span> unbounded = requestAmount == Long.MAX_VALUE;<br>                <span class="hljs-keyword">long</span> currentEmission = <span class="hljs-number">0L</span>;<br>                <br>                <span class="hljs-keyword">while</span> (requestAmount != <span class="hljs-number">0L</span>) &#123;<br>                    <span class="hljs-keyword">boolean</span> done = finished;<br>                    Object v = q.poll();<br>                    <span class="hljs-keyword">boolean</span> empty = v == <span class="hljs-keyword">null</span>;<br>                    <br>                    <span class="hljs-keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <br>                    <span class="hljs-keyword">if</span> (empty) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <br>                    localChild.onNext(localOn.getValue(v));<br>                    <br>                    requestAmount--;<br>                    currentEmission--;<br>                    emitted++;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (currentEmission != <span class="hljs-number">0L</span> &amp;&amp; !unbounded) &#123;<br>                    requested.addAndGet(currentEmission);<br>                &#125;<br>                <br>                missed = counter.addAndGet(-missed);<br>                <span class="hljs-keyword">if</span> (missed == <span class="hljs-number">0L</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (emitted != <span class="hljs-number">0L</span>) &#123;<br>                request(emitted);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>可以看到上面其实和 Android 本身的 looper 一样，也是一个循环发射的一个过程，checkTerminated 根据当前发射的完成状况和 subscriber 的订阅状态判断是否需要停止。不去过多的理解这个，看重点for循环。<br>在 for 循环里还有一个 while 循环，在 while 中给 Subscriber 对象发射数据。这样就是在 recursiveScheduler 中新的线程中发射的数据。这样就实现了 observeOn 中的线程切换。</p><h4 id="observeOn总结"><a href="#observeOn总结" class="headerlink" title="observeOn总结"></a>observeOn总结</h4><p>observeOn 的线程切换也是通过给自定义的 Subscriber 设置新的 Producer，在新的 Producer中 指定分发(subscriber.onNext())调用的线程,这样就实现了 observeOn 线程的切换。</p><h3 id="subscribe分析"><a href="#subscribe分析" class="headerlink" title="subscribe分析"></a>subscribe分析</h3><p>再看看订阅的执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Subscription <span class="hljs-title">subscribe</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; subscriber)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Observable.subscribe(subscriber, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Subscription <span class="hljs-title">subscribe</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;<br>     <span class="hljs-comment">// validate and proceed</span><br>        <span class="hljs-keyword">if</span> (subscriber == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;observer can not be null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (observable.onSubscribe == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;onSubscribe function can not be null.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// new Subscriber so onStart it</span><br>        subscriber.onStart();<br>        <span class="hljs-comment">// if not already wrapped</span><br>        <span class="hljs-keyword">if</span> (!(subscriber <span class="hljs-keyword">instanceof</span> SafeSubscriber)) &#123;<br>            <span class="hljs-comment">// assign to `observer` so we return the protected version</span><br>            subscriber = <span class="hljs-keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);<br>        &#125;<br>        <span class="hljs-comment">// The code below is exactly the same an unsafeSubscribe but not used because it would </span><br>        <span class="hljs-comment">// add a significant depth to already huge call stacks.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// allow the hook to intercept and/or decorate</span><br>            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);<br>            <span class="hljs-keyword">return</span> hook.onSubscribeReturn(subscriber);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-comment">// special handling for certain Throwable/Error/Exception types</span><br>            Exceptions.throwIfFatal(e);<br>            <span class="hljs-comment">// if an unhandled error occurs executing the onSubscribe we will propagate it</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                subscriber.onError(hook.onSubscribeError(e));<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;<br>                Exceptions.throwIfFatal(e2);<br>                <span class="hljs-comment">// if this happens it means the onError itself failed (perhaps an invalid function implementation)</span><br>                <span class="hljs-comment">// so we are unable to propagate the error correctly and will just throw</span><br>                RuntimeException r = <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Error occurred attempting to subscribe [&quot;</span> + e.getMessage() + <span class="hljs-string">&quot;] and then again while trying to pass to onError.&quot;</span>, e2);<br>                <span class="hljs-comment">// TODO could the hook be the cause of the error in the on error handling.</span><br>                hook.onSubscribeError(r);<br>                <span class="hljs-comment">// TODO why aren&#x27;t we throwing the hook&#x27;s return value.</span><br>                <span class="hljs-keyword">throw</span> r;<br>            &#125;<br>            <span class="hljs-keyword">return</span> Subscriptions.unsubscribed();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们看到hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);这就是所谓的只要在订阅的时候才会发射数据的原因。 subscriber 作为参数传递到调用 subscribe 方法的 observable 中 onSubscribe 的 call 方法了。也就是说最终的subscriber是被传递给了最后一个调用它的 observable 了，因为我们知道在整个操作链中，每个操作符都会返回一个新的 observable ，并且内部都是创建了一个新的 subscriber ，利用代理的方式调用我们自定义的 subscriber。</p><h3 id="实例讲解流程"><a href="#实例讲解流程" class="headerlink" title="实例讲解流程"></a>实例讲解流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Observable:&quot;</span> + Thread.currentThread());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          subscriber.onNext(i);<br>        &#125;<br>        subscriber.onCompleted();<br>      &#125;<br>    &#125;)<br>        <span class="hljs-comment">//  决定了最终在哪个线程调用OnSubscribe的call方法，这会让源observable订阅subscribeOn内新创建的subscriber,</span><br>        <span class="hljs-comment">//  内部新的subscriber会在指定的IO线程上执行。</span><br>        .subscribeOn(Schedulers.io())<br>            <span class="hljs-comment">// filter会返回一个 observable，这个observable会订阅后面的subscriber，接收到之后交给Operator，Operator调用Func1操作完之后再交给调用这个filter</span><br>            <span class="hljs-comment">// 的observable中的OnSubscribe调用，运行在调用这个filter的observable的call方法运行的线程上。</span><br>        .filter(<span class="hljs-keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(Integer integer)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;filter:&quot;</span> + Thread.currentThread());<br>            <span class="hljs-keyword">if</span> (integer &gt; <span class="hljs-number">2</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>          &#125;<br>        &#125;)<br><br>        <span class="hljs-comment">// 指定subscriber中的call方法运行的线程，内部也是通过lift操作实现的，也新建了一个subscriber，</span><br>            <span class="hljs-comment">// 这个新的subscriber为后面订阅的subscriber设置了新producer，</span><br>            <span class="hljs-comment">// 新的producer指定了后面订阅的subscriber的分发数据的线程，也就是订阅的subscriber调用onNext的线程。</span><br>        .observeOn(AndroidSchedulers.mainThread())<br>            <span class="hljs-comment">//订阅，直接运行，分发数据</span><br>        .subscribe(<span class="hljs-keyword">new</span> Action1&lt;Integer&gt;() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Integer integer)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Action1:&quot;</span> + Thread.currentThread());<br>            textViewMain.setText(integer.toString());<br>          &#125;<br>        &#125;);<br><br>  &#125;<br></code></pre></td></tr></table></figure><p>具体的解释就在上面的注释部分了，暂时rxjava部分的解析先暂停，以上的内容，还有许多待斟酌的，遇到错误，看到的希望指教。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxAndroid入门分享(二)</title>
    <link href="/2016/02/26/RxAndroidIntroduction2/"/>
    <url>/2016/02/26/RxAndroidIntroduction2/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 RxJava 中在 Android 中的应用,介绍 RxAndroid 的使用.</p><span id="more"></span><h1 id="More-RxJava-及其在Android上的应用"><a href="#More-RxJava-及其在Android上的应用" class="headerlink" title="More RxJava 及其在Android上的应用"></a>More RxJava 及其在Android上的应用</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>在 module 的 gradle 中添加 RxAndroid 的相关依赖，如果想体验 rx 在 Android 上的更方便的功能。可以添加 Jake 大神的兼容包 RxBinding。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//RXAndroid</span><br>compile <span class="hljs-string">&#x27;io.reactivex:rxandroid:1.1.0&#x27;</span><br><span class="hljs-comment">//RxBinding</span><br>compile <span class="hljs-string">&#x27;com.jakewharton.rxbinding:rxbinding:0.3.0&#x27;</span><br>compile <span class="hljs-string">&#x27;com.jakewharton.rxbinding:rxbinding-support-v4:0.3.0&#x27;</span><br>compile <span class="hljs-string">&#x27;com.jakewharton.rxbinding:rxbinding-appcompat-v7:0.3.0&#x27;</span><br>compile <span class="hljs-string">&#x27;com.jakewharton.rxbinding:rxbinding-design:0.3.0&#x27;</span><br>compile <span class="hljs-string">&#x27;com.jakewharton.rxbinding:rxbinding-recyclerview-v7:0.3.0&#x27;</span><br><span class="hljs-comment">//compile &#x27;com.jakewharton.rxbinding:rxbinding-leanback-v17:0.3.0&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="以下开始用一个demo来演示"><a href="#以下开始用一个demo来演示" class="headerlink" title="以下开始用一个demo来演示"></a>以下开始用一个demo来演示</h2><p>目的地有三个 tab，每个 tab 内的详情用 RecyclerView 展示，下拉刷新用 SwipeRefreshLayout。<br>布局界面如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.widget.SwipeRefreshLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/destinationSwipeRefreshLayout&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.RecyclerView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/destinationRecyclerView&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:clipToPadding</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.RecyclerView</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>开始 RxAndroid 的编写，我们开始考虑在目的地页面需要有的步骤</p><ul><li>网络请求数据(放在 IO 线程)；</li><li>填充网络请求返回的数据到页面(UI 线程展示)；<br>RxAndroid 是基于响应式的编程，我们考虑将以上的网络请求产生的结果作为一个事件，他产生的数据就可以定义为数据流了。</li></ul><h3 id="Observable-amp-amp-create"><a href="#Observable-amp-amp-create" class="headerlink" title="Observable&amp;&amp;create"></a>Observable&amp;&amp;create</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//网络请求，从头开始，自定义创建一个数据流。自主决定数据流的发射时机。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Observable&lt;DestinationDataModel&gt; <span class="hljs-title">getDestinationDataObservable</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String url)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;DestinationDataModel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> DestinationDataModel&gt; subscriber)</span> </span>&#123;<br>                Gson gson = <span class="hljs-keyword">new</span> Gson();<br>                Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).build();<br>                Response response = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    response = client.newCall(request).execute();<br>                    DestinationDataModel destinationDataModel = gson.fromJson(response.body().string(), DestinationDataModel.class);<br>                    <span class="hljs-keyword">if</span> (subscriber.isUnsubscribed())&#123;<span class="hljs-comment">//判断连接是否断开，避免无谓的操作</span><br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    subscriber.onNext(destinationDataModel);<br>                    <span class="hljs-keyword">if</span> (!subscriber.isUnsubscribed())&#123;<br>                        subscriber.onCompleted();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里我们定义了一个方法，这个方法返回一个 Observable，里面封装了数据流,其实不是很计较的情况下，我们先将 Observable 事件等价(自我的理解，未在官方文档找到合适的解释，如有找到望不吝赐教)，事件对外以数据流的形式展现，这个事件就是在发射数据，然后发射结束就通知，失败了也通知。此处我们用到了操作符 create，一种创建操作符，这种操作的扩展性极大，但是我们也需要自己负责发射数据。全程的执行规范都在你的手里。<br>这里可能会有误区，数据流，不一定是多个，非要像 list，数组似的，那种有多个值，像弹珠似的连续发射。像上面的代码，我们只是发射了一个 destinationDataModel 对象，这个也是数据流，即，你发射出去的就是数据流的子集。</p><p>现在，我们有数据流了，就需要在某个适当的地方进行响应。我们思考，需要响应什么？对一个事件可能存在三种情况，事件对应的数据发射失败了( onError )，发射成功了( onCompleted ),还有接收到了发射来的数据( onNext )。<br>有点需要注意，这里的失败，以及成功，这两个回调，只是一个通知而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">  Subscriber&lt;DestinationDataModel&gt; subscriber = <span class="hljs-keyword">new</span> Subscriber&lt;DestinationDataModel&gt;() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStart();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>    Toast.makeText(getActivity(), <span class="hljs-string">&quot;onCompleted&quot;</span>, Toast.LENGTH_SHORT).show();<br>    destinationSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>    e.printStackTrace();<br>    destinationSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(DestinationDataModel destinationDataModel)</span> </span>&#123;<br>    destinationRecyclerView.setAdapter(<span class="hljs-keyword">new</span> DestinationRecyclerAdapter(getActivity(), destinationDataModel.getDatas()));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们定义了一个 Subscriber 对象，在上篇中讲到了什么是 Subscriber。这个是对数据流发射的相应，差不多对应了观察者模式中的观察者。当得到失败和成功的通知的时候，我们这里进行 log 的输出并且显示刷新的图标。当接收到数据的时候，我们就创建 recyclerview 的 adapter，进行列表的填充显示。</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>一旦我们订阅，就会执行数据的发射，默认的情况下，没有订阅操作，数据是不会被发射的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservable(url).subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>以上的操作就会完成订阅，正常的数据产生，发射，相应都会发生。但是，真当我们允许的时候，就会报错，原因是我们都知道，对 UI 的操作都必须在 UI 主线程中。</p><h3 id="subscribeOn-amp-amp-observeOn"><a href="#subscribeOn-amp-amp-observeOn" class="headerlink" title="subscribeOn &amp;&amp; observeOn"></a>subscribeOn &amp;&amp; observeOn</h3><p>指定数据产生发射的线程和订阅响应的线程。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservable(url).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);<br></code></pre></td></tr></table></figure><br> subscribeOn 表示 Observable 执行所在的线程，这里指的是网络请求，请求的数据进行 gson 解析，再将数据发射的线程。<br> observeOn 表示的订阅响应的线程，这里指的是填充发射过来的数据到列表中。<br> 运行就能看到我们想要的效果。到此我们学会了最基本的一些使用，基本上掌握了这几个就可以轻松地展开工作了。当然还有很多其他的技巧。</p><h3 id="From-amp-amp-Just"><a href="#From-amp-amp-Just" class="headerlink" title="From &amp;&amp; Just"></a>From &amp;&amp; Just</h3><p>我们刚刚有说过，数据流不一定是连续的，那么肯定存在连续的，连续不断的弹射，更符合官方文档那种弹珠示意图。from 就是一个这样的操作符。<br>这个目前未想到在当前这个模块的应用场景。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>这个是重复，我们让当前的列表中的数据重复发送两次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservableByCreate(url).repeat(<span class="hljs-number">2</span>)<br>            .subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>修改下subscriber</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(DestinationDataModel destinationDataModel)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (destinationRecyclerView.getAdapter() == <span class="hljs-keyword">null</span>) &#123;<br>                    DestinationRecyclerAdapter adapter = <span class="hljs-keyword">new</span> DestinationRecyclerAdapter(getActivity(), destinationDataModel.getDatas());<br>                    destinationRecyclerView.setAdapter(adapter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    DestinationRecyclerAdapter adapter = (DestinationRecyclerAdapter) destinationRecyclerView.getAdapter();<br>                    adapter.datas.get(<span class="hljs-number">0</span>).getInfos().addAll(destinationDataModel.getDatas().get(<span class="hljs-number">0</span>).getInfos());<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><p>上面的结果是，请求两次网络。我们会看到数据重复了，同样的数据被发送了两次，并且是从头到尾的重复了两次。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>延迟操作，等到订阅的时候再准备数据流。这里尤其对 just 和 from 操作符的效果最为明显,以下是国外的一个 just 的例子说明，from 的原理一样。<br><a href="http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/">借用一个国外的例子</a><br><a href="http://www.jianshu.com/p/c83996149f5b">国内的翻译</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeType</span> </span>&#123;<br><span class="hljs-keyword">private</span> String value;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.value = value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;String&gt; <span class="hljs-title">valueObservable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Observable.just(value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于以下代码的调用会出现怎么样的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SomeType instance = <span class="hljs-keyword">new</span> SomeType();  <br>Observable&lt;String&gt; value = instance.valueObservable();  <br>instance.setValue(<span class="hljs-string">&quot;Some Value&quot;</span>);  <br>value.subscribe(System.out::println); <span class="hljs-comment">//订阅的时候发射数据</span><br></code></pre></td></tr></table></figure><p>如果你认为会打印出 “Some Value”，那就错了。而实际打印结果是 “null”。因为在调用 Observable.just() 的时候，value 已经初始化了。<br>just()，from() 这类能够创建 Observable 的操作符（译者注：创建 Observable 的操作符）在创建之初，就已经存储了对象的值，而不被订阅的时候。订阅的时候只是发射数据。<br>这种情况，显然不是预期表现，我想要的 valueObservable() 是无论什么时候请求，都能够表现为当前值。所以我们需要延迟数据的创建直到有人订阅。有两个方法，一个是用 create 自主创建，我们可以自己精确的控制发射什么，什么时候发射，还有一个是用的 defer 延迟操作符。defer() 中的代码直到被订阅才会执行。我们只需要在请求数据的时候调用 Observable.just() 就行了，使用 defer() 操作符的唯一缺点就是，每次订阅都会创建一个新的 Observable 对象。create() 操作符则为每一个订阅者都使用同一个函数，所以，后者效率更高。</p><p>因为我学习的时候，难以想清楚延迟和 create 操作符中的 call 的时间顺序和区别，我们用另外一个例子解释一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Observable&lt;Integer&gt; <span class="hljs-title">getInt</span><span class="hljs-params">()</span> </span>&#123;<br><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd_HHmmss&quot;</span>);<br>        String currentDateandTime = sdf.format(<span class="hljs-keyword">new</span> Date());<br>        Log.e(<span class="hljs-string">&quot;GetInt&quot;</span>, currentDateandTime);<br><br>        <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (subscriber.isUnsubscribed()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                subscriber.onNext(<span class="hljs-number">42</span>);<br>                subscriber.onCompleted();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//simple defer</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleDefer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//defer中的getInt操作等到有人订阅deferObservable的时候才会被执行</span><br>        <span class="hljs-comment">//假如这里不用defer，直接用getInt返回，那么调用simpleDefer的时候就会打印时间</span><br>        deferObservable = Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;Integer&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> getInt();<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//        deferObservable.subscribe(new Action1&lt;Integer&gt;() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public void call(Integer integer) &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;subscribe:&quot; + integer);</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在不用延迟的情况下，我们调用 simpleDefer 返回一个数据流的时候就会打印时间，反之我们不用延迟的话，则会在调用 simpleDefer 的时候就已经打印了当前的时间。<br>所以，这里被延迟的是我们 getInt 被调用的时机。注意：create 中的发射 42 和延迟 <em>无关</em>，这个 call 函数就是在 <em>发射</em> 数据，<em>订阅的时候才会发射数据</em> ，一旦订阅发生的额时候，就会发射42。</p><p>总之记住，defer 延迟的是参数 function 中的操作。只要将需要延迟创建的操作放到 function 函数中即可。这个对于数据的新鲜度有要求的操作很有用。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>我们接受到的数据常常用些是不满足我们的需求的，这时候就可以用 filter 操作符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservableByCreate(url).filter(<span class="hljs-keyword">new</span> Func1&lt;DestinationDataModel, Boolean&gt;() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(DestinationDataModel destinationDataModel)</span> </span>&#123;<br>               <span class="hljs-keyword">return</span> destinationDataModel != <span class="hljs-keyword">null</span>;<br>           &#125;<br>       &#125;)<br>           .subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())<br>           .subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>比如我们可以对发射的数据中 null 数据进行过滤，虽然我们也可以在 onNext 或者在 subscriber 中进行过滤，那样就会破坏代码的业务逻辑，这样，每个函数只要注重自身的业务逻辑即可。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>我们有时候随着需求的变更，版本的迭代，可能用同一套数据可能会做不用的用处，亦或者同一个功能的同一个数据源，但是上层的应用对数据结构的需求发生了变化。这时候，如果我们去变更数据提供层，或者让上层去适配，都会破坏代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservableByCreate(url).map(<span class="hljs-keyword">new</span> Func1&lt;DestinationDataModel, String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">(DestinationDataModel destinationDataModel)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> destinationDataModel.getVersion();<br>    &#125;<br>&#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>看上面，我们并没有修改 getDestinationDataObservableByCreate 的业务逻辑，这样就不会影响其他的代码逻辑，也不会去贸然修改底层数据提供，用 map 操作符，我们就将 getDestinationDataObservableByCreate 发射的 DestinationDataModel 类型的数据，一个个变换成了 String 类型。<br>map适用于这些数据结构的变化的操作。</p><h3 id="FlatMap-amp-amp-ConcatMap"><a href="#FlatMap-amp-amp-ConcatMap" class="headerlink" title="FlatMap &amp;&amp; ConcatMap"></a>FlatMap &amp;&amp; ConcatMap</h3><p>对于一些 Observable 本身也会返回 Observable，我们可以将这些子 Observable 发射的数据进行统一，合并这些 Observables 发射的数据，最后将合并后的结果作为最终的 Observable。<br>这就是为什么叫做铺平的原因。<br>提示：合并部分是允许交叉的。意味着 flatMap() 不能够保证在最终生成的 Observable 中源 Observables 确切的发射顺序。ConcatMap 可以保证顺序，用法和 flatMap 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Observable&lt;Observable&lt;DestinationDataModel&gt;&gt; getDestinationDataObservableByFlatMap(<span class="hljs-keyword">final</span> String url) &#123;<br>        <span class="hljs-keyword">return</span> Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;Observable&lt;DestinationDataModel&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> Observable&lt;DestinationDataModel&gt;&gt; subscriber)</span> </span>&#123;<br>                Gson gson = <span class="hljs-keyword">new</span> Gson();<br>                Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).build();<br>                Response response = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    response = client.newCall(request).execute();<br>                    DestinationDataModel destinationDataModel = gson.fromJson(response.body().string(), DestinationDataModel.class);<br>                    <span class="hljs-keyword">if</span> (subscriber.isUnsubscribed()) &#123;<span class="hljs-comment">//判断连接是否断开，避免无谓的操作</span><br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    subscriber.onNext(Observable.just(destinationDataModel));<br>                    subscriber.onNext(Observable.just(destinationDataModel));<br>                    subscriber.onCompleted();<br>                    <span class="hljs-keyword">if</span> (!subscriber.isUnsubscribed()) &#123;<br>                        subscriber.onCompleted();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservableByFlatMap(url).flatMap(<span class="hljs-keyword">new</span> Func1&lt;Observable&lt;DestinationDataModel&gt;, Observable&lt;DestinationDataModel&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;DestinationDataModel&gt; <span class="hljs-title">call</span><span class="hljs-params">(Observable&lt;DestinationDataModel&gt; destinationDataModelObservable)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> destinationDataModelObservable;<br>            &#125;<br>        &#125;)<br>        .subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>上面我们用 subscriber.onNext(Observable.just(destinationDataModel));模拟发送两个 Observable,然后通过 flatMap 进行扁平化处理。我们看到效果是列表中有两组相同的数据。<br>flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。 但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。<br> flatMap() 的原理是这样的：</p><ol><li>使用传入的事件对象创建一个 Observable 对象；</li><li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li><li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。<br>这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。 而这个『铺平』就是 flatMap() 所谓的 flat。</li></ol><h3 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h3><p>和上面的操作符类似 ，都是 Observable 发射 Observable,不同的是，这个操作不会合并数据项中的所有数据，而是当遇到后一个 Observable 发射数据的时候，就停止对前一个 Observable 的接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">getDestinationDataObservableByFlatMap(url).switchMap(<span class="hljs-keyword">new</span> Func1&lt;Observable&lt;DestinationDataModel&gt;, Observable&lt;DestinationDataModel&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;DestinationDataModel&gt; <span class="hljs-title">call</span><span class="hljs-params">(Observable&lt;DestinationDataModel&gt; destinationDataModelObservable)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> destinationDataModelObservable;<br>    &#125;<br>&#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())<br>    .subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>只要换个操作符即可 switchMap，这里因为发射的数据只有一个，效果不明显，如果是列表，交叉发射的话，会很明显，效果回事丢失一部分数据。</p><h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p>我们对数据按照某个依据进行分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Observable&lt;GroupedObservable&lt;String, DestinationDataModel&gt;&gt; groupedObservableObservable = getDestinationDataObservableByCreate(url).groupBy(<span class="hljs-keyword">new</span> Func1&lt;DestinationDataModel, String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">(DestinationDataModel destinationDataModel)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> destinationDataModel.getVersion();<br>            &#125;<br>        &#125;);<br>        Observable.concat(groupedObservableObservable).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>以上依旧版本号对数据进行分组，一组的将在一起当做一个 Observable 发射。</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>对数据进行整合一起发射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Observable&lt;DestinationDataModel&gt; merge1 = getDestinationDataObservableByCreate(url);<br>Observable&lt;DestinationDataModel&gt; merge2 = getDestinationDataObservableByCreate(url);<br>Observable&lt;DestinationDataModel&gt; merge = Observable.merge(merge1, merge2);<br>merge.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>merge 作为一个可观测序列，发射源 merge1，merge2 中的所有数据。注意发射的数据被交叉合并到一个 Observable 里面。如果同步的合并 Observable，它们将连接在一起并且不会交叉。</p><h3 id="zip-join-amp-amp-combineLatest"><a href="#zip-join-amp-amp-combineLatest" class="headerlink" title="zip $$ join &amp;&amp; combineLatest"></a>zip $$ join &amp;&amp; combineLatest</h3><p>上面的数据，是原样的放在一个可观测序列中进行发射的，然而如果我们想对源数据中两两的进行操作后再放到一个数据列中呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Observable&lt;DestinationDataModel&gt; zip1 = getDestinationDataObservableByCreate(url);<br>       Observable&lt;DestinationDataModel&gt; zip2 = getDestinationDataObservableByCreate(url);<br>       Observable&lt;DestinationDataModel&gt; zip = Observable.zip(zip1, zip2, <span class="hljs-keyword">new</span> Func2&lt;DestinationDataModel, DestinationDataModel, DestinationDataModel&gt;() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> DestinationDataModel <span class="hljs-title">call</span><span class="hljs-params">(DestinationDataModel destinationDataModel, DestinationDataModel destinationDataModel2)</span> </span>&#123;<br>               <span class="hljs-comment">//进行数据的合并操作</span><br>               destinationDataModel.setCode(destinationDataModel.getCode() + destinationDataModel2.getCode());<br>               <span class="hljs-keyword">return</span> destinationDataModel;<br>           &#125;<br>       &#125;);<br>       zip.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);<br></code></pre></td></tr></table></figure><p>上面在 Func2 中对两个数据源中的数据进行两两操作，我们只是简单的将 model 的 code 值相加来模拟合并操作，作为新的数据返回，假如两数据源的长度相同，则只会返回一个数据源长度的数据，假如长度不一样，以短的数据长度为准。</p><p>zip 作用于最近未打包的两个 Observables,还有一个需求就是我们不一定要非都是未打包的，并不一定要两个数据源要一定的长度相等，这个时候可以用 combineLatest，相反，combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了 A 并且 Observable2 发射了 B 和 C，combineLatest() 将会分组处理 AB 和 AC。</p><p>join 操作符把类似于 combineLatest 操作符，也是两个 Observable 产生的结果进行合并，合并的结果组成一个新的 Observable，但是 join 操作符可以控制每个 Observable 产生结果的生命周期，在每个结果的生命周期内，可以与另一个 Observable 产生的结果按照一定的规则进行合并。</p><h2 id="RxAndroid-rxbinding"><a href="#RxAndroid-rxbinding" class="headerlink" title="RxAndroid rxbinding"></a>RxAndroid rxbinding</h2><p>Jake 为 Android 控件写的包，这个的使用就太多了。这个我们以一个登陆界面为例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/linearLayoutRoot&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textViewRxAndroid&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Result&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/editTextRXAndroid&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;输入自己的内容，上面的textview会在400毫秒之后显示出来&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/blue_light&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/email&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;Email&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/blue_light&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/phone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;Phone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/blue_light&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/username&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;UserName&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/blue_light&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/LoginButton&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;注册&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们用第一个 TextView 来演示怎么样定时操作 TextView 的响应。场景常见于搜索，智能提示，我们不能用户输入什么就不停地网络请求。比如用户停止输入的内容有变，500秒之后再进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两个事件源的时间间隔小于规定的时间单位的，都会被忽略。</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleDebounce</span><span class="hljs-params">()</span> </span>&#123;<br>        RxTextView.textChangeEvents(editTextRXAndroid)<br>            .debounce(<span class="hljs-number">400</span>, TimeUnit.MILLISECONDS)<br>            .observeOn(AndroidSchedulers.mainThread())<br>            .subscribe(<span class="hljs-keyword">new</span> Observer&lt;TextViewTextChangeEvent&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(TextViewTextChangeEvent textViewTextChangeEvent)</span> </span>&#123;<br>                  <span class="hljs-comment">//模拟响应</span><br>                    textViewRxAndroid.setText(textViewTextChangeEvent.text());<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的代码中，在400毫秒的时间窗口内，如若临近的事件发生间隔在400毫秒以内的，都将被忽略，当相差的时间间隔达到400毫秒到达的时候，发射最近的一次事件。</p><p>在登录的时候，必须验证三要素都齐全才能进行注册的网络请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用combineLatest合并最近N个结点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleCombineLatest</span><span class="hljs-params">()</span> </span>&#123;<br>        Observable&lt;CharSequence&gt; emailChangeObservable = RxTextView.textChanges(email);<br>        Observable&lt;CharSequence&gt; phoneChangeObservable = RxTextView.textChanges(phone);<br>        Observable&lt;CharSequence&gt; usernameChangeObservable = RxTextView.textChanges(username);<br>        Observable.combineLatest(emailChangeObservable, phoneChangeObservable, usernameChangeObservable, <span class="hljs-keyword">new</span> Func3&lt;CharSequence, CharSequence, CharSequence, Boolean&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(CharSequence charSequence, CharSequence charSequence2, CharSequence charSequence3)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(charSequence) &amp;&amp; !TextUtils.isEmpty(charSequence2) &amp;&amp; !TextUtils.isEmpty(charSequence3)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Boolean&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Boolean aBoolean)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (aBoolean) &#123;<br>                    LoginButton.setEnabled(<span class="hljs-keyword">true</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LoginButton.setEnabled(<span class="hljs-keyword">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 combineLatest 操作符，合并三个 TextView 的事件源，判断三个事件源都满足条件的时候，我们就返回 true，接着进行响应。</p><p>有时候，我们获取数据的渠道有很多，最后我们还是需要放到一起进行显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用merge合并两个数据源。</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleMerge</span><span class="hljs-params">()</span> </span>&#123;<br>      Observable.merge(getDataFromFile(), getDataFromNet())<br>          .subscribeOn(Schedulers.io())<br>          .observeOn(AndroidSchedulers.mainThread())<br>          .subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                  textViewRxAndroid.setText(s + textViewRxAndroid.getText());<br>              &#125;<br>          &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>以上我们对来自于本地的和网络请求的数据进行 merge 操作，产生新的数据流。</p><p>对于数据获取，我们有时候也有优先级，先去判断内存中是否有数据，有我们取内存中的，依次接下里是本地缓存，再次我们再去请求网络获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//依次检查memory、disk、network</span><br>        Observable.concat(memory, disk, network)<br>            .first()<br>            .subscribeOn(Schedulers.newThread())<br>            .subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;选择了：&quot;</span> + s);<br>                &#125;<br>            &#125;);<br></code></pre></td></tr></table></figure><p>使用 timer 做定时操作。当有“x秒后执行y操作”类似的需求的时候，想到使用 timer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleTimer</span><span class="hljs-params">()</span> </span>&#123;<br>        Observable.timer(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>            .subscribe(<span class="hljs-keyword">new</span> Observer&lt;Long&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;现在是2秒之后&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br><br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Long aLong)</span> </span>&#123;<br><br>                &#125;<br>            &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 interval 做周期性操作。当有“每隔xx秒后执行yy操作”类似的需求的时候，想到使用 interval</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleInterval</span><span class="hljs-params">()</span> </span>&#123;<br>        Observable.interval(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>            .subscribe(<span class="hljs-keyword">new</span> Observer&lt;Long&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Long number)</span> </span>&#123;<br>                &#125;<br>            &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>以两秒为周期，不断的发送数据。</p><p>使用 throttleFirst 防止按钮重复点击,ps：debounce 也能达到同样的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleThrottleFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    RxView.clicks(LoginButton)<br>        .throttleFirst(<span class="hljs-number">1</span>, TimeUnit.SECONDS)<br>        .subscribe(<span class="hljs-keyword">new</span> Subscriber&lt;Void&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Void aVoid)</span> </span>&#123;<br><br>            &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的含义是在一秒以内，只接收第一个数据，其他的将会被忽略。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Android</tag>
      
      <tag>RxAndroid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LayoutInflater中inflate的使用方法</title>
    <link href="/2016/02/23/LayoutInflater%E4%B8%ADinflate%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2016/02/23/LayoutInflater%E4%B8%ADinflate%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 LayoutInflater 的 inflate 方法的三个参数的含义.</p><span id="more"></span><p>常常需要使用 LayoutInflater 中 inflate 方法。这个方法有两个重载的版本，一个是含有三个参数的，一个是两个参数的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//resource 代表了要被加载的布局文件的 ID，root 是待附加的父布局</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root)</span></span><br><span class="hljs-function"><span class="hljs-comment">//前两个是一样的，最后一个 attachToRoot 代表是否加载到父布局的树形结构中</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span><br></code></pre></td></tr></table></figure><p>我们使用最频繁的地方应该就是在 adapter 的 getView 方法中，将 root 值设为 null，或者设一个 parent，将 attachToRoot 设为 false。一般没有特殊的需求的话，这样就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;<br>       View root;<br>       ViewHolder viewHolder;<br>       <span class="hljs-keyword">if</span> (convertView == <span class="hljs-keyword">null</span>) &#123;<br>           viewHolder = <span class="hljs-keyword">new</span> ViewHolder();<br>           <span class="hljs-comment">//加载布局</span><br>           root = LayoutInflater.from(mContext).inflate(R.layout.listitem_campaign, parent, <span class="hljs-keyword">false</span>);<br>           <span class="hljs-comment">//加载布局，上面是含有第三个参数的版本，下面是含有两个参数的版本。和上面的效果是一样的；</span><br>           <span class="hljs-comment">//root = LayoutInflater.from(mContext).inflate(R.layout.listitem_campaign,null);</span><br>           viewHolder.time = (TextView) root.findViewById(R.id.campaignItemTimeTextView);<br>           viewHolder.imageView = (ImageView) root.findViewById(R.id.campaignItemImageView);<br>           viewHolder.title = (TextView) root.findViewById(R.id.campaignItemTitleTextView);<br>           viewHolder.desc = (TextView) root.findViewById(R.id.campaignItemDescTextView);<br>           viewHolder.redCircle = (ImageView) root.findViewById(R.id.redCircleImageView);<br>           root.setTag(viewHolder);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           root = convertView;<br>           viewHolder = (ViewHolder) root.getTag();<br>       &#125;<br>       Campaign campaign = data.get(position);<br>       viewHolder.time.setText(campaign.getTime());<br>       viewHolder.title.setText(campaign.getTitle());<br>       viewHolder.desc.setText(campaign.getDescription());<br>       viewHolder.time.setText(campaign.getTime());<br>       viewHolder.redCircle.setVisibility(campaign.isRead() ? View.INVISIBLE : View.VISIBLE);<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>当 parent 为 null 的时候，attachToRoot 就为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-keyword">int</span> resource, <span class="hljs-meta">@Nullable</span> ViewGroup root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> inflate(resource, root, root != <span class="hljs-keyword">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>再看下 inflate 方法的关键部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Temp is the root view that was found in the xml</span><br>                    <span class="hljs-keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);<br><br>                    ViewGroup.LayoutParams params = <span class="hljs-keyword">null</span>;<br><br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;Creating params from root: &quot;</span> +<br>                                    root);<br>                        &#125;<br>                        <span class="hljs-comment">// Create layout params that match root, if supplied</span><br>                        params = root.generateLayoutParams(attrs);<br>                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;<br>                            <span class="hljs-comment">// Set the layout params for temp if we are not</span><br>                            <span class="hljs-comment">// attaching. (If we are, we use addView, below)</span><br>                            temp.setLayoutParams(params);<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;-----&gt; start inflating children&quot;</span>);<br>                    &#125;<br><br>                    <span class="hljs-comment">// Inflate all children under temp against its context.</span><br>                    rInflateChildren(parser, temp, attrs, <span class="hljs-keyword">true</span>);<br><br>                    <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;-----&gt; done inflating children&quot;</span>);<br>                    &#125;<br><br>                    <span class="hljs-comment">// We are supposed to attach all the views we found (int temp)</span><br>                    <span class="hljs-comment">// to root. Do that now.</span><br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;<br>                        root.addView(temp, params);<br>                    &#125;<br><br>                    <span class="hljs-comment">// Decide whether to return the root that was passed in or the</span><br>                    <span class="hljs-comment">// top view found in xml.</span><br>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;<br>                        result = temp;<br>                    &#125;<br>                &#125; <br></code></pre></td></tr></table></figure><p>当 root 为空的时候，直接返回了 temp (temp是从xml布局文件中加载的view)，而当 root 不为空的时候，会将 root 作为父布局，根据 xml 解析布局文件中的节点，获取属性元素，重新生成 temp 的布局参数 params (此时假如 attachToRoot 为 false，则会将 temp 的布局参数设置成生成的布局参数 params),而后根据 temp 重新inflate temp 中的子 view，该设置 params 的设置 params。而后如果 parent 不为空，attachToRoot 为 true，就会将整个布局中的所有元素挨个添加到 parent 中。最后返回的是 parent。</p><p>那么当 parent 为空的时候，又是什么个情况呢？因为 parent 为空，也就是 xml 文件根布局没有 parent 作为参照，解析的时候，他的高无论节点上设置的是什么都会默认是 wrap_content，宽都会是 match_parent。</p><p>假设目前有个布局文件为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ff0000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;red&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们指定了 textview 的宽高。这里的 textview 就一个布局文件的跟布局。看下下面的代码，adapter 的 item 的布局也是类似的，原理一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LayoutInflaterActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> View view = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_layoutinflater_main);<br><br>        ViewGroup parent = (ViewGroup) findViewById(R.id.layoutInflaterContainer);<br>        <span class="hljs-comment">// result: layout_height=wrap_content layout_width=match_parent</span><br>        view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, <span class="hljs-keyword">null</span>);<br>        parent.addView(view);<br><br>        <span class="hljs-comment">// result: layout_height=100 layout_width=100</span><br>        view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, <span class="hljs-keyword">null</span>);<br>        parent.addView(view, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// result: layout_height=25dp layout_width=25dp</span><br>        <span class="hljs-comment">// view=textView due to attachRoot=false</span><br>        view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, parent, <span class="hljs-keyword">false</span>);<br>        parent.addView(view);<br><br>        <span class="hljs-comment">// result: layout_height=25dp layout_width=25dp</span><br>        <span class="hljs-comment">// parent.addView not necessary as this is already done by attachRoot=true</span><br>        <span class="hljs-comment">// view=root due to parent supplied as hierarchy root and attachRoot=true</span><br>        view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, parent, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>第一种方案，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// result: layout_height=wrap_content layout_width=match_parent</span><br>view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, <span class="hljs-keyword">null</span>);<br>parent.addView(view);<br></code></pre></td></tr></table></figure><p>效果就是加载的布局宽度为充满 match_parent ，高度为 wrap_content。</p><ul><li>第二种方案</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// result: layout_height=100 layout_width=100</span><br>view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, <span class="hljs-keyword">null</span>);<br>parent.addView(view, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>效果就是加载的布局宽宽高均为 100 个像素。</p><ul><li>第三种方案</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// result: layout_height=25dp layout_width=25dp</span><br><span class="hljs-comment">// view=textView due to attachRoot=false</span><br>view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, parent, <span class="hljs-keyword">false</span>);<br>parent.addView(view);<br></code></pre></td></tr></table></figure><p>效果就是加载的布局宽宽高均为布局中设置的 25dp。</p><ul><li>第四种</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// result: layout_height=25dp layout_width=25dp</span><br><span class="hljs-comment">// parent.addView not necessary as this is already done by attachRoot=true</span><br><span class="hljs-comment">// view=root due to parent supplied as hierarchy root and attachRoot=true</span><br>view = LayoutInflater.from(<span class="hljs-keyword">this</span>).inflate(R.layout.activity_layoutinflater_sub, parent, <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>效果就是加载的布局宽宽高均为布局中设置的 25dp，并且添加到了当前的布局中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，要能在 getview 中，自定义宽高，办法有两个，一个是在最外层再套一层布局，然后 parent 设为 null。另一个是指定 parent，将 attachToRoot 设为 false。</p>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LayoutInflater</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataBinding 入门简介</title>
    <link href="/2016/02/20/DataBinding/"/>
    <url>/2016/02/20/DataBinding/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文介绍 DataBinding 的基本概念和接入流程</p><span id="more"></span><h1 id="DataBinding出现的背景"><a href="#DataBinding出现的背景" class="headerlink" title="DataBinding出现的背景"></a>DataBinding出现的背景</h1><p>作为一种 MVVM 的实现方式出现.</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>将数据的 provider 和 consumer 进行绑定，而后进行二者之间同步的一种技术。实现逻辑层和表现层的绑定。</p><hr><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>使用的编译工具必须是 gradle，并且使用的 Android gradle 插件版本依旧官方所说，不能低于 Android Plugin for Gradle 1.3.0-beta4；</li><li>在使用的 module 的 gradle 文件中添加 apply plugin: ‘com.android.databinding’；</li></ul><hr><p>以上部分是 beta 1.3 版本的环境搭建以下是 1.5 的</p><hr><ul><li>使用gradle for android 1.5</li><li>在 APP module 的 gradle 中添加代码段 </li></ul> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">dataBinding &#123;<br>    enabled = true<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="工作的流程原理"><a href="#工作的流程原理" class="headerlink" title="工作的流程原理"></a>工作的流程原理</h2><ol><li><p>在编译的时候，dataBinding 回去布局文件中进行文件的解析，然后获取关于 dataBinding 的设置，然后为对应的 view 设置 tag，<br>然后删除关于 dataBinding 的所有内容。</p></li><li><p>对于属性中引用 java 变量的值的地方，原理都是调用的对应的 java 的 set 方法进行设置，比如 TextView 的属性 text 对应了 setText();对于 ImageView 的 src 属性<br>通过一些注解，让其对应 setImageResource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingMethod(</span><br><span class="hljs-meta">type = android.widget.ImageView.class,</span><br><span class="hljs-meta">attribute = &quot;android:src&quot;,</span><br><span class="hljs-meta">method = &quot;setImageResource&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>dataBinding 的 BaseObservable，继承的类，通过注解 @Bindable 注解对应属性的 get 方法可以在属性变化的时候及时的通知布局中更新 UI。</p></li><li><p>BindingAdapter 方法，用在 adapter 中的</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(&quot;android:src&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageUrl</span><span class="hljs-params">(ImageView view, String url)</span> </span>&#123;<br>    Picasso.with(view.getContext()).load(url).into(view);<br>&#125;<br></code></pre></td></tr></table></figure><p>1.额外的属性,同样是 adapter 中<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> …</span><br><span class="hljs-tag">   <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@&#123;contact.largeImageUrl&#125;&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">app:placeHolder</span>=<span class="hljs-string">&quot;@&#123;R.drawable.contact_placeholder&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(value = &#123;&quot;android:src&quot;, &quot;placeHolder&quot;&#125;,requireAll = false)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageUrl</span><span class="hljs-params">(ImageView view, String url,<span class="hljs-keyword">int</span> placeHolder)</span> </span>&#123;<br>    RequestCreator requestCreator =Picasso.with(view.getContext()).load(url);<br>    <span class="hljs-keyword">if</span> (placeHolder != <span class="hljs-number">0</span>) &#123;<br>        requestCreator.placeholder(placeHolder);<br>    &#125;<br>    requestCreator.into(view);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>参考官方指导：<br>  <a href="https://developer.android.com/tools/data-binding/guide.html">https://developer.android.com/tools/data-binding/guide.html</a></li><li>同时发现，敲完代码发现这个demo写的很详细：<br>  <a href="https://github.com/LyndonChin/MasteringAndroidDataBinding">https://github.com/LyndonChin/MasteringAndroidDataBinding</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxAndroid入门分享(一)</title>
    <link href="/2016/02/08/RxAndroidIntroduction1/"/>
    <url>/2016/02/08/RxAndroidIntroduction1/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文记录 RxJava 的概念.</p><span id="more"></span><h1 id="RxJava-以及响应式函数思想篇"><a href="#RxJava-以及响应式函数思想篇" class="headerlink" title="RxJava 以及响应式函数思想篇"></a>RxJava 以及响应式函数思想篇</h1><h2 id="Why-技术产生的背景"><a href="#Why-技术产生的背景" class="headerlink" title="Why 技术产生的背景"></a>Why 技术产生的背景</h2><p>在编程中，经常需要切换线程，为了能对结果进行相应处理，经常需要进行回调，随着业务需求的增加，嵌套的回调也会随之增加，不仅增加了代码量，也增加了逻辑的复杂性，增加了理解和维护的难度。<br>所以就需要一种</p><ul><li>既能方便切换线程</li><li>又能即是相应变化</li><li>又可以简化代码的逻辑，方便维护，</li><li>还不需要回调。</li></ul><h2 id="What-ReactiveX是什么"><a href="#What-ReactiveX是什么" class="headerlink" title="What ReactiveX是什么"></a>What ReactiveX是什么</h2><p>Reactive Extensions,简称 RX，原来只是微软开发的一个 LINQ 的一个扩展。</p><p>微软给的定义是，Rx 是一个函数库，让开发者可以利用<strong>可观察序列</strong>和<strong>LINQ风格查询操作符</strong>来编写<strong>异步</strong>和基于<strong>事件</strong>的程序，使用 Rx，开发者可以用Observables 表示异步数据流，用 LINQ 操作符查询异步数据流，用 Schedulers 参数化异步数据流的并发处理，Rx 可以这样定义：<strong>Rx = Observables + LINQ + Schedulers。</strong></p><p>ReactiveX.io 给的定义是，Rx 是一个使用可观察数据流进行异步编程的<strong>编程接口</strong>，ReactiveX 结合了观察者模式、迭代器模式和函数式编程的精华。</p><p>看完微软给的定义已经很详细了，开源组织给的更加精简，里面提到了数据流还有事件，我们来自己看看怎么理解。</p><p>这里得提到响应式编程的概念，其中有两个关键点，</p><ul><li>事件，事件可以被观察，等待，过滤，响应，也可以触发其他的事件，事件通过数据流的形式对外呈现。</li><li>数据流，数据流就像一条河：它可以<strong>被观测，被过滤，被操作，或者与另外一条流合并为一条新的流来给新的消费者消费</strong>。</li></ul><p>所以，响应式编程就是一种基于异步<strong>数据流</strong>概念的编程模式。其实 EventBus 还有其他的点击事件一样，本质上就是异步的数据流，我们可以为任何的事件创建数据流。比如我们可以为登录操作创建数据流，然后监听这个数据流，进行登录验证这样的响应操作。</p><p>主要特点有：</p><ul><li>易于并发从而更好的利用服务器的能力。</li><li>易于有条件的异步执行。</li><li>一种更好的方式来避免回调地狱。</li><li>一种响应式方法。</li></ul><h2 id="RxJava与传统的Java的不同"><a href="#RxJava与传统的Java的不同" class="headerlink" title="RxJava与传统的Java的不同"></a>RxJava与传统的Java的不同</h2><p>在 Rx 中，开发者用 Observables 模拟可被观察的异步数据流，从纯 Java 的观点看，RxJava 的 Observable 类源自于经典的 Gang Of Four 的观察者模式。</p><h3 id="与传统观察者的不同"><a href="#与传统观察者的不同" class="headerlink" title="与传统观察者的不同"></a>与传统观察者的不同</h3><p>它添加了三个缺少的功能：</p><ul><li>生产者在没有更多数据可用时能够发出信号通知：onCompleted()事件。</li><li>生产者在发生错误时能够发出信号通知：onError()事件。</li><li>RxJava Observables 能够组合而不是嵌套，从而避免开发者陷入回调地狱。</li></ul><h3 id="与传统的Iterable的不同"><a href="#与传统的Iterable的不同" class="headerlink" title="与传统的Iterable的不同"></a>与传统的Iterable的不同</h3><p>Observables 和 IterablesAPI 是很相似的：我们在 Iterable 可以执行的许多操作也都同样可以在 Observables 上执行。当然，由于 Observables 流的本质，没有如Iterable.remove() 这样相应的方法,因为数据可能已经发射出去了，remove 也没有任何意义。</p><p>使用 Iterable 时，消费者从生产者那里以同步的方式得到值，在这些值得到之前线程处于阻塞状态。相反，使用 Observable 时，生产者以异步的方式把值 push 给观察者，无论何时，这些值都是可用的。这种方法之所以更灵活是因为即便值是同步或异步方式到达，消费者在这两种场景都可以根据自己的需要来处理。</p><table><thead><tr><th>Pattern</th><th align="right">一个返回值</th><th align="center">多个返回值</th></tr></thead><tbody><tr><td>Synchronous</td><td align="right">T getData()</td><td align="center">Iterable<T></td></tr><tr><td>Asynchronous</td><td align="right">Future<T> getData()</td><td align="center">Observable<T> getData()</td></tr></tbody></table><p>Observable 的生命周期包含了三种可能的易于与 Iterable 生命周期事件相比较的事件，下表展示了如何将 Observable async/push 与 Iterable sync/pull 相关联起来。</p><table><thead><tr><th>Event</th><th align="right">Iterable(pull)</th><th align="center">Observable(push)</th></tr></thead><tbody><tr><td>检索数据</td><td align="right">T next()</td><td align="center">onNext(T)</td></tr><tr><td>发现错误</td><td align="right">throws Exception</td><td align="center">onError(Throwable)</td></tr><tr><td>完成</td><td align="right">!hasNext()</td><td align="center">onCompleted()</td></tr></tbody></table><p>所以，由以上这些新增的特点，开发者只要简单的去请求，当请求完成的时候，会得到一个通知。开发者需要对可能发生的每个事件提供一个清晰的响应链。</p><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>用户提交完用户名和密码，我们可以用 observable 模拟这个登录的数据流，而后我们需要对可能发生的情况进行定义；</p><ul><li>用户名密码正确，登录成功，转到登录成功界面。</li><li>用户名和密码匹配不成功，登录失败，给用户个提示。</li></ul><p>这样，我们不需要等待结果，等到有结果的时候，会有通知，这个过程是异步的。这中间可以做很多其他的事情，保存到缓存，显示进度条等等。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>当我们异步执行一些复杂的事情，Java 提供了传统的类，例如 Thread、Future、FutureTask、CompletableFuture 来处理这些问题。当复杂度提升，这些方案就会变得麻烦和难以维护。最糟糕的是，它们都不支持链式调用。RxJava Observables 可以解决这些问题。它可以作用于单个结果程序上，也可以作用于序列上。无论何时你想发射单个标量值，或者一连串值，甚至是无穷个数值流，你都可以使用 Observable。和传统的观察者模式一样，也有冷热之分。</p><ul><li>热的 observable，只要创建了 observable，就开始发射数据了，所以，后续订阅他的 observer 可能从中间某个位置开始接收数据。</li><li>冷的 observable，等到有订阅的时候才开始发射数据。</li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>观察者，订阅 observable 发射的数据，对其做出相应，对可能出现的情况的定义就在这里。</p><p>三个重要的回调方法 (onNext, onCompleted, onError)<br>通过Subscribe方法可以将观察者连接到 Observable，观察者需要实现以下方法的一个子集:</p><ul><li>onNext(T item):Observable 调用这个方法发射数据，方法的参数就是 Observable 发射的数据，这个方法可能会被调用多次，取决于你的实现。</li><li>onError(Exception ex):当 Observable 遇到错误或者无法返回期望的数据时会调用这个方法，这个调用会终止 Observable，后续不会再调用 onNext 和 onCompleted，onError 方法的参数是抛出的异常。</li><li>onComplete:正常终止，如果没有遇到错误，Observable 在最后一次调用 onNext 之后调用此方法。</li></ul><p>根据 Observable 协议的定义，onNext 可能会被调用<strong>零次或者很多次</strong>，最后会有一次 onCompleted 或 onError 调用（不会同时），传递数据给 onNext 通常被称作发射，onCompleted 和 onError 被称作通知。</p><h3 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h3><p>Observers 和 Subscribers 是两个“消费”实体。Subscriber 是一个实现了 Observer 的一个抽象类。相对于基本的 Observer，提供了手动解开订阅的方法 unsubscribe 和在 subscribe 刚开始，而事件还未发送之前被调用的方法 onStart。其他的使用方式是一样的。</p><h3 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h3><p>Subject = Observable + Observer。<br>subject 是一个神奇的对象，它可以是一个 Observable 同时也可以是一个 Observer：它作为连接这两个世界的一座桥梁。一个 Subject 可以订阅一个 Observable，就像一个观察者，并且它可以发射新的数据，或者传递它接受到的数据，就像一个 Observable。很明显，作为一个 Observable，观察者们或者其它 Subject 都可以订阅它。<br>一旦 Subject 订阅了 Observable，它将会触发 Observable 开始发射。如果原始的 Observable 是“冷”的，这将会对订阅一个“热”的 Observable 变量产生影响。</p><h2 id="How怎么使用"><a href="#How怎么使用" class="headerlink" title="How怎么使用"></a>How怎么使用</h2><p>接下来讨论他的具体使用方法。首先是需要搭建环境，我们就以 AS 为例。</p><ul><li>因为就是为了 Android 开发所学的，在 module 的 gradle 中添加 RxAndroid 的仓库地址,RxAndroid 本身是依赖 RxJava 的，所以会自动下载 RxJava 的依赖包。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">compile <span class="hljs-string">&#x27;io.reactivex:rxandroid:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h3><h4 id="Create之从头创建"><a href="#Create之从头创建" class="headerlink" title="Create之从头创建"></a>Create之从头创建</h4><p>这个操作符传递一个<strong>含有观察者作为参数的函数</strong>的对象，编写这个函数让它的行为表现为一个 Observable –恰当的调用观察者的 onNext，onError 和 onCompleted 方法。下面是个非常简单的一个例子，先有个直观的大致的认识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java">Observable.OnSubscribe&lt;String&gt; f = <span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> String&gt; o)</span> </span>&#123;<br>                <span class="hljs-comment">//完全自己决定发射数据给subscriber和通知subscriber的时机以及方式</span><br>                o.onNext(<span class="hljs-string">&quot;发射的数据&quot;</span>);<br>                o.onCompleted();<br>            &#125;<br>        &#125;;<br>        Observable observable = Observable.create(f);<br>        <span class="hljs-comment">//创建订阅者</span><br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//正常结束，收到发射的通知</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                <span class="hljs-comment">//出现了错误的通知</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>                <span class="hljs-comment">//收到observable发射的数据</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//订阅，一旦订阅发生，observable将开始发射数据</span><br>        observable.subscribe(subscriber);<br></code></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>这个操作符需要传入数组或者列表等可以迭代的类型，将会返回一个 Observable 对象，这个 Observable 会迭代列表里的数据，然后将数据一个一个的发射出去。</p><h4 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h4><p>这个操作符会返回一个 Observable，这个 Observable 将传入的对象直接发射出去。这个操作符对于进行旧版本的改造非常有用，对于暂时不想做过多操作的函数，可以直接传入到 just 操作符中，这样就自动构造出了一个数据流。</p><h4 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h4><p>这个操作符需要一个整形数字作为参数，代表了重复发射的次数，比如发射“123”三次，就会变成发射”123123123”。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>这个操作符可以延迟 Observable 的创建，当有订阅者的时候才开始创建，这个对于一些不是每次都需要创建的数据流而言，很有用。怎么理解呢，我们简单的看个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Subscriber subscriber;<br>    <span class="hljs-keyword">private</span> Observable simpleObservable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;在执行just的时候，这里需要执行的操作已经执行结束了。。。&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SteveYan&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        simpleObservable = Observable.just(doSomeThing());<br>        subscriber = <span class="hljs-keyword">new</span> Subscriber() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//正常结束，收到发射的通知</span><br>                System.out.println(<span class="hljs-string">&quot;onCompleted&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                <span class="hljs-comment">//出现了错误的通知</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>                <span class="hljs-comment">//收到observable发射的数据</span><br>                System.out.println(<span class="hljs-string">&quot;Receive &quot;</span> + o.toString());<br>            &#125;<br>        &#125;;<br>        init();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        findViewById(R.id.button).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                <span class="hljs-comment">//每次点击的时候都进行订阅</span><br>                simpleObservable.subscribe(subscriber);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，每次点击就进行一次订阅，在 onCreate 方法里，在执行 just 的时候，doSomeThing 已经执行完了，<br>但是并未发射数据，但是假如使用 defer 操作符的话，doSomeThing 则会等到点击的时候才执行。<br>修改成的 defer 操作符的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Subscriber subscriber;<br>    <span class="hljs-keyword">private</span> Observable simpleObservable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Do Some&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SteveYan&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        simpleObservable = Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;String&gt; <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> Observable.just(doSomeThing());<br>            &#125;<br>        &#125;);<br>        subscriber = <span class="hljs-keyword">new</span> Subscriber() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//正常结束，收到发射的通知</span><br>                System.out.println(<span class="hljs-string">&quot;onCompleted&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>                <span class="hljs-comment">//出现了错误的通知</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>                <span class="hljs-comment">//收到observable发射的数据</span><br>                System.out.println(<span class="hljs-string">&quot;Receive &quot;</span> + o.toString());<br>            &#125;<br>        &#125;;<br>        init();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        findViewById(R.id.button).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                <span class="hljs-comment">//每次点击的时候都进行订阅</span><br>                simpleObservable.subscribe(subscriber);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="range-从一个指定的数字X开始发射N个数字"><a href="#range-从一个指定的数字X开始发射N个数字" class="headerlink" title="range 从一个指定的数字X开始发射N个数字"></a>range 从一个指定的数字X开始发射N个数字</h4><p>range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。目前未发现在实际项目中的用处。</p><h4 id="interval-重复轮训操作"><a href="#interval-重复轮训操作" class="headerlink" title="interval  重复轮训操作"></a>interval  重复轮训操作</h4><p>interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。需要创建一个轮询程序时非常好用</p><h4 id="timer-一段时间之后才发射的Observable"><a href="#timer-一段时间之后才发射的Observable" class="headerlink" title="timer 一段时间之后才发射的Observable"></a>timer 一段时间之后才发射的Observable</h4><p>接受两个参数，一个是延迟发射的时间，第二个参数是时间的。</p><h3 id="可观测序列的本质：过滤"><a href="#可观测序列的本质：过滤" class="headerlink" title="可观测序列的本质：过滤"></a>可观测序列的本质：过滤</h3><p>过滤：如何从发射的 Observable 中选取我们想要的值，如何获取有限个数的值，如何处理溢出的场景，以及更多的有用的技巧。</p><h4 id="filter函数，进行内容的过滤"><a href="#filter函数，进行内容的过滤" class="headerlink" title="filter函数，进行内容的过滤"></a>filter函数，进行内容的过滤</h4><p>接受一个参数，对数据流中的每个数据进行过滤。</p><h4 id="Take-取序列的前N个元素"><a href="#Take-取序列的前N个元素" class="headerlink" title="Take,取序列的前N个元素"></a>Take,取序列的前N个元素</h4><p>take() 函数用整数N来作为一个参数，从原始的序列中发射前 N 个元素</p><h4 id="takeLast-取序列的最后的N个元素"><a href="#takeLast-取序列的最后的N个元素" class="headerlink" title="takeLast,取序列的最后的N个元素"></a>takeLast,取序列的最后的N个元素</h4><p>如果我们想要最后 N 个元素，接给 takeLast<br>函数传入 N 作为参数。有一点值得注意，为了得到最后的数据，所以 takeLast 方法只能作用于一组有限的序列（发射元素），它只能应用于一个完整的序列。否则他无从知晓最后到哪。</p><h4 id="Distinct-有且仅有一个"><a href="#Distinct-有且仅有一个" class="headerlink" title="Distinct 有且仅有一个"></a>Distinct 有且仅有一个</h4><p>distinct 函数去掉重复的。就像 takeLast 一样，distinct 也必须作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。</p><h4 id="DistinctUntilsChanged-改变的时候就记录"><a href="#DistinctUntilsChanged-改变的时候就记录" class="headerlink" title="DistinctUntilsChanged 改变的时候就记录"></a>DistinctUntilsChanged 改变的时候就记录</h4><p>如果我们想在一个可观测序列发射一个不同于之前的一个新值时，让我们得到通知，就可以用这个操作符。</p><h4 id="First-And-Last"><a href="#First-And-Last" class="headerlink" title="First And Last"></a>First And Last</h4><p>从 Observable 中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数，：一个可以确定我们感兴趣的第一个或者最后一个的谓词。<br>与 first()和 last()相似的变量有：firstOrDefault() 和 lastOrDefault().这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果 Observable 不再发射任何值时我们可以指定发射一个默认的值</p><h4 id="Skip-And-SkipLast"><a href="#Skip-And-SkipLast" class="headerlink" title="Skip And SkipLast"></a>Skip And SkipLast</h4><p>它们用整数 N 作参数，从本质上来说，它们不让 Observable 发射前 N 个或者后 N 个值。这个和上面的 First 和 Last 正好相反。</p><h4 id="elementAt-观察指定位置的数据"><a href="#elementAt-观察指定位置的数据" class="headerlink" title="elementAt 观察指定位置的数据"></a>elementAt 观察指定位置的数据</h4><p>elementAt() 函数仅从一个序列中发射第 n 个元素然后就完成了。<br>如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault()。</p><h4 id="sample-每隔一段时间取最近的数据"><a href="#sample-每隔一段时间取最近的数据" class="headerlink" title="sample 每隔一段时间取最近的数据"></a>sample 每隔一段时间取最近的数据</h4><p>创建一个新的可观测序列，它将在一个指定的时间间隔里由 Observable 发射最近一次的数值。<br>如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst()。</p><h4 id="timeout-超时操作"><a href="#timeout-超时操作" class="headerlink" title="timeout 超时操作"></a>timeout 超时操作</h4><p>使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。</p><h4 id="debounce-除去发射过快的数据"><a href="#debounce-除去发射过快的数据" class="headerlink" title="debounce 除去发射过快的数据"></a>debounce 除去发射过快的数据</h4><p>debounce() 函数过滤掉由 Observable 发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。</p><h3 id="转换Observables"><a href="#转换Observables" class="headerlink" title="转换Observables"></a>转换Observables</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>转换发射的数据，将发射数据 A 的 Observable 变换成发射数据 B 的 Observable。适用于对数据的再加工场景。</p><h4 id="FlatMap-铺平序列"><a href="#FlatMap-铺平序列" class="headerlink" title="FlatMap 铺平序列"></a>FlatMap 铺平序列</h4><p>这样的 Observable：它发射一个数据序列，这些数据本身也可以发射 Observable。等于是说发射的数据可以再发射数据。flatMap 函数提供一种铺平序列的方式，然后合并这些 Observables 发射的数据，最后将合并后的结果作为最终的 Observable.</p><p>当我们在处理可能有大量的 Observables 时，重要是记住任何一个 Observables 发生错误的情况，flatMap 将会触发它自己的 onError 函数并放弃整个链。</p><p>重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap 不能够保证在最终生成的 Observable 中源 Observables 确切的发射顺序。</p><h4 id="ConcatMap-保证有序的铺平"><a href="#ConcatMap-保证有序的铺平" class="headerlink" title="ConcatMap 保证有序的铺平"></a>ConcatMap 保证有序的铺平</h4><p>和上面的 FlatMap 一样，就是弥补了交叉这个一个特点。</p><h4 id="FlatMapIterable"><a href="#FlatMapIterable" class="headerlink" title="FlatMapIterable"></a>FlatMapIterable</h4><p>它将源数据两两结成对并生成 Iterable，而不是原始数据项和生成的 Observables。</p><h4 id="SwitchMap-切换数据流-喜新厌旧"><a href="#SwitchMap-切换数据流-喜新厌旧" class="headerlink" title="SwitchMap 切换数据流(喜新厌旧)"></a>SwitchMap 切换数据流(喜新厌旧)</h4><p>switchMap() 和 flatMap() 很像，除了一点：每当源 Observable 发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的 Observable，并开始监视当前发射的这一个。</p><h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><p>RxJava 的 scan() 函数可以看做是一个累积函数。scan 函数对原始 Observable 发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。简单的说是每次可以处理的数据有本次的和上次的数据。</p><h4 id="groupBy-分组"><a href="#groupBy-分组" class="headerlink" title="groupBy 分组"></a>groupBy 分组</h4><p>接受一个方法，在方法里进行分组操作，返回一个自定义的值，系统将根据这个值将进行分组。</p><h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>每次发射一组值，是一个列表，而不是一个个的发射。接受一个整形参数 N，表示 N 个一组进行发射。也可以接受两个参数，SKIP，表示 SKIP 个值中取 N 个一组进行发射。</p><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>和 buffer 类似，但是他发射的不是一个列表，而是一个 Observable。</p><h4 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h4><p>和 map 类似，不同的是将数据进行转换成一个新的类型。TODO 目前测试未发现怎么使用。</p><h3 id="组合Observable"><a href="#组合Observable" class="headerlink" title="组合Observable"></a>组合Observable</h3><p>以上的内容是对 Observable 的发射数据进行过滤，接下来谈谈怎么组合数据流。</p><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>将多个 Observable 发射的值进行合并成一个新的 Observable 然后再发射。中途合并的时候出现任何一个错误都会导致链条断裂，如果想延迟这样的错误处理，可以用 mergeDelayError。</p><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>这个操作符和 merge 一样，也是合并两个 Observable 的数据；不一样的是，他是将两个未进行打包的数据根据传入的谓词规则进行合并成一个新的数据,再进行发射。值得注意的是，两个数据流的长度必须一样，多余的数据将会因为不能打包而得不到发射。</p><h4 id="join-TODO-待详细验证用途"><a href="#join-TODO-待详细验证用途" class="headerlink" title="join TODO 待详细验证用途"></a>join TODO 待详细验证用途</h4><p>有四个参数，</p><ul><li>第一个参数为，Observable，表示和源 Observable 结合的数据流。</li><li>Func1参数：在指定的由时间窗口定义时间间隔内，源 Observable 发射的数据和从第二个 Observable 发射的数据相互配合返回的 Observable。</li><li>Func1参数：在指定的由时间窗口定义时间间隔内，第二个 Observable 发射的数据和从源 Observable 发射的数据相互配合返回的 Observable。</li><li>Func2参数：定义已发射的数据如何与新发射的数据项相结合。</li></ul><h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><p>和 Zip 一样，去组合两个数据流发射的数据，并且进行组合，合并成一个新的数据进行发射，不同的是，Zip 发射的是最近未进行打包的，而 combineLatest 走的是相反的路线，打包最近发射的数据，不管是否已经打包过了。这样的话，就会弥补 Zip 的长度限制，全部得到发射。</p><h4 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h4><p>Observable 开始发射他们的数据之前， startWith() 通过传递一个参数来先发射一个数据序列。 表示发射之前先将传入的参数法发射出去。</p><h3 id="Schedulers-随时切换运行的线程"><a href="#Schedulers-随时切换运行的线程" class="headerlink" title="Schedulers 随时切换运行的线程"></a>Schedulers 随时切换运行的线程</h3><p>这里大致说一下有哪几种情况，因为在 Java 中的情况和 Android 稍有差异，并且必须结合实例才能明白这个好处。</p><h4 id="RxJava提供的五种调度器"><a href="#RxJava提供的五种调度器" class="headerlink" title="RxJava提供的五种调度器"></a>RxJava提供的五种调度器</h4><ul><li>.io()<br>这个调度器时用于 I/O 操作。它基于根据需要，增长或缩减来自适应的线程池。由于它专用于 I/O 操作，所以并不是 RxJava 的默认方法；正确的使用它是由开发者决定的。重点需要注意的是线程池是无限制的，大量的 I/O 调度操作将创建许多个线程并占用内存。</li><li>.computation()<br>这个是计算工作默认的调度器，与I/O 操作无关。也是许多 RxJava 方法的默认调度器：buffer(),debounce(),delay(),interval(),sample(),skip()。所以可以将一些耗时的，但是与 IO 无关的一些操作。</li><li>.immediate()<br>这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout(),timeInterval(),以及 timestamp() 方法默认的调度器。</li><li>.newThread()<br>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</li><li>.trampoline()<br>当我们想在当前线程执行一个任务时，并不是立即，我们可以用<br>.trampoline 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat()和 retry() 方法默认的调度器。</li></ul><h4 id="SubscribeOn-and-ObserveOn，指定线程，线程切换"><a href="#SubscribeOn-and-ObserveOn，指定线程，线程切换" class="headerlink" title="SubscribeOn and ObserveOn，指定线程，线程切换"></a>SubscribeOn and ObserveOn，指定线程，线程切换</h4><p>subscribeOn() 方法来用于每个 Observable 对象。subscribeOn() 方法用 Scheduler 来作为参数并在这个 Scheduler 上执行 Observable 调用。<br>observeOn() 方法将会在指定的调度器上返回结果。observeOn() 方法用 Scheduler 来作为参数，在指定的线程上返回结果，观察者在返回结果的线程上消费这个结果。</p><h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p>Retrofit 完美的支持 Rx 编程，可以完美的结合。</p><p>##感激,非常感激，万分的感激！</p><p>感谢以下的文章以及其作者和翻译的开发者们,排名不分先后</p><ul><li><a href="http://rxjava.yuxingxin.com/">RxJava Essentials 中文翻译版</a></li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX文档中文翻译</a></li><li><a href="http://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mobile</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Android</tag>
      
      <tag>RxAndroid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标题：Hello World</title>
    <link href="/2016/02/07/hello-world/"/>
    <url>/2016/02/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>序言：Hello World.新的一年，希望有一个新的开始。</p><p>开个博客，方便自己平时写总结，公司内部也有分享，这样一举两得，而且用的是markdown，对于我这样懒惰的人，减轻了很多排版的烦恼。</p><p>希望我的内容不会浪费大家的时间，不会增加大家筛选有用信息的时间。</p><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>之后所有的总结分享类的文章脉络，应该遵循Why-&gt;What-&gt;How的原则总结。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
