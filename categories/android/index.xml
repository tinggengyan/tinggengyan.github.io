<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Android - Category - Tinggeng</title>
        <link>https://tinggengyan.github.io/categories/android/</link>
        <description>Android - Category - Tinggeng</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>tinggengyan@gmail.com (Tinggeng)</managingEditor>
            <webMaster>tinggengyan@gmail.com (Tinggeng)</webMaster><lastBuildDate>Sun, 03 Apr 2022 16:19:04 &#43;0000</lastBuildDate><atom:link href="https://tinggengyan.github.io/categories/android/" rel="self" type="application/rss+xml" /><item>
    <title>一张思维导图看 Android【持续迭代】</title>
    <link>https://tinggengyan.github.io/2022/04/android_summary/</link>
    <pubDate>Sun, 03 Apr 2022 16:19:04 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2022/04/android_summary/</guid>
    <description><![CDATA[概述 总结自己的 Android 知识，按照编码 -&gt; 运行，画了一张图，xmind 导出的图比较大，后续持续更新，迭代这部分的内容。
下面是一些常见的知识,将会慢慢补充进思维导图内 Handler 与 Binder handler 处理的是 App 进程内的通信； binder 处理的是，App 进程间、application 和 framework 之间的通信；
任务启动管理 - 启动框架 抽象任务 task； 优先级 ； countdownlatch 数值为依赖 task 的数量； 运行的 executor ； 被依赖的 task 列表； toWait 方法； notify 方法，countdownlatch 减一； 构造 task 的有向无环图； TaskManager： 管理所有的 task，及其拓扑关系； 管理需要执行的 task； countdownlatch 值为 Activity 跳转的生命周期 ActivityA跳转到ActivityB： 1 2 3 4 5 Activity A：onPause Activity B：onCreate Activity B：onStart Activity B：onResume Activity A：onStop ActivityB返回ActivityA： 1 2 3 4 5 6 Activity B：onPause Activity A：onRestart Activity A：onStart Activity A：onResume Activity B：onStop Activity B：onDestroy 旋转屏幕 不改配置，默认配置 1 2 3 4 5 6 7 onPause--&gt; onStop--&gt; onDestroy--&gt; onCreate--&gt; onStart--&gt; onRestoreInstanceState--&gt; onResume--&gt; 修改配置 1 onConfigChanged--&gt; Activity 的启动模式 参考链接1]]></description>
</item>
<item>
    <title>mySoftware</title>
    <link>https://tinggengyan.github.io/2021/07/mysoftware/</link>
    <pubDate>Tue, 06 Jul 2021 19:57:21 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2021/07/mysoftware/</guid>
    <description><![CDATA[概述 记录我平时使用的一些软件,提效的,娱乐的.
快速打开 Raycast Alfred Contexts
目的: 用于快速打开应用软件和文件夹 其中比较知名的就是 Alfread了,我目前把它和Context进行配合使用.
Raycast 和 Alfred 差不多,Raycast 我装了,但是用的频率不高,目前没发现他有什么特别的亮点,用来作为 Alfred 的备选,毕竟免费.
Context有一个feature就是可以切换window,比如,AndroidStudio里打开了多个Project,形成了多个window,这说话,直接Alfred打开Androidstudio的话,只是打开了软件,至于哪个Window,有时候不清楚,这种情况下,Context 是个很好的补充. Context 的缺陷就是,他只是用来打开,已有的窗口的.
输入法 搜狗输入法
目前国内也就搜狗输入法还行了,当然百度也有Mac版本,但是体验上,还是搜狗好点.
终端 iterm2 oh-my-zsh Mac 下很好的终端工具了.目前没发现其他替代品;
Git fork Native开发,相比对sourceTree,颜值和性能都更高,无他,颜值即正义.
Android开发 AndroidStudio
开发Android必备,只是有一点至今让我诟病的地方,就是ActivityStack的打印被删除了&hellip;
C/Cpp开发 Clion
VSC配置cpp开发环境也试过,繁琐.Mac 下的Xcode也用过,感觉一般, 不得不说,jetbrains做的IDE,真香.
Java开发 IntellijIdea Eclipse NetBeans
目前在用的就是 IntellijIdea 了,其他的基本不用了.只有一个 NetBeans 在某些场景下是有优势的,那就是JavaSE GUI开发的时候.
清除广告 AdBlock Pro 清除Safari广告用; 看动漫太多的广告了,Chrome 上清除广告很容易,Safari就只能依赖这个plugin了.
database DataGrip 一个客户端,支持查看所有的数据库,jetbrains太香了.
分屏 Grid
windows 系统有个自动管理窗口的功能,这个软件就是在Mac上实现类似的功能;
扩展屏幕 Deskreen 只要有个浏览器就可以实现屏幕的扩展,有时候可以将自己的iPad用上.
statusbar 隐藏图标 Dozer Bartender]]></description>
</item>
<item>
    <title>AOSP编译</title>
    <link>https://tinggengyan.github.io/2020/09/aosp_build/</link>
    <pubDate>Sun, 06 Sep 2020 15:09:42 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/09/aosp_build/</guid>
    <description><![CDATA[override 最近给电脑换了块SSD，装了Ubuntu 18.04。之前的aosp也不想copy过来了，直接重新编译一份，顺带看下新的SSD带来的提效。 因为手机是 nexus 6p，aosp 最后支持到 8.1. 记录下编译需要的操作。
步骤 open jdk(https://openjdk.java.net/install/) 1 sudo apt install openjdk-8-jdk repo(https://gerrit.googlesource.com/git-repo/) AUTO 1 sudo apt-get install repo MANUALLY 1 2 3 4 $ mkdir -p ~/.bin $ PATH=&#34;${HOME}/.bin:${PATH}&#34; $ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/.bin/repo $ chmod a+rx ~/.bin/repo AOSP mirror 1 mkdir aosp 1 2 3 4 5 6 7 8 9 10 11 12 git config --global user.email &#34;tinggengyan@gmail.com&#34; git config --global user.name &#34;Tinggeng Yan&#34; sudo apt install python cd aosp # 切换指定版本分支 repo init -u https://mirrors.]]></description>
</item>
<item>
    <title>Activity启动流程概述</title>
    <link>https://tinggengyan.github.io/2020/07/activity-launch-process-1/</link>
    <pubDate>Thu, 23 Jul 2020 17:17:42 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/07/activity-launch-process-1/</guid>
    <description><![CDATA[概述 花了点时间,debug了一下系统,跟踪了一下Activity的启动流程.画了一张图,作为综述. 分析的 compileSdkVersion 为 28. 用的是 draw.io 画的,源文件.]]></description>
</item>
<item>
    <title>jdk携带的一个HttpServer实现</title>
    <link>https://tinggengyan.github.io/2020/04/jdk-httpserver/</link>
    <pubDate>Mon, 20 Apr 2020 18:57:56 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/04/jdk-httpserver/</guid>
    <description><![CDATA[概述 记录一个意外发现的一个类 com.sun.net.httpserver.HttpsServer. 一个 Http 的 Server 端.
用处 适用于泛前端类开发者,在无后端服务的情况下,可以用来mock数据或者mock后端行为,非常灵活. 适用于网络库的开发者,测试库的行为; 缺点 目前不支持HTTP2协议. 分类 HTTP 协议 自定义一个 HTTP 服务; 1 2 3 4 5 6 HttpsServer server = HttpsServer.create(new InetSocketAddress(8500), 0); HttpsConfigurator httpsConfigurator = new HttpsConfigurator(SSLContext.getDefault()); server.setHttpsConfigurator(httpsConfigurator); HttpContext context = server.createContext(&#34;/example&#34;); context.setHandler(new CustomHttpHandler()); server.start(); 该 Http 服务,是在本机的 8500 端口启动的; 根目录为 example. 所以,直接通过 http://127.0.0.1:8500/example 即可访问.
Server 的行为定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class CustomHttpHandler implements HttpHandler { @Override public void handle(HttpExchange exchange) throws IOException { URI requestURI = exchange.]]></description>
</item>
<item>
    <title>NDK学习之JNI_Tip</title>
    <link>https://tinggengyan.github.io/2020/02/ndk-jni-tip/</link>
    <pubDate>Thu, 13 Feb 2020 22:47:58 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/02/ndk-jni-tip/</guid>
    <description><![CDATA[Override 本篇是对于 Google NDK GUIDES 中 JNI tips 的总结,是关于 JNI 开发过程 中的一些原则和注意点,没有原理. 所有的内容适用于 Java 和 Kotlin.
约定
- managed code (Java/kotlin编写的代码) - native code (C/C++编写的代码) Tips General 整体上大的原则是: 尽量减少 JNI 层的操作. 故而有以下3点注意事项,重要性由高到低依次为:
JNI 层调用传递的数据尽量少,调用的频率尽量低; JNI Java 调用 native 避免异步调用,异步操作都放在 Java 层.这指的是 JNI 调用,不包含 native 库自身有些异步操作; JNI 操作涉及到的线程越少越好.即使要用线程池,也是由线程池的管理者负责JNI之间的交互,而不是由工作线程直接负责交互; 为了方便维护和重构, 保证JNI相关的代码在固定的位置,容易辨认,且接口尽量少; JavaVM &amp; JNIEnv 二者本质上都是指向函数表的指针的指针. 虽然理论上来说,每个进程可以有多个 JavaVM 对象,但是 Android 规定,每个进程只能有一个 JavaVM ; 注意点 JNIEnv 是个线程局部变量,线程不可共享,请勿在线程之间共享 JNIEnv 对象; 如若无其他方式获取 JNIEnv,可以采如下方式; 1 2 JNIEnv* env; vm-&gt;AttachCurrentThread(&amp;env, nullptr); // 此处的 vm 即为JavaVM 对象,可以处理成全局单例; 由于 JavaVM &amp; JNIEnv 在 C 和 C++ 中的定义是不一样(&ldquo;jni.]]></description>
</item>
<item>
    <title>Activity 在横竖屏切换情况下的生命周期变化</title>
    <link>https://tinggengyan.github.io/2018/04/activitylifecycle/</link>
    <pubDate>Thu, 26 Apr 2018 23:05:57 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2018/04/activitylifecycle/</guid>
    <description><![CDATA[概述 Activity 在横竖屏切换的时候,生命周期是不一样的,本地通过打印 log 的方式,看下区别.测试的机器是 Android6.0 .
不做任何配置的情况下 第一次启动 1 2 3 D/LifeCircleActivity: onCreate() called with: savedInstanceState = [null]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@de950fc D/LifeCircleActivity: onStart() called D/LifeCircleActivity: onResume() called 第一次切换成横屏 1 2 3 4 5 6 7 8 9 D/LifeCircleActivity: onPause() called D/LifeCircleActivity: onSaveInstanceState() called with: outState = [Bundle[{android:viewHierarchyState=Bundle[{android:views={16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5}}], key=x}]] D/LifeCircleActivity: onStop() called D/LifeCircleActivity: onDestroy() called D/LifeCircleActivity: onCreate() called with: savedInstanceState = [Bundle[{android:viewHierarchyState=Bundle[{android:views={16908290=android.view.AbsSavedState$1@80a47f5, 2131296581=android.view.AbsSavedState$1@80a47f5, 2131296815=android.view.AbsSavedState$1@80a47f5}}], key=x}]]Activity对象的地址:cn.steve.activitylifecycle.LifeCircleActivity@266fbfb D/LifeCircleActivity: onStart() called D/LifeCircleActivity: onRestoreInstanceState() called with: savedInstanceState = [Bundle[{android:viewHierarchyState=Bundle[{android:views={16908290=android.]]></description>
</item>
<item>
    <title>Service 的生命周期</title>
    <link>https://tinggengyan.github.io/2018/04/servicelifecycle/</link>
    <pubDate>Thu, 26 Apr 2018 22:40:55 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2018/04/servicelifecycle/</guid>
    <description><![CDATA[概述 Service 有两种启动方式,一种是 startService ;一种是 bindService.这两种的启动的 Service 的生命周期有些许差异,并且当二者混用的时候,有一些需要注意的地方.这里用打印 log 日志的方式记录下生命周期的差异.
仅 startService 触发 startService 方法 1 2 D/ServiceLifeService: onCreate() called D/ServiceLifeService: onStartCommand() called with: intent = [Intent { cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService }], flags = [0], startId = [1] 退出APP 无回调
再次进入APP，触发startService 方法 1 D/ServiceLifeService: onStartCommand() called with: intent = [Intent { cmp=cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService }], flags = [0], startId = [2] 杀死 App 进程 没有回调，直接被系统杀死。只有一些AMS系统回调
1 2 W/ActivityManager: Scheduling restart of crashed service cn.steve.study/cn.steve.servicelifecycle.ServiceLifeService in 1000ms I/ActivityManager: Force stopping service ServiceRecord{38ffaacf u0 cn.]]></description>
</item>
<item>
    <title>webview中关于服务端重定向的判断</title>
    <link>https://tinggengyan.github.io/2017/08/webview-judge-302/</link>
    <pubDate>Thu, 10 Aug 2017 23:13:21 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2017/08/webview-judge-302/</guid>
    <description><![CDATA[背景 由于 H5 页面打开都比较慢,为了减少返回时候的刷新,所以有时候需要多开,就是每个 url 都是在一个新的 activity 中打开.一般的处理方式是在 shouldOverrideUrlLoading() 方法中进行处理,这个方法按照 SDK 中的说明是当 url 发生变化时就会回调,当遇到服务端重定向的时候,就会出现一个空白页面的情况,所以我们需要判断是否是重定向,对于重定向进行特殊的处理.
困难 1 2 3 4 public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { return shouldOverrideUrlLoading(view, request.getUrl().toString()); } 在 Android7.0 ,新增了 WebResourceRequest 接口,接口中有个判断是否是重定向的方法,但对于低版本的该如何判断呢? 可以做如下判断.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 WebViewClient webViewClient = new WebViewClient() { private boolean mLoaded = false; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { if (mLoaded){ //not redirect }else { // is redirect } return true; } @Override public void onPageFinished(WebView webView, String url) { mLoaded = true; } }; 因为能回调 onPageFinished 方法,都是有渲染页面的操作,说明页面是有内容的,对于服务端重定向而言,是没有内容的,所以就不会走 onPageFinished 方法,通过这个间接的判断页面是否是重定向的.]]></description>
</item>
<item>
    <title>IPC_Binder_java_2</title>
    <link>https://tinggengyan.github.io/2017/07/ipc-binder-java-2/</link>
    <pubDate>Tue, 04 Jul 2017 14:47:55 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2017/07/ipc-binder-java-2/</guid>
    <description><![CDATA[概述 本文作为第一篇的补充,补充一下第一篇遗漏的内容,主要谈一下,缺少的概念,技术背景等内容.
Why为什么需要Binder Binder 是 Android 系统进程间通信（IPC）方式之一。Android 是基于 Linux 内核的,Linux 已经有很多 IPC 方式,为何还需要一个新的 IPC 方式. Linux已经拥有
管道 system V IPC Socket 等IPC手段。 却还要倚赖Binder来实现进程间通信。
Binder具有无可比拟的优势。 或者可以说，Android系统对进程间有什么特殊的需求是传统其他 IPC 无法完成或者无法很好完成。 基于Client-Server的通信方式广泛应用于从互联网和数据库访问到嵌入式手持设备内部通信等各个领域。
智能手机平台特别是Android系统中，为了向应用开发者提供丰富多样的功能，这种通信方式更是无处不在，诸如媒体播放，视音频频捕获，到各种让手机更智能的传感器（加速度，方位，温度，光亮度等）都由不同的Server负责管理，应用程序只需做为Client与这些Server建立连接便可以使用这些服务，花很少的时间和精力就能开发出令人眩目的功能。
Client-Server 方式的广泛采用对进程间通信（IPC）机制是一个挑战。
只有socket支持Client-Server的通信方式。当然也可以在这些底层机制上架设一套协议来实现Client-Server通信，但这样增加了系统的复杂性，在手机这种条件复杂，资源稀缺的环境下可靠性也难以保证.
传输性能角度： socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。
消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。
共享内存虽然无需拷贝，但控制复杂，难以使用。
安全性角度： Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。
传统IPC没有任何安全措施，完全依赖上层协议来确保。 传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加才能确保安全性。 传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。 效率角度 从对比图可以看出,Binder 在效率上是有优势的.
What Binder 是什么 因为 Binder 也是 CS 架构的一种,而 CS 架构最典型的就是 TCP/IP 请求了.下面做个对比,顺带类比以下 Binder 中的几个关键的概念. 背景 在开发中，经常需要通过 getSystemService 的方式获取一个系统服务,那么这些系统服务的 Binder 引用是如何传递给客户端的呢？要知道，系统服务并不是通过 startService() 启动的。
ServiceManager 管理的服务 ServiceManager 是一个独立进程，其作用如名称所示，管理各种系统服务.]]></description>
</item>
</channel>
</rss>
