<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Android - Tag - Tinggeng</title>
        <link>https://tinggengyan.github.io/tags/android/</link>
        <description>Android - Tag - Tinggeng</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>tinggengyan@gmail.com (Tinggeng)</managingEditor>
            <webMaster>tinggengyan@gmail.com (Tinggeng)</webMaster><lastBuildDate>Sun, 03 Apr 2022 16:19:04 &#43;0000</lastBuildDate><atom:link href="https://tinggengyan.github.io/tags/android/" rel="self" type="application/rss+xml" /><item>
    <title>一张思维导图看 Android【持续迭代】</title>
    <link>https://tinggengyan.github.io/2022/04/android_summary/</link>
    <pubDate>Sun, 03 Apr 2022 16:19:04 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2022/04/android_summary/</guid>
    <description><![CDATA[概述 总结自己的 Android 知识，按照编码 -&gt; 运行，画了一张图，xmind 导出的图比较大，后续持续更新，迭代这部分的内容。
下面是一些常见的知识,将会慢慢补充进思维导图内 Handler 与 Binder handler 处理的是 App 进程内的通信； binder 处理的是，App 进程间、application 和 framework 之间的通信；
任务启动管理 - 启动框架 抽象任务 task； 优先级 ； countdownlatch 数值为依赖 task 的数量； 运行的 executor ； 被依赖的 task 列表； toWait 方法； notify 方法，countdownlatch 减一； 构造 task 的有向无环图； TaskManager： 管理所有的 task，及其拓扑关系； 管理需要执行的 task； countdownlatch 值为 Activity 跳转的生命周期 ActivityA跳转到ActivityB： 1 2 3 4 5 Activity A：onPause Activity B：onCreate Activity B：onStart Activity B：onResume Activity A：onStop ActivityB返回ActivityA： 1 2 3 4 5 6 Activity B：onPause Activity A：onRestart Activity A：onStart Activity A：onResume Activity B：onStop Activity B：onDestroy 旋转屏幕 不改配置，默认配置 1 2 3 4 5 6 7 onPause--&gt; onStop--&gt; onDestroy--&gt; onCreate--&gt; onStart--&gt; onRestoreInstanceState--&gt; onResume--&gt; 修改配置 1 onConfigChanged--&gt; Activity 的启动模式 参考链接1]]></description>
</item>
<item>
    <title>mySoftware</title>
    <link>https://tinggengyan.github.io/2021/07/mysoftware/</link>
    <pubDate>Tue, 06 Jul 2021 19:57:21 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2021/07/mysoftware/</guid>
    <description><![CDATA[概述 记录我平时使用的一些软件,提效的,娱乐的.
快速打开 Raycast Alfred Contexts
目的: 用于快速打开应用软件和文件夹 其中比较知名的就是 Alfread了,我目前把它和Context进行配合使用.
Raycast 和 Alfred 差不多,Raycast 我装了,但是用的频率不高,目前没发现他有什么特别的亮点,用来作为 Alfred 的备选,毕竟免费.
Context有一个feature就是可以切换window,比如,AndroidStudio里打开了多个Project,形成了多个window,这说话,直接Alfred打开Androidstudio的话,只是打开了软件,至于哪个Window,有时候不清楚,这种情况下,Context 是个很好的补充. Context 的缺陷就是,他只是用来打开,已有的窗口的.
输入法 搜狗输入法
目前国内也就搜狗输入法还行了,当然百度也有Mac版本,但是体验上,还是搜狗好点.
终端 iterm2 oh-my-zsh Mac 下很好的终端工具了.目前没发现其他替代品;
Git fork Native开发,相比对sourceTree,颜值和性能都更高,无他,颜值即正义.
Android开发 AndroidStudio
开发Android必备,只是有一点至今让我诟病的地方,就是ActivityStack的打印被删除了&hellip;
C/Cpp开发 Clion
VSC配置cpp开发环境也试过,繁琐.Mac 下的Xcode也用过,感觉一般, 不得不说,jetbrains做的IDE,真香.
Java开发 IntellijIdea Eclipse NetBeans
目前在用的就是 IntellijIdea 了,其他的基本不用了.只有一个 NetBeans 在某些场景下是有优势的,那就是JavaSE GUI开发的时候.
清除广告 AdBlock Pro 清除Safari广告用; 看动漫太多的广告了,Chrome 上清除广告很容易,Safari就只能依赖这个plugin了.
database DataGrip 一个客户端,支持查看所有的数据库,jetbrains太香了.
分屏 Grid
windows 系统有个自动管理窗口的功能,这个软件就是在Mac上实现类似的功能;
扩展屏幕 Deskreen 只要有个浏览器就可以实现屏幕的扩展,有时候可以将自己的iPad用上.
statusbar 隐藏图标 Dozer Bartender]]></description>
</item>
<item>
    <title>OkHttp学习之简介(1)</title>
    <link>https://tinggengyan.github.io/2021/02/okhttp-1/</link>
    <pubDate>Tue, 09 Feb 2021 16:09:59 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2021/02/okhttp-1/</guid>
    <description><![CDATA[概述 回顾一下 OKHttp 这个优秀库,画了张思维导图.]]></description>
</item>
<item>
    <title>AndroidStudio调试framework源码</title>
    <link>https://tinggengyan.github.io/2020/06/as-debug-framework/</link>
    <pubDate>Tue, 23 Jun 2020 10:42:04 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/06/as-debug-framework/</guid>
    <description><![CDATA[概述 debug 是学习流程最快的方式,也是验证想法最好的方法.记录 Androidstudio 如何debug Android framework的代码.
使用无 AOSP 的代码(Java层) 这是最简单方便的方式了.
下载某个版本的 Android Source code 确认 Source code 正确下载了.
新建项目,所用的 compile SDK 版本为需要调试的代码版本 1 2 3 4 5 android { // 设置成需要需要分析的,且已下载源码的版本 compileSdkVersion 29 ...... } 新建并启动对应版本的模拟器. 打断点; 这里以系统的 ActivityManagerService 为例. 因为ActivityManagerService 并未导出到Android.jar,所以无法直接搜索定位到 .java文件,所以采用双击shift的方式,检索文件. attach 到对应的进程,运行,查看断点. ActivityManagerService 这个类是在系统 system_process 进程中的,所以,需要对system_process 进程进行 attach 操作. 小结 至此,经过如上操作,就可以对某个类进行debug操作了.对于分析framework代码也是方便的很.
可能遇到的问题 有时候还是会遇到代码行号不匹配,debug定位的代码行号不对,目前原因未知,应该是source code 和生成模拟器镜像的代码有出入. 没有好的解决办法,有个替代的方案.
断点后,有明确的thread stack信息; 找到最早一个可以定位准备行号的函数; 针对这个函数进行 findByUsage,在查出的结果中,查找stack信息指引的函数. 使用 AOSP 的源码进行调试 上述的方法基本能满足常见的debug需求了.但是有个前提是,debug的设备基本只能是模拟器或者装了官方release镜像的亲儿子. 对于有修改ROM需求的情况下,debug 则需要导入 aosp 中framework 的代码.]]></description>
</item>
<item>
    <title>jdk携带的一个HttpServer实现</title>
    <link>https://tinggengyan.github.io/2020/04/jdk-httpserver/</link>
    <pubDate>Mon, 20 Apr 2020 18:57:56 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2020/04/jdk-httpserver/</guid>
    <description><![CDATA[概述 记录一个意外发现的一个类 com.sun.net.httpserver.HttpsServer. 一个 Http 的 Server 端.
用处 适用于泛前端类开发者,在无后端服务的情况下,可以用来mock数据或者mock后端行为,非常灵活. 适用于网络库的开发者,测试库的行为; 缺点 目前不支持HTTP2协议. 分类 HTTP 协议 自定义一个 HTTP 服务; 1 2 3 4 5 6 HttpsServer server = HttpsServer.create(new InetSocketAddress(8500), 0); HttpsConfigurator httpsConfigurator = new HttpsConfigurator(SSLContext.getDefault()); server.setHttpsConfigurator(httpsConfigurator); HttpContext context = server.createContext(&#34;/example&#34;); context.setHandler(new CustomHttpHandler()); server.start(); 该 Http 服务,是在本机的 8500 端口启动的; 根目录为 example. 所以,直接通过 http://127.0.0.1:8500/example 即可访问.
Server 的行为定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class CustomHttpHandler implements HttpHandler { @Override public void handle(HttpExchange exchange) throws IOException { URI requestURI = exchange.]]></description>
</item>
<item>
    <title>RxAndroid入门分享(二)</title>
    <link>https://tinggengyan.github.io/2016/02/rxandroidintroduction2/</link>
    <pubDate>Fri, 26 Feb 2016 22:50:26 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2016/02/rxandroidintroduction2/</guid>
    <description><![CDATA[概述 本文记录 RxJava 中在 Android 中的应用,介绍 RxAndroid 的使用.
More RxJava 及其在Android上的应用 开发环境 在 module 的 gradle 中添加 RxAndroid 的相关依赖，如果想体验 rx 在 Android 上的更方便的功能。可以添加 Jake 大神的兼容包 RxBinding。 1 2 3 4 5 6 7 8 9 //RXAndroid compile &#39;io.reactivex:rxandroid:1.1.0&#39; //RxBinding compile &#39;com.jakewharton.rxbinding:rxbinding:0.3.0&#39; compile &#39;com.jakewharton.rxbinding:rxbinding-support-v4:0.3.0&#39; compile &#39;com.jakewharton.rxbinding:rxbinding-appcompat-v7:0.3.0&#39; compile &#39;com.jakewharton.rxbinding:rxbinding-design:0.3.0&#39; compile &#39;com.jakewharton.rxbinding:rxbinding-recyclerview-v7:0.3.0&#39; //compile &#39;com.jakewharton.rxbinding:rxbinding-leanback-v17:0.3.0&#39; 以下开始用一个demo来演示 目的地有三个 tab，每个 tab 内的详情用 RecyclerView 展示，下拉刷新用 SwipeRefreshLayout。 布局界面如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;?]]></description>
</item>
<item>
    <title>RxAndroid入门分享(一)</title>
    <link>https://tinggengyan.github.io/2016/02/rxandroidintroduction1/</link>
    <pubDate>Mon, 08 Feb 2016 21:44:26 &#43;0000</pubDate>
    <author>Tinggeng</author>
    <guid>https://tinggengyan.github.io/2016/02/rxandroidintroduction1/</guid>
    <description><![CDATA[概述 本文记录 RxJava 的概念.
RxJava 以及响应式函数思想篇 Why 技术产生的背景 在编程中，经常需要切换线程，为了能对结果进行相应处理，经常需要进行回调，随着业务需求的增加，嵌套的回调也会随之增加，不仅增加了代码量，也增加了逻辑的复杂性，增加了理解和维护的难度。 所以就需要一种
既能方便切换线程 又能即是相应变化 又可以简化代码的逻辑，方便维护， 还不需要回调。 What ReactiveX是什么 Reactive Extensions,简称 RX，原来只是微软开发的一个 LINQ 的一个扩展。
微软给的定义是，Rx 是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用 Rx，开发者可以用Observables 表示异步数据流，用 LINQ 操作符查询异步数据流，用 Schedulers 参数化异步数据流的并发处理，Rx 可以这样定义：Rx = Observables + LINQ + Schedulers。
ReactiveX.io 给的定义是，Rx 是一个使用可观察数据流进行异步编程的编程接口，ReactiveX 结合了观察者模式、迭代器模式和函数式编程的精华。
看完微软给的定义已经很详细了，开源组织给的更加精简，里面提到了数据流还有事件，我们来自己看看怎么理解。
这里得提到响应式编程的概念，其中有两个关键点，
事件，事件可以被观察，等待，过滤，响应，也可以触发其他的事件，事件通过数据流的形式对外呈现。 数据流，数据流就像一条河：它可以被观测，被过滤，被操作，或者与另外一条流合并为一条新的流来给新的消费者消费。 所以，响应式编程就是一种基于异步数据流概念的编程模式。其实 EventBus 还有其他的点击事件一样，本质上就是异步的数据流，我们可以为任何的事件创建数据流。比如我们可以为登录操作创建数据流，然后监听这个数据流，进行登录验证这样的响应操作。
主要特点有：
易于并发从而更好的利用服务器的能力。 易于有条件的异步执行。 一种更好的方式来避免回调地狱。 一种响应式方法。 RxJava与传统的Java的不同 在 Rx 中，开发者用 Observables 模拟可被观察的异步数据流，从纯 Java 的观点看，RxJava 的 Observable 类源自于经典的 Gang Of Four 的观察者模式。
与传统观察者的不同 它添加了三个缺少的功能：
生产者在没有更多数据可用时能够发出信号通知：onCompleted()事件。 生产者在发生错误时能够发出信号通知：onError()事件。 RxJava Observables 能够组合而不是嵌套，从而避免开发者陷入回调地狱。 与传统的Iterable的不同 Observables 和 IterablesAPI 是很相似的：我们在 Iterable 可以执行的许多操作也都同样可以在 Observables 上执行。当然，由于 Observables 流的本质，没有如Iterable.]]></description>
</item>
</channel>
</rss>
